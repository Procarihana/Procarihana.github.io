<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FAFA Blog</title>
    <link>https://procarihana.github.io/public/</link>
    <description>Recent content on FAFA Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 30 Aug 2020 17:47:43 +0800</lastBuildDate>
    
	<atom:link href="https://procarihana.github.io/public/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java 部署</title>
      <link>https://procarihana.github.io/public/posts/java-%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Sun, 30 Aug 2020 17:47:43 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java-%E9%83%A8%E7%BD%B2/</guid>
      <description>应用开发流程  产品调研 产品设计 系统设计 -&amp;gt; 全后端文档等 开发 测试 部署  Web应用是怎么工作的  默认443端口 每个HTTP请求背后都是一台主机  分布式  解决用户量大的问题   垂直扩展 ：购入更好的机器     水平扩展 ： 购入更多的机器（分布式）      负载均衡器 Load Balance   负载均衡 容灾（单点故障）：一个服务器故障也不会影响到业务    如何保持数据一致性   让负载均衡器保证同一个用户的请求都发到同一台机器上，但是HTTP是无状态的，同一个用户的不同请求是没有先后顺序的，没有用户标识，都是HTTP请求，即使有Cookie也不行     单一数据源：数据都存在同一个数据库，即使服务器杀死重启复原数据都不会改变，但是不能够避免单点故障的问题，数据库会出问题      大多数情况下，数据库都是稳定的。 数据库会有备份   部署  分库分表  </description>
    </item>
    
    <item>
      <title>JAVA IO</title>
      <link>https://procarihana.github.io/public/posts/io/</link>
      <pubDate>Sun, 30 Aug 2020 15:29:44 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/io/</guid>
      <description>cpu 负责所有运算
  3GHz 每秒运行30亿条指令，做一件事情只需要0.38纳秒
   SSD（固态硬盘）：寻址时间太慢了，和CPU形成矛盾     内存：存数据，断电丢失     硬盘（硬盘驱动器） 存数据容量大，断电不丢失    一个文件本质上是一段字节流，由一个执行程序决定怎么执行一段字节流（16进制）
  字节范围 0～255
一切文件的本质  一段字节流：   文本文件（txt/代码/HTML等）     二进制文件   每个程序负责解释文件中的字节流  输入输出是站在程序的角度
InputStream/PutputStream  抽象的输入/输出操作   从文件读取字节流 【实战】    value ==-1 的时候，循环结束
 -从网络读取字节流【实战】 -从其他
最好使用绝对路径
抽象类不能直接实例化，因为抽象类里面包含还没有实现的方法 InputStream…… 这种只是抽象方法，不能够直接实现 用ProcessBuilder建立新的进程  Java中的File   file 代表的是文件路径</description>
    </item>
    
    <item>
      <title>计算机网络TCP and SOCket</title>
      <link>https://procarihana.github.io/public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Ctcp-and-socket/</link>
      <pubDate>Sun, 30 Aug 2020 11:39:13 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Ctcp-and-socket/</guid>
      <description>没有100%可靠的通信协议  红军/蓝军 计算机网络：虚电路分组，A服务器把报文给离目标IP最近的力所能及的设备（过程为HOP），这个设备再把报文发给下一个设备，如果中间某个最佳的设备被毁，就选择另一个设备绕过，直到到达目标IP（快递发货）   网络分层模型  TCP/IP模型（应用层、传输层【四层交换机、四层路由器】、网络层【路由器，三层交换机】） TCP Transmisson Control ProTocal 传输控制协议   TCP的握手与断开       三次握手建立连接        SYN SENT seq = x 发送请求建立连接的请求 -&amp;gt; 获得SYN seq=y,ACK x+1 （同意建立请求） ACK =y+1 表明收到同意建立连接 ==&amp;gt; 连接建立，        四次挥手断开连接        FIN seq = x+2 ACK = y+1发送断链接的请求 -&amp;gt; 获得ACK x+3 表示收到，又获得 FIN seq= y+1 表示断开链接 ACK = y+2 表示收到同意断开链接        如果中间有信息丢掉没有成功收到，会通过请求超时来知道链接断开成功     TCP 协议无法传递数据包，只能把所有数据包拆、黏包   TCP 没有规定包的界限，需要自己设计协议、分隔符、结束符来设计包的边界   TCP 中的数据包含TCP 包首部和数据两个部分，而IP中的数据包含前两个部分，在加上IP包首部 TCP 只有两个字节的端口（65536），端口数量有限制（同时使用），而每个端口访问的对象是不限制   TCP数据里面有确认号码，如果接受的没有收到，就需要重传。校验和可以检验数据是否有被串改，如果有则向发送的一方放再次发送请求 的   以太网则在IP数据的基础杀昂添加以太网包首部 TCP特点   面向连接     点对点 需要有目标端口     可靠交付 校验和、序列号码、确认号码 保证数据正确     面向字节流   UDP 协议（用于视频）   无连接的 无法保证数据是否到达     尽最大可能交付     面向报文的    Socket    </description>
    </item>
    
    <item>
      <title>AccountingService</title>
      <link>https://procarihana.github.io/public/posts/accountingservice/</link>
      <pubDate>Mon, 10 Aug 2020 20:48:22 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/accountingservice/</guid>
      <description>.ignore放什么 1 *.iml 是 intellij idea的工程配置文件，里面是当前project的一些配置信息。.Idea存放项目的配置信息，包括历史记录，版本控制信息等。 2. .idea/ 3. target/
项目结构和模型转换  external 用于存放外部团队的接口和服务，然后再Manager里面放。在接口处写注析。 exception 异常处理 config 存放MybatisBean等等的Bean Controller 存放SpringBoot对外接口（API接口）   不要有过多的处理逻辑 参数校验越早做越好  manager 组合各个业务的逻辑 先写接口后写实现 Dao Converter 用于转换 Moudle的common向service等等的转换但是不能够用于Http、数据库、IO等操作 Service 部分是给前段展示的内容，不能直接返回密码（加密后的还是可以的）等内容  添加Maven  通过Maven getting start  SpringBoot Spring boot 开发四大步  添加相应依赖   SpringBoot 引入       基础Maven引入：、spring-boot-starter-web、plugin     添加相应注解   添加Appliation类作为SpringBoot入口，并添加注解@SpringBootApplication     添加Controller类，并添加注解@RestController      @RestController == @Controller + @ResponseBodymapping    编写代码 添加相应配置   在resources里添加application.</description>
    </item>
    
    <item>
      <title>Spring Web</title>
      <link>https://procarihana.github.io/public/posts/spring-web/</link>
      <pubDate>Mon, 06 Jul 2020 15:29:45 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/spring-web/</guid>
      <description>Spring Web 和 HTTP进行沟通
从零开始⼀个Spring应⽤ • pom.xml • src/main/java/hello/Application.java • src/main/java/hello/HelloController.java
Query String 最简单的HTTP请求（查询字符串），就是</description>
    </item>
    
    <item>
      <title>HTML 标签</title>
      <link>https://procarihana.github.io/public/posts/html-%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Sat, 04 Jul 2020 17:11:23 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/html-%E6%A0%87%E7%AD%BE/</guid>
      <description>A标签  作用   跳转外部页面     跳转内部锚点     跳转到邮箱或电话等    href  超级链接  &amp;lt;body&amp;gt; &amp;lt;a herf = &amp;#34;https://google.com&amp;#34; target=&amp;#34;_blank&amp;#34; download&amp;gt;超链&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; target  在哪个窗口打开超级链接   在空白页打开超级链接     在    download rel=noopener target  在哪个窗口打开超级链接   在空白页打开    &amp;lt;a href=&amp;#34;//goole.com&amp;#34; target=_blank&amp;gt;top&amp;lt;/a&amp;gt;    在顶层打开链接（正常打开链接）&amp;ndash; top     在本层打开（Google 不允许用iframe指向，所以打不开，如果可以打开，则可以再其他页面直接打开）    如何在编辑过程中正确打开html  http-server   安装    $ yarn global add http-server   启动并点击任一网址，要编写路径</description>
    </item>
    
    <item>
      <title>Java面向对象————多态</title>
      <link>https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</link>
      <pubDate>Mon, 11 May 2020 17:20:16 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</guid>
      <description>面向对象的三大特征 封装 继承 多态 多态：不同类的不同的实现方法
 方法名字变量都一样，但是子类继承后的实现不一样  重载：两个类同一个方法的不同实现,根据最接近的类型进行匹配
 方法名相同，参数表不一样  多态 实例方法本身是多态的 实例：一个方法不是静态的就是实例方法
通过区分有无Statci
 在运行时根据this（当前对象的实际类型）来决定调用哪个方法 []方法接收者  obj.method(1)
消息接受者.消息（参数）//接受者会根据消息的不同自行决定如何响应消息
 静态方法没有多态 参数静态绑定，接受者动态绑定 覆盖：重写父类中的方法，方法名、参数不能改变，但是返回值可以改变   多态只对方法的接受者生效     多态只选择接受者的类型，不选择参数的类型    public class Base { public void print(ParamBase param) { System.out.println(&amp;#34;I am Base,the param is ParamBase&amp;#34;); } public void print(ParamSub param){ System.out.println(&amp;#34;I am Base,the param is ParamSub&amp;#34;); } } public class Sub extends Base { @Override public void print(ParamBase param){ System.</description>
    </item>
    
    <item>
      <title>Java面向对象——组合与继承</title>
      <link>https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Mon, 11 May 2020 17:19:33 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/</guid>
      <description>三大特征 封装 继承 public class Animal { protected String name;
public Animal(String name) { this.name = name; } public void sayMyName() { System.out.println(&amp;quot;我的名字是&amp;quot; + name); } public class Cat extends Animal{ public Cat(String name) { super(name); } public void meow() { System.out.println(&amp;quot;喵&amp;quot; + name); } } public class Main { public static void main(String[] args) { Cat cat = new Cat(&amp;quot;ABC&amp;quot;); cat.meow(); cat.sayMyName(); }  多态 继承 DRY（Donot Repeat Yourself）  事不过三，三则重构  继承的本质是提炼出公用代码，避免重复 继承一个类就会自动继承类的行为</description>
    </item>
    
    <item>
      <title>Java 面向对象初步——封装与隐藏</title>
      <link>https://procarihana.github.io/public/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F/</link>
      <pubDate>Mon, 11 May 2020 17:18:58 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F/</guid>
      <description>面向对象的三大特征 封装 优点：实现细节可以发生变化，只要接口不变，就不会对使用产生影响 理念：对外暴露尽可能少的细节
继承 多态 封装 封装隐藏了内部实现细节，只暴露出接口 电灯对象 高、低耦合
  你只访问他的“开关”接口，不关心内部的“电路”细节
 public static void main(String[] args) { Light light = new Light(); light.turnOn();//低耦合 Light light2 = new Light(); light2.打开电路1(); light2.打开电路2(); light2.打开电路3(); //高耦合,比低耦合更难扩展 //Home类和Light类之间建立联系——&amp;gt;耦合（让改变变得困难） //一方进行改变时，另一方也需要进行改变 public class Light {  public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节
} public void 打开电路1(){
} public void 打开电路2(){
} public void 打开电路3(){
}
  废弃后使用自动停止，不影响其他代码的运行
public class Light { @Deprecated public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节 } public static void main(String[] args) { Light light = new Light();  light.</description>
    </item>
    
    <item>
      <title>Java 面向对象初步</title>
      <link>https://procarihana.github.io/public/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5/</link>
      <pubDate>Mon, 11 May 2020 17:18:01 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5/</guid>
      <description>面向对象的三大特征 封装 优点：实现细节可以发生变化，只要接口不变，就不会对使用产生影响
继承 多态 封装 封装隐藏了内部实现细节，只暴露出接口 电灯对象   你只访问他的“开关”接口，不关心内部的“电路”细节
 public static void main(String[] args) { Light light = new Light(); light.turnOn();//低耦合 Light light2 = new Light(); light2.打开电路1(); light2.打开电路2(); light2.打开电路3(); //高耦合,比低耦合更难扩展 //Home类和Light类之间建立联系——&amp;gt;耦合（让改变变得困难） //一方进行改变时，另一方也需要进行改变 public class Light {  public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节
} public void 打开电路1(){
} public void 打开电路2(){
} public void 打开电路3(){
}
  废弃后使用自动停止，不影响其他代码的运行
public class Light { @Deprecated public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节 } public static void main(String[] args) { Light light = new Light();  light.</description>
    </item>
    
    <item>
      <title>Java面向对象系统基础</title>
      <link>https://procarihana.github.io/public/posts/java%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 07 May 2020 16:40:59 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</guid>
      <description>对象（引用类型）  对象是数据和行为的集合（主观能动性） 一切使用new运算符创建出来的都是对象   new Object（）     特例： Integer i=2/String s= &amp;ldquo;2&amp;rdquo; 自动装拆箱的时候后会自动new 出一个新的对象     特例：new Object[]    对象组成？  所有的对象都在堆上分配 每个对象都包含⾃⼰的数据（成员变量）   初始化
声明int age = 0; 和int age;是相同的，因为默认初始化的值为0 【整数类型】
String 等引用类型的为null   原⽣类型的成员 引⽤类型的成员  栈、堆 栈：方法栈，main执行后需要用到的方法都会放到方法栈里面执行 堆：存放对象
对象的构造函数  新建对象的唯⼀途径 在堆上分配空间 执⾏必要的初始化⼯作 执⾏构造器函数 如果没有任何构造器，编译器会偷偷摸摸帮你⽣成⼀个  对象的方法  数据：有什么 方法：做什么  方法的重载(overload)  重载（overload）与重写/覆盖（override）    重载</description>
    </item>
    
    <item>
      <title>Java的控制流</title>
      <link>https://procarihana.github.io/public/posts/java%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/</link>
      <pubDate>Wed, 06 May 2020 21:05:25 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/</guid>
      <description>控制流 控制流：方法调用 方法调用就是一个方法栈，每当开始一个新的方法调用的时候就会开启一个方法栈的栈针，方法调用之后方法针会被销毁。当有新的方法调用的时候就会开始新一轮的方法栈，循环往复。
while与 do while 循环   while（返回boolean语句)
{
……
}
  do {无论真假就先执行一遍}
while{(返回 boolean语句）;}
  控制流：for 循环   fori
 for（int i = 0;//任何语句，包括空语句 1️⃣ i &amp;lt; 100;//返回boolean的语句，包括空语句 2️⃣ i++){//任何语句，包括空语句） 4️⃣ System.out.println(i); //3️⃣ }    for each
for（String s :Iterable）{ …… }
  对象能够实现Iterabie接口（可迭代）
List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;); //遍历列表，把元素拿出来 for (int i = ;i&amp;lt;list.size(); i++){ System.out.println(list.get(i)); } == for(String element : list){ System.</description>
    </item>
    
    <item>
      <title>爬虫项目</title>
      <link>https://procarihana.github.io/public/posts/%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Wed, 06 May 2020 17:07:22 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/</guid>
      <description>原则  使用GitHub+主干/分支模型进行开发 禁止直接push master 所有的变更通过PR进行 自动化代码质量检查+测试 Checkstyle/SpotBugs 最基本的自动化测试覆盖 一切工作自动化 规范化提交流程   创建仓库流程   Github -new
  建立新项目 newBranch 的时候选Apache License 2.0
   Mvn archetype     IDEA - new     copy （cp -r ～/* .）    .gitigonre
  git commit &amp;ndash;amend 就可以把这一次的commit和上一次的合并起来
   记得要把.iml 放进（vi .gitignore）： *.iml和target/(放在最后一行就好) 更改pom 里面的groundId，artifactId cp -r ～/.circleci . (因为之前cp ～* 的时候并不会cp到.</description>
    </item>
    
    <item>
      <title>IDEAMaven调试器的基本使用</title>
      <link>https://procarihana.github.io/public/posts/ideamaven%E8%B0%83%E8%AF%95%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 06 May 2020 17:06:17 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/ideamaven%E8%B0%83%E8%AF%95%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid>
      <description>SpotBugs  Maven 生命周期
设置生命周期后的Maven会在相应的阶段执行 Picture 设置 生命周期对应执行的工作需要绑定插件进行设置   complie —— goal ——&amp;gt; maven-compilen-plugin test —— goal ——&amp;gt; surefire 测试插件 verlfy —— goal ——&amp;gt; checkstyle（非核心插件可以绑定到任何阶段  </description>
    </item>
    
    <item>
      <title>Java的运算系统</title>
      <link>https://procarihana.github.io/public/posts/java%E7%9A%84%E8%BF%90%E7%AE%97%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 01 May 2020 16:42:24 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java%E7%9A%84%E8%BF%90%E7%AE%97%E7%B3%BB%E7%BB%9F/</guid>
      <description>基本运算   /
int b = 5/2; &amp;ndash;&amp;gt;结果为 &amp;lsquo;2&amp;rsquo;（地板除）
  取余运算
5/2=2……1
System.out.println(9 % 5);——&amp;gt;2 System.out.println(-9 % 5);——&amp;gt;-2(余数)      判断奇偶
通过取余是否为零完成
//判断一个整数是不是奇数 public static boolean isOdd(int number){ return number % 2 != 0; }    运算符
    += ，-= ，*=，/=
Eg：a+=2 | a = a+2
  += a +=3 ==&amp;gt; a = a + 3
  -= a -=3 ==&amp;gt;a - e</description>
    </item>
    
    <item>
      <title>Java的数据类型</title>
      <link>https://procarihana.github.io/public/posts/java%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 29 Apr 2020 15:16:54 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>数据类型  两种数据类型   原生数据 赋值的是值本身     原生数据 字节 最小值 最大值     byte 1     short 2  0*7fffffff(21亿)   int 4     long 8  2^63-1   float 4     double 8     char 2       boolean true/false void     存储数据超过最大值会溢出</description>
    </item>
    
    <item>
      <title>Java程序的基本结构</title>
      <link>https://procarihana.github.io/public/posts/java%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 28 Apr 2020 16:58:28 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</guid>
      <description>Java程序的基本结构 Java 简述  强类型：在内存的每一个数据都需要和一个类型相绑定   即使数据相同，但是类型不一样，解释的方式也不一样  静态   Java code &amp;ndash;&amp;gt; 字节码 （编译）  跨平台性能   操作系统  Linux、windows、mac…… 不同的操作系统有不同的语言 （API 【Application Programming Interface】 应用编程接口）&amp;ndash;&amp;gt;实现跨平台就要通过JVM实现   JVM 【Java Vitual Mach】（Java虚拟机） 字节码   最小单位为字节，八个字节为一个字节码   Java 成句基本结构 类和包的关系  基本结构&amp;ndash;类，Java 程序的最小的结构单元，按照约定放在自己同名的&amp;rsquo;.java&amp;rsquo; 文件中 每个 Class 都处于一个package中 Package 的名字是相对于src决定的，也就是由目录结构确定的，名字通常用域名的倒叙 如果class 直接放在java文件夹下面，就不会显示package 因为处于默认包里面  包的意义  类的名字是一个简单的字符串，通过包更容易区分 Eg：通过运用全限定类名，可以用于区分不同的同名类   全限定类名 ：包含包名的类&amp;ndash;&amp;gt;package.class  可以通过import引入包，可以让引用类的编写更加便捷  第三方包的引用  Maven 当方法属于Java.</description>
    </item>
    
    <item>
      <title>The Second Test</title>
      <link>https://procarihana.github.io/public/posts/the-second-test/</link>
      <pubDate>Sun, 26 Apr 2020 18:49:13 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/the-second-test/</guid>
      <description>Test Second </description>
    </item>
    
    <item>
      <title>TEST</title>
      <link>https://procarihana.github.io/public/posts/test/</link>
      <pubDate>Sat, 25 Apr 2020 23:50:04 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/test/</guid>
      <description>TEST &amp;ndash; OK? ???
I am fine</description>
    </item>
    
  </channel>
</rss>