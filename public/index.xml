<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FAFA Blog</title>
    <link>https://procarihana.github.io/</link>
    <description>Recent content on FAFA Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Mon, 06 Jul 2020 15:29:45 +0800</lastBuildDate>
    
	<atom:link href="https://procarihana.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Spring Web</title>
      <link>https://procarihana.github.io/posts/spring-web/</link>
      <pubDate>Mon, 06 Jul 2020 15:29:45 +0800</pubDate>
      
      <guid>https://procarihana.github.io/posts/spring-web/</guid>
      <description>Spring Web 和 HTTP进行沟通
从零开始⼀个Spring应⽤ • pom.xml • src/main/java/hello/Application.java • src/main/java/hello/HelloController.java
Query String 最简单的HTTP请求（查询字符串），就是</description>
    </item>
    
    <item>
      <title>HTML 标签</title>
      <link>https://procarihana.github.io/posts/html-%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Sat, 04 Jul 2020 17:11:23 +0800</pubDate>
      
      <guid>https://procarihana.github.io/posts/html-%E6%A0%87%E7%AD%BE/</guid>
      <description>A标签  作用   跳转外部页面     跳转内部锚点     跳转到邮箱或电话等    href  超级链接  &amp;lt;body&amp;gt; &amp;lt;a herf = &amp;#34;https://google.com&amp;#34; target=&amp;#34;_blank&amp;#34; download&amp;gt;超链&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; target  在哪个窗口打开超级链接   在空白页打开超级链接     在    download rel=noopener target  在哪个窗口打开超级链接   在空白页打开    &amp;lt;a href=&amp;#34;//goole.com&amp;#34; target=_blank&amp;gt;top&amp;lt;/a&amp;gt;    在顶层打开链接（正常打开链接）&amp;ndash; top     在本层打开（Google 不允许用iframe指向，所以打不开，如果可以打开，则可以再其他页面直接打开）    如何在编辑过程中正确打开html  http-server   安装    $ yarn global add http-server   启动并点击任一网址，要编写路径</description>
    </item>
    
    <item>
      <title>Java面向对象————多态</title>
      <link>https://procarihana.github.io/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</link>
      <pubDate>Mon, 11 May 2020 17:20:16 +0800</pubDate>
      
      <guid>https://procarihana.github.io/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</guid>
      <description>面向对象的三大特征 封装 继承 多态 多态：不同类的不同的实现方法
 方法名字变量都一样，但是子类继承后的实现不一样  重载：两个类同一个方法的不同实现,根据最接近的类型进行匹配
 方法名相同，参数表不一样  多态 实例方法本身是多态的 实例：一个方法不是静态的就是实例方法
通过区分有无Statci
 在运行时根据this（当前对象的实际类型）来决定调用哪个方法 []方法接收者  obj.method(1)
消息接受者.消息（参数）//接受者会根据消息的不同自行决定如何响应消息
 静态方法没有多态 参数静态绑定，接受者动态绑定 覆盖：重写父类中的方法，方法名、参数不能改变，但是返回值可以改变   多态只对方法的接受者生效     多态只选择接受者的类型，不选择参数的类型    public class Base { public void print(ParamBase param) { System.out.println(&amp;#34;I am Base,the param is ParamBase&amp;#34;); } public void print(ParamSub param){ System.out.println(&amp;#34;I am Base,the param is ParamSub&amp;#34;); } } public class Sub extends Base { @Override public void print(ParamBase param){ System.</description>
    </item>
    
    <item>
      <title>Java面向对象——组合与继承</title>
      <link>https://procarihana.github.io/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Mon, 11 May 2020 17:19:33 +0800</pubDate>
      
      <guid>https://procarihana.github.io/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/</guid>
      <description>三大特征 封装 继承 public class Animal { protected String name;
public Animal(String name) { this.name = name; } public void sayMyName() { System.out.println(&amp;quot;我的名字是&amp;quot; + name); } public class Cat extends Animal{ public Cat(String name) { super(name); } public void meow() { System.out.println(&amp;quot;喵&amp;quot; + name); } } public class Main { public static void main(String[] args) { Cat cat = new Cat(&amp;quot;ABC&amp;quot;); cat.meow(); cat.sayMyName(); }  多态 继承 DRY（Donot Repeat Yourself）  事不过三，三则重构  继承的本质是提炼出公用代码，避免重复 继承一个类就会自动继承类的行为</description>
    </item>
    
    <item>
      <title>Java 面向对象初步——封装与隐藏</title>
      <link>https://procarihana.github.io/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F/</link>
      <pubDate>Mon, 11 May 2020 17:18:58 +0800</pubDate>
      
      <guid>https://procarihana.github.io/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F/</guid>
      <description>面向对象的三大特征 封装 优点：实现细节可以发生变化，只要接口不变，就不会对使用产生影响 理念：对外暴露尽可能少的细节
继承 多态 封装 封装隐藏了内部实现细节，只暴露出接口 电灯对象 高、低耦合
  你只访问他的“开关”接口，不关心内部的“电路”细节
 public static void main(String[] args) { Light light = new Light(); light.turnOn();//低耦合 Light light2 = new Light(); light2.打开电路1(); light2.打开电路2(); light2.打开电路3(); //高耦合,比低耦合更难扩展 //Home类和Light类之间建立联系——&amp;gt;耦合（让改变变得困难） //一方进行改变时，另一方也需要进行改变 public class Light {  public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节
} public void 打开电路1(){
} public void 打开电路2(){
} public void 打开电路3(){
}
  废弃后使用自动停止，不影响其他代码的运行
public class Light { @Deprecated public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节 } public static void main(String[] args) { Light light = new Light();  light.</description>
    </item>
    
    <item>
      <title>Java 面向对象初步</title>
      <link>https://procarihana.github.io/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5/</link>
      <pubDate>Mon, 11 May 2020 17:18:01 +0800</pubDate>
      
      <guid>https://procarihana.github.io/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5/</guid>
      <description>面向对象的三大特征 封装 优点：实现细节可以发生变化，只要接口不变，就不会对使用产生影响
继承 多态 封装 封装隐藏了内部实现细节，只暴露出接口 电灯对象   你只访问他的“开关”接口，不关心内部的“电路”细节
 public static void main(String[] args) { Light light = new Light(); light.turnOn();//低耦合 Light light2 = new Light(); light2.打开电路1(); light2.打开电路2(); light2.打开电路3(); //高耦合,比低耦合更难扩展 //Home类和Light类之间建立联系——&amp;gt;耦合（让改变变得困难） //一方进行改变时，另一方也需要进行改变 public class Light {  public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节
} public void 打开电路1(){
} public void 打开电路2(){
} public void 打开电路3(){
}
  废弃后使用自动停止，不影响其他代码的运行
public class Light { @Deprecated public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节 } public static void main(String[] args) { Light light = new Light();  light.</description>
    </item>
    
    <item>
      <title>Java面向对象系统基础</title>
      <link>https://procarihana.github.io/posts/java%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 07 May 2020 16:40:59 +0800</pubDate>
      
      <guid>https://procarihana.github.io/posts/java%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</guid>
      <description>对象（引用类型）  对象是数据和行为的集合（主观能动性） 一切使用new运算符创建出来的都是对象   new Object（）     特例： Integer i=2/String s= &amp;ldquo;2&amp;rdquo; 自动装拆箱的时候后会自动new 出一个新的对象     特例：new Object[]    对象组成？  所有的对象都在堆上分配 每个对象都包含⾃⼰的数据（成员变量）   初始化
声明int age = 0; 和int age;是相同的，因为默认初始化的值为0 【整数类型】
String 等引用类型的为null   原⽣类型的成员 引⽤类型的成员  栈、堆 栈：方法栈，main执行后需要用到的方法都会放到方法栈里面执行 堆：存放对象
对象的构造函数  新建对象的唯⼀途径 在堆上分配空间 执⾏必要的初始化⼯作 执⾏构造器函数 如果没有任何构造器，编译器会偷偷摸摸帮你⽣成⼀个  对象的方法  数据：有什么 方法：做什么  方法的重载(overload)  重载（overload）与重写/覆盖（override）    重载</description>
    </item>
    
    <item>
      <title>Java的控制流</title>
      <link>https://procarihana.github.io/posts/java%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/</link>
      <pubDate>Wed, 06 May 2020 21:05:25 +0800</pubDate>
      
      <guid>https://procarihana.github.io/posts/java%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/</guid>
      <description>控制流 控制流：方法调用 方法调用就是一个方法栈，每当开始一个新的方法调用的时候就会开启一个方法栈的栈针，方法调用之后方法针会被销毁。当有新的方法调用的时候就会开始新一轮的方法栈，循环往复。
while与 do while 循环   while（返回boolean语句)
{
……
}
  do {无论真假就先执行一遍}
while{(返回 boolean语句）;}
  控制流：for 循环   fori
 for（int i = 0;//任何语句，包括空语句 1️⃣ i &amp;lt; 100;//返回boolean的语句，包括空语句 2️⃣ i++){//任何语句，包括空语句） 4️⃣ System.out.println(i); //3️⃣ }    for each
for（String s :Iterable）{ …… }
  对象能够实现Iterabie接口（可迭代）
List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;); //遍历列表，把元素拿出来 for (int i = ;i&amp;lt;list.size(); i++){ System.out.println(list.get(i)); } == for(String element : list){ System.</description>
    </item>
    
    <item>
      <title>爬虫项目</title>
      <link>https://procarihana.github.io/posts/%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Wed, 06 May 2020 17:07:22 +0800</pubDate>
      
      <guid>https://procarihana.github.io/posts/%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/</guid>
      <description>原则  使用GitHub+主干/分支模型进行开发 禁止直接push master 所有的变更通过PR进行 自动化代码质量检查+测试 Checkstyle/SpotBugs 最基本的自动化测试覆盖 一切工作自动化 规范化提交流程   创建仓库流程   Github -new
  建立新项目 newBranch 的时候选Apache License 2.0
   Mvn archetype     IDEA - new     copy （cp -r ～/* .）    .gitigonre
  git commit &amp;ndash;amend 就可以把这一次的commit和上一次的合并起来
   记得要把.iml 放进（vi .gitignore）： *.iml和target/(放在最后一行就好) 更改pom 里面的groundId，artifactId cp -r ～/.circleci . (因为之前cp ～* 的时候并不会cp到.</description>
    </item>
    
    <item>
      <title>IDEAMaven调试器的基本使用</title>
      <link>https://procarihana.github.io/posts/ideamaven%E8%B0%83%E8%AF%95%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 06 May 2020 17:06:17 +0800</pubDate>
      
      <guid>https://procarihana.github.io/posts/ideamaven%E8%B0%83%E8%AF%95%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid>
      <description>SpotBugs  Maven 生命周期
设置生命周期后的Maven会在相应的阶段执行 Picture 设置 生命周期对应执行的工作需要绑定插件进行设置   complie —— goal ——&amp;gt; maven-compilen-plugin test —— goal ——&amp;gt; surefire 测试插件 verlfy —— goal ——&amp;gt; checkstyle（非核心插件可以绑定到任何阶段  </description>
    </item>
    
    <item>
      <title>Java的运算系统</title>
      <link>https://procarihana.github.io/posts/java%E7%9A%84%E8%BF%90%E7%AE%97%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 01 May 2020 16:42:24 +0800</pubDate>
      
      <guid>https://procarihana.github.io/posts/java%E7%9A%84%E8%BF%90%E7%AE%97%E7%B3%BB%E7%BB%9F/</guid>
      <description>基本运算   /
int b = 5/2; &amp;ndash;&amp;gt;结果为 &amp;lsquo;2&amp;rsquo;（地板除）
  取余运算
5/2=2……1
System.out.println(9 % 5);——&amp;gt;2 System.out.println(-9 % 5);——&amp;gt;-2(余数)      判断奇偶
通过取余是否为零完成
//判断一个整数是不是奇数 public static boolean isOdd(int number){ return number % 2 != 0; }    运算符
    += ，-= ，*=，/=
Eg：a+=2 | a = a+2
  += a +=3 ==&amp;gt; a = a + 3
  -= a -=3 ==&amp;gt;a - e</description>
    </item>
    
    <item>
      <title>Java的数据类型</title>
      <link>https://procarihana.github.io/posts/java%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 29 Apr 2020 15:16:54 +0800</pubDate>
      
      <guid>https://procarihana.github.io/posts/java%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>数据类型  两种数据类型   原生数据 赋值的是值本身     原生数据 字节 最小值 最大值     byte 1     short 2  0*7fffffff(21亿)   int 4     long 8  2^63-1   float 4     double 8     char 2       boolean true/false void     存储数据超过最大值会溢出</description>
    </item>
    
    <item>
      <title>Java程序的基本结构</title>
      <link>https://procarihana.github.io/posts/java%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 28 Apr 2020 16:58:28 +0800</pubDate>
      
      <guid>https://procarihana.github.io/posts/java%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</guid>
      <description>Java程序的基本结构 Java 简述  强类型：在内存的每一个数据都需要和一个类型相绑定   即使数据相同，但是类型不一样，解释的方式也不一样  静态   Java code &amp;ndash;&amp;gt; 字节码 （编译）  跨平台性能   操作系统  Linux、windows、mac…… 不同的操作系统有不同的语言 （API 【Application Programming Interface】 应用编程接口）&amp;ndash;&amp;gt;实现跨平台就要通过JVM实现   JVM 【Java Vitual Mach】（Java虚拟机） 字节码   最小单位为字节，八个字节为一个字节码   Java 成句基本结构 类和包的关系  基本结构&amp;ndash;类，Java 程序的最小的结构单元，按照约定放在自己同名的&amp;rsquo;.java&amp;rsquo; 文件中 每个 Class 都处于一个package中 Package 的名字是相对于src决定的，也就是由目录结构确定的，名字通常用域名的倒叙 如果class 直接放在java文件夹下面，就不会显示package 因为处于默认包里面  包的意义  类的名字是一个简单的字符串，通过包更容易区分 Eg：通过运用全限定类名，可以用于区分不同的同名类   全限定类名 ：包含包名的类&amp;ndash;&amp;gt;package.class  可以通过import引入包，可以让引用类的编写更加便捷  第三方包的引用  Maven 当方法属于Java.</description>
    </item>
    
    <item>
      <title>The Second Test</title>
      <link>https://procarihana.github.io/posts/the-second-test/</link>
      <pubDate>Sun, 26 Apr 2020 18:49:13 +0800</pubDate>
      
      <guid>https://procarihana.github.io/posts/the-second-test/</guid>
      <description>Test Second </description>
    </item>
    
    <item>
      <title>TEST</title>
      <link>https://procarihana.github.io/posts/test/</link>
      <pubDate>Sat, 25 Apr 2020 23:50:04 +0800</pubDate>
      
      <guid>https://procarihana.github.io/posts/test/</guid>
      <description>TEST &amp;ndash; OK? ???
I am fine</description>
    </item>
    
  </channel>
</rss>