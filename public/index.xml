<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FAFA Blog</title>
    <link>https://procarihana.github.io/public/</link>
    <description>Recent content on FAFA Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Wed, 21 Oct 2020 09:45:43 +0800</lastBuildDate>
    
	<atom:link href="https://procarihana.github.io/public/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>HTTP</title>
      <link>https://procarihana.github.io/public/posts/http/</link>
      <pubDate>Wed, 21 Oct 2020 09:45:43 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/http/</guid>
      <description>HTTP metood 第一个单词表明请求的方法
GET 请求 拿一个网页 请求的数据全部都放在HTTP request header中
Host 网络主机名的别称
DNS 把网络名编程IP地址 通过sudo 来改变本地 网络的DNS对应的IP地址 所有访问都要通过IP地址才能访问
local host == 127.0.1
反爬虫
  status 401/403
  在返回的数据中投毒
  POST 请求登陆
发送一个header，真正的数据保存在body里面
PUT DELETE HTTP status 状态码
2xx 200OK 表示请求成功
3xx 重定向 永久移动 并且会发送一个新的地址给你
4xx 客户端的错误，无法完成请求
用GET方法发送请求登陆获得405，客户端用错误的方法发出请求
5xx 服务器有问题
Joke:6xx HTTP 请求header 重要的header   Accept*
   Accept-Language    Cookie
  User-Agent 显示发出请求的客户端</description>
    </item>
    
    <item>
      <title>Java Security</title>
      <link>https://procarihana.github.io/public/posts/java-security/</link>
      <pubDate>Tue, 13 Oct 2020 20:39:19 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java-security/</guid>
      <description>[start.spring.io]
 Lombok 要编译就必须大家都用idea 有lombok ，且包含私有的java代码  </description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://procarihana.github.io/public/posts/redis/</link>
      <pubDate>Sat, 10 Oct 2020 13:32:57 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/redis/</guid>
      <description>分布式要防止单点故障  缓存基础  cache 位于速度相差较大的两种较大的两种硬件之间，用于协调两者数据输速度差异的结构 缓存是一个高速数据存储层，其中存储了数据子集，且通常是短暂性存储，这样日后再次请求该数据是，速度要比访问数据的主存储位置快。通过缓存，可以高效地重用之前检索或计算的数据 本质就是空间换时间，性能成本Tradeoff 减少对底层速度较慢的存储层的访问需求以此来提高数据检索性能，在容量换取速度方面，缓存通常是完整且持久地存储数据 缓存必要性   提升访问性能 降低网络拥堵 消除数据库热点   某个资源被大量访问，就需要对这个热点数据和相应的数据进行配置，通过预测性能来提前放在缓存里面  可预测的性能 减少后端负载 增加系统可扩展性  缓存特征指标  命中率   命中率 = 返回正确结果数、请求缓存次数     缓存率越高，缓存使用效率越高   最大空间   缓存中可以存放的最大元素数量   缓存生存时间 TTL   缓存可以存活的时间，超过时间就失效   缓存清空策略   缓存可使用的存储空间有限，占满后就需要清除一些缓存，清空策略就决定了要清空哪些缓存      FIFO : 先进先出 ，最先进入缓存的数据会被优先清除掉，比缓存元素的创建时间，优先保障最新数据可用 LFU (less frequently used): 最少使用，根据元素的使用次数判断，使用次数较少的数据将被删除 LRU(less recently used）: 最近最少使用，假设最近最少使用的这些信息，将来被使用的概率也不大，根据数据最后一次被使用的时间戳来决定，把最老的诗句删掉 定时过期：每个设置过时间的key都需要创建一个定时器，到过期时间就会立即清除 惰性过期：只有当访问一个key时，才会判断该key是否已经过期，过期则清除 最长过期： 根据过期时间，清理最长时间没用的 随机过期清理：根据过期时间，任意清理一个 随机清理：无论是否过期，随机清理   缓存常见问题详解  缓存内数据同时失效   导致所有的请求都被传到数据库里，使得数据库请求突然增加   解决：让缓存添加一个随机事件，使得同一批的请求不会同一时间失效    缓存穿透   用户使用非法请求，请求的数据不是数据库和缓存里面存在的，使得请求每次都传到数据库，造成数据库瘫痪 如果是合理的范围里面，但是数据库仍是不存在的，也会导致请求直接发送到数据库里面。   解决：      要在最外层进行基本的数据校验，遇到非法请求直接 BlomFilter 过滤器 &amp;ndash;&amp;gt; 存储所有的数据id，直接通过判断请求的数据id是否存在来判断请求数据是否合法   分配一个内存空间全部存0，加入元素，用k个互相独立的哈希函数计算，然后将元素哈希映射的K个位置全部设置为1，检测key，仍然按     但是只是大概率，还是有误差的     缓存雪崩   存在缓存数据里面的节点崩坏，节点内的数据全部都会失效，倒是请求都直接发送到数据库里面   数据支持    数据源统一   不要自己单独另外进行缓存，会导致和原本的数据源出现不同  ReadAfterWrite   写完后立即能够读，就会造成 DB和Catch里面不一样。需要对数据库和缓存一致性问题先解决。   缓存尽快失效，能够尽可能保证数据一致    缓存和  缓存和数据库的更新  先删除缓存后更新DB？   并发的时候就会出现问题。当线程A需要更新数据一时，把cache 删除 。然后线程B发现数据一没有了，就从数据库里面读取数据一，这时数据库是新的数据，cache 会继续沿用线程B缓存进cache 的旧数据。   先更新后缓存？   当线程A 更新数据库后再删除cache时，还没有来得及删除，线程B就过来向数据库写入新的数据，此时缓存里是线程A的更新的数据，而数据库里面的是线程B更新的数据。在线程B还没有把新的数据写入缓存时间里，就会出现缓存和数据库不一致的情况。     但是这种情况很少，因为更新数据库的速度比更新缓存的速度要慢。    Spring缓存抽象与相关源码分析   CachingProvider 可以控制多个CacheManager(Guava等等的cache实现)，从而实现分级的缓存</description>
    </item>
    
    <item>
      <title>JVM</title>
      <link>https://procarihana.github.io/public/posts/jvm/</link>
      <pubDate>Thu, 08 Oct 2020 11:12:52 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/jvm/</guid>
      <description>HotSport JVM 堆
 所有对象都在里面 只能操纵对象的引用或者地址 只能够操纵产生，但无法控制死亡    常量池 String.intern() 直接从常量池里面获取这个对象的引用    栈  递归调用 阶乘   每次方法调用都会产生一个新的栈针，返回之后就会销毁   栈里面的内存分配   局部变量都是在栈里面的，因为每一次方法调用所用到的变量都是复制得到的，所以在调用改变的过程中是不会改变局部变量的     对象的地址根据虚拟机是32位（4个字节）还是64位（8个字节）   栈针   方法调用开始的时候，变量就会放在每个方法栈里面的操作数栈里面，     方法区
 被整个虚拟机共享的共享的class信息（创建对象的说明书）   永久代放在堆里面，很容易就会超出内存 元空间 和 natice 共享内存 平台无关性
 基于栈的模型   查看字节码
 javap target.xxx.classname 只能够查看public 的方法   -private 能够查看所有的方法     -v 常量的等等     字节码的加载和执行</description>
    </item>
    
    <item>
      <title>HashMap</title>
      <link>https://procarihana.github.io/public/posts/hashmap/</link>
      <pubDate>Wed, 07 Oct 2020 19:49:58 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/hashmap/</guid>
      <description>Hash 数据结构
 核心是哈希值数组和值链表 Hash 桶 底层是数组，查找、插入、删除平均速度是O(1) 哈希碰撞 多个元素的hash值相同，解决的方法是通过链表解决哈希值相同的状况   HashMap
 对于hash 基于map接口的实现 默认是初始容量必须是2的幂   最大的容量是-2^31~2^31-1 42亿左右     构造函数
 默认初始容量 16 默认负载 0.75f   负载因子高就会减少的浪费，增加查找的消耗   初始容量和负载因数 都可以改变的   但是没有初始化的时候是空的，扩展容量会根据有制定的初始容量向上膨胀到2的幂     put
 找到相同的话就覆盖并返回 没有的话就addEntry   如果add 过程中超过12就开始扩容       resize 把所有的哈希都重新进行计算，新的容量是旧的容量的两倍        旧表的哈希桶就会通过transfer，遍历一遍并计算在新的表的位置，并放进去（Java 7）    get   为什么数组的大小一定时2的幂   计算哈希桶的时候是 2^n-1按位与&amp;amp;   2的N次方-1 才会拿到全部是1的值，使用按位与才能快速拿到数组下标，且分布还是均匀的    Java 7 hash 死锁   HashMap 不是线程安全的！ 存在安全隐患   通过精心构造的恶意请求引发Dos 链表性能退化      Tomcat 通过设置设置参数的限制来避免大量相同的恶意哈希值 Orcal put方法里面 initHashSeedAdNeeded 提供一个种子，在出现这种状况是会自动使用另外一种计算方式 通过精心设计HashMap 会退化成链表。因为Hash算法是公开的 Aa BB #C 哈希算法就是相同的   Java 8 HashMap 改进   数组+链表 / 红黑树的改进   当桶里面的值超过8 的时候就会变成树 通过里面的算法得知超过8的可能性非常小     红黑树通过计算能够保证数是平衡的     插入的时候，如果超过八就会执行变树的方法   扩容是插入顺序的改进   transfer 保持插入的顺序，而java7 没有     但是这种方法只能让线程出现死锁的概率变低，并没有解决      高位 低位 扩容后新的索引值和旧的索引值在低位的部分是相同的，高位部分要么是相等，要么是最高位+1 &amp;ndash;&amp;gt; 原先的列表有的会在原来的位置，也有可能在新列表的高位，    函数方法   forEach     compute 系列   Map 的新API   merge     replace    resize 效率很低     HashSet  HashSet 的实现就是输入的value 为 hashMap 的key，然后自己new 一个 object 作为value，从而能够复用HashMap的代码  </description>
    </item>
    
    <item>
      <title>Linux</title>
      <link>https://procarihana.github.io/public/posts/linux/</link>
      <pubDate>Tue, 06 Oct 2020 16:33:07 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/linux/</guid>
      <description>POSIX 标准 可移植的操作系统接口    ECS 虚拟机 镜像选择 ubuntu 版本号 xx.xx 年份.版本 公网IP    Kernel 内核 &amp;ndash;&amp;gt; 控制操作系统和调度的代码 Shell 用于控制kernel 的方式 ,访问内核的交互式命令行    通过一个终端连接Linux主机，可以再任何地方使用     镜像   相当于光盘使用后能够安装处光盘里面的东西      SSH (Secure Shell)   加密访问，保证安全   $ ssh root@公IP 登录后默认在/home    Linux 用户 登录后就拥有一个用户名 $ whoami &amp;ndash;&amp;gt; 当前登录的权限 Eg：root……user   root 拥有所有权限，日常工作尽量不使用，但是安装系统等需要root/非常高权限的用户完成   sudo切换成root 用户完成命令   sudo username xxx 生成新的用户       生成用户后并没有同时生成目录等，需要额外配置     $ exist 退出   su xxx切换成该用户   pwd 工作目录 usergroup 用户组 用于权限管理，用户组能够共享权限    $ list (ls)列出清单   -l -h 详情     -a  查看包括隐藏的文件       d 目录 时间后面就是文件夹的名字 文件夹的大小是固定的        目录能够区分权限 dxxx xxx xxx &amp;ndash;&amp;gt;d所有者权限 用户组权限 其他人 r read w write x execute        l 快捷方式 -&amp;gt; 实际的地址 是一个软链接，执行能够通过软连接实际执行程序        创造快捷方式   ln -s 目标地址 软连接       软连接必须在PATH 环境变量里面     alias 程序快捷名=实际地址        - 文件 可读可写可执行       cat 查看文本文件内容</description>
    </item>
    
    <item>
      <title>Servlet</title>
      <link>https://procarihana.github.io/public/posts/servlet/</link>
      <pubDate>Sun, 04 Oct 2020 14:18:34 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/servlet/</guid>
      <description>Socket 从客户端到服务器的四元组，能够读写数据（IntOutputStream） Servlet 不需要手动通过socket写符合http协议的字节流给服务器，一套规范，但本质上是Java 的接口，避免手工处理http的内容，是web应用的基石
 Java Servlet api maven   HttpServerRequest 能够完成getCookie()、getConrectTtpe()、header等等，能够读取能够生成，状态码也可以   全是接口，不需要具体实现    Socket 把字节流封装成HttpServletRequest对象 和 HtppServletResponse 对象， ServletRequest 可以直接强制类型转换成HttpServletRequest request.getParameter(&amp;quot;&amp;quot;) 设置Servlet对象 设置Json = &amp;quot;{\&amp;quot;requestParameter\&amp;quot;+&amp;quot;:&amp;quot;+ }&amp;quot; response.setContentType() response.getOutputStream().write(Json.getByte()) 把outputStream flush（）    Servlet 容器 为Servlet 提供运行   Servlet 不能够独立运行，必须依赖容器     bin 目录下面存放着可运行的程序       bat 是windows sh 是Mac     Tomcat 的可执行程序同样是放在bin目录里面 核心为 catalina   运行tomcat 就需要把 运行的Servlet 存放在 catalina_base/webapps/.</description>
    </item>
    
    <item>
      <title>Set</title>
      <link>https://procarihana.github.io/public/notes/set/</link>
      <pubDate>Wed, 30 Sep 2020 10:45:24 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/set/</guid>
      <description> Set 用于存储无序（存入和取出的顺序不一定相同）元素，值不能重复  对象相等性 </description>
    </item>
    
    <item>
      <title>Java 泛型</title>
      <link>https://procarihana.github.io/public/posts/java-%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Mon, 28 Sep 2020 19:12:01 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java-%E6%B3%9B%E5%9E%8B/</guid>
      <description>上界通配符（Upper Bounds Wildcards）&amp;lt; ? extends T &amp;gt; 下界通配符（Lower Bouds Wildcards） &amp;lt;? super T&amp;gt;  通配符和边界的作用 边界让不同泛型转换更加容易，但是部分容易功能容易失效  上界通配符 : 一个能放水果以及其子类的盘子    苹果继承水果，但是能放水果的盘子不能够放苹果，因为能放苹果的盘子并非继承能放水果的盘子，他们之间没有继承关系 为了能够让盘子放苹果，需要一个Plate&amp;lt;? extend Fruit&amp;gt;的盘子，这个盘子能够放Fruit 的所有子类    下界通配符 ：一个能放水果Fruit 以及其父类的盘子    Fruit 继承 Food， 所以Plate&amp;lt;? super Fruit&amp;gt; 的盘子可以放 Plate&amp;lt; Food&amp;gt;, 因为 Fruit 作为下界限，所以 Apple 就不能放进去了     上界不能往里存，只能往外去   因为编译器只知道容器内是Fruit 或者其子类，但具体类型是不知道的，所以用 Plate&amp;lt;Apple&amp;gt; 赋值之后，plate 并没有标上Apple，而是标上一个占位符CAP#1,表示捕获一个Fruit或Fruit子类，具体是什么类并不知道，只用代号代替。所以之后无论添加什么类型都无法判断是否和apple 是统一类型，因为只有代号。    Plate&amp;lt;? extends super Fruit&amp;gt; p = new Plate&amp;lt;Fruit&amp;gt;(new Apple()); //不能存入任何元素  p.</description>
    </item>
    
    <item>
      <title>Java 8 函数式编程</title>
      <link>https://procarihana.github.io/public/posts/java-8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 28 Sep 2020 16:28:56 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java-8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>函数式编程 1、减少工作量 2、提高效率 3、减少Bug
 Java8的新引入，包含函数式的设计，接口都有@FunctionalInterface的注解。注解在接口层面，且注解的接口要有且仅有一个抽象方法。&amp;ndash;&amp;gt;
 Lambada 表达式 Lambda允许把函数作为一个方法的参数（函数）作为参数传递进方法中
 Filter Pradicate 判断，用来判断一个东西是否满足条件    （user -&amp;gt; user.id%2==0）// 方法列表-&amp;gt;方法体，如果方法体太多要加括号，但一般精简. 满足 方法列表能够映射成布尔值，就能够转化成函数接口 方法应用有名字能够解释方法的用处，函数接口简单，但是没有任何注释；    满足类名::静态方法名字，且方法为布尔函数的时候，可以使用::     接口 输入 -&amp;gt; 输出  接口 输入 -&amp;gt; 输出     Supplier &amp;lt;Object&amp;gt; 虚无 -&amp;gt; Object  Function&amp;lt;User,String&amp;gt; User -&amp;gt; String   Lambad() -&amp;gt; new Object() void -&amp;gt; Object  Lambda user -&amp;gt; user.getName() User -&amp;gt; String   static Object create() void -&amp;gt; Object  static String getName(User user) User -&amp;gt; String   Object :: new void -&amp;gt; Object  User::getName User -&amp;gt; String      任何只包含一个抽象方法的接口都可以被自动转换为函数接口 抽象类：没有方法体    Supplier :从虚空里获得一个对象 &amp;ndash;&amp;gt; void -&amp;gt; OBject new 也同样是从虚空获得一个对象  public static void main (String [] agrs){ create(() -&amp;gt; new Object()); create(() -&amp;gt; &amp;#34;&amp;#34;); create(() -&amp;gt; new User(1,&amp;#34;A&amp;#34;)); create(Object :: new); } private static Object create(Supplier&amp;lt;Object&amp;gt; supplier){ return supplier.</description>
    </item>
    
    <item>
      <title>多人聊天室</title>
      <link>https://procarihana.github.io/public/projects/%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</link>
      <pubDate>Thu, 24 Sep 2020 19:46:15 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/projects/%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</guid>
      <description>使用多线程是因为信息收发IO是非常慢的
Socket 插座 套接字  使用java自带的java.net.ServerSocket 双向的可以收发数据的东西 server.accept()等待一个连接连入，直到有链接连入，否则就会一直阻塞   返回一个Socket 能够用于收发数据     链接后就能够通过Socket读取数据。使用的是inputstream 速度很慢。而且这个Socket只能够单独地进行读取数据或者链接，在读取数据的过程中就不能够通过这个Socket处理链接 &amp;ndash;&amp;gt; 数据读写不能够放在主线程里面，不然就会出现阻塞。需要建立新的线程完成   socket 会缓存IO 所以传递完一次消息后就要flash 清空  用户协议  用来识别用户    userid user name    规定每个客户端连上的时候要先上报自己的名字，如果是空话就吧stream得到的为用户的名字  </description>
    </item>
    
    <item>
      <title>Java面向对象  接口和抽象类</title>
      <link>https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</link>
      <pubDate>Tue, 22 Sep 2020 18:02:40 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</guid>
      <description>问题：如何禁止默认实现 强制要求覆盖方法
 抛出异常  在空的方法里面设置UnsupportedOperationException（）；
   缺点：编译的时候不会报错，运行的时候抛出异常     原因：abstruct是一个抽象集合，有时候这个集合不可变，不可以往里面添加（不支持修改，不可变）   抽象化 抽象方法必须在抽象类中 抽象方法不能够实例化  强制提供默
 抽象类  可以有成员，可以有构造器，可以有实例方法
 实现 抽象  Abstruct 有时候是不可变，不可以添加东西
 接口  抽象类 除了用abstruct声明之外，和其他类没有本质上的区别
 不可实例化
没有方法体的方法 可以拥有抽象的方法 abstruct void methon（）； 可以是实例化的东西一定要补全所有的方法体
因为抽象方法没有执行的内容，执行也没有内容可执行，所以必须要补全方法体 可以包含抽象方法 非private/static   抽象方法目的是让人继承     继承多态只发生在实例里面，因此不能用static，没有意义     private不能被子类访问继承，继承也没有用   可以包含普通类的任何东西
内部类、成员变量……  AbstructCollection 集合 AbstructList 列表（有序）</description>
    </item>
    
    <item>
      <title>多线程</title>
      <link>https://procarihana.github.io/public/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 22 Sep 2020 10:20:53 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>多线程  Java 的执行模型是同步/阻塞的&amp;ndash;&amp;gt;默认情况下只有一个线程,虽然处理问题非常自然，但是具有严重的性能问题。   同步与异步同步     同步：一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。 异步：不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。 用打电话（同步）和发短信（异步）     阻塞和非阻塞     阻塞与非阻塞主要是从 CPU 的消耗上来说的 阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事。 非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，等这个慢的操作完成时，CPU 再接着完成后续的操作。 虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的 CPU使用时间能不能补偿系统的切换成本需要好好评估。  为什么需要多线程  CPU 运行速度快，现代CPU是多核的&amp;ndash;&amp;gt; 不浪费CPU的资源。通过并发的操作，减少工作时间，提高效率。（为了解决负载均衡问题,充分利用CPU资源。为了提高CPU的使用率,采用多线程的方式去同时完成几件事情而不互相干扰） 为了处理大量的IO操作时或处理的情况需要花费大量的时间,比如:读写文件,视频图像的采集,处理,显示,保存等  多线程缺点
1.如果有大量的线程,会影响性能,因为操作系统需要在它们之间切换.
2.更多的线程需要更多的内存空间
3.线程中止需要考虑对程序运行的影响.
4.通常块模型数据是在多个线程间共享的,需要防止线程死锁情况的发生
一个简单新的线程 new Thread(new Runnable() {/** do something **/}).start()  Java虚拟机允许一个程序有多个线程在同时运行——性能来源
 Java 中只有Thread一种东西代表线程 Start 方法才能并发执行   start 和 run 的区别     在同样的工作量情况下start的执行速度大于run start（）方法来启动线程，真正实现了多线程运行。这时无需等待run()代码执行完毕，可以直接继续执行下面的代码； 通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态，并没有运行。    接着通过此Thread类调用方法run()来完成其运行操作的，这里方法run()称为线程体，它包含了要执行的这个线程的内容（业务），Run方法运行结束，此线程终止。然后CPU再调度其它线程。   run（）方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程，其程序执行路径还是只有一条，这样就没有达到写线程的目的。  多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发</description>
    </item>
    
    <item>
      <title>操作系统与计算机原理</title>
      <link>https://procarihana.github.io/public/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 21 Sep 2020 23:40:37 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/</guid>
      <description>计算机体系原理 核心 ：CPU 中央处理器 包含控制器和运算器    寄存器 ：临时存放 register 是CPU的内置，容量小，但是速度极快的内存     内存 ：包含数据和指令（说明书）冯诺依曼结构&amp;ndash;&amp;gt; 将程序指令和数据存储一起的结构     汇编指令    程序的装载和执行  可执行程序 exe、executable： 执行指令和数据的共同体   一个exe 可以执行多个进程 &amp;ndash;&amp;gt; 装载到内存不同的进程里，两个进程是不相同的      物理寻址 通过指令完成 物理地址：真是的内存地址 虚拟地址空间：对于每一个进程而言，操作系统随机分配给进程的内存空间   每个程序是独立的，程序间数据不共享，程序不会窃取别的程序，互不干扰，一个崩溃另一个也不会出事   跨平台性   不同架构的CUP执行指令是不一样的，所以不同平台的CPU不能执行其他CUP的指令     而模拟器能够实现      动态链接库 静态链接库    CPU 在执行指令的时候，有的方法是存在另外的地方，需要用的时候就去加载。能够节省空间，共用方法，升级的时候也比较简单。但是如果不存在的话就会出现错误，也有可能出现和系统不兼容的问题    《链接、装载与库》  程序的分时复用调度  CPU 速度 &amp;raquo; memory &amp;raquo; IO 操作系统根据实际采用调度 时间片轮转：不停地轮流做不同的事情，基于CUP运行速度快 每个程序轮流占用CPU的时间片（进程、线程）   什么时候放弃占用CUP时间片      程序时间片到时间 请求慢速设备（把数据储存到磁盘） CPU需要响应中断（磁盘处理完后向CPU发出中断，CPU 就马上去完成中断后的工作）     上下文切换</description>
    </item>
    
    <item>
      <title>工厂方法</title>
      <link>https://procarihana.github.io/public/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 21 Sep 2020 18:23:42 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</guid>
      <description>对象创建模式  避免用new创建过程中需要依赖具体类，从而支持对象创建的稳定 避免紧耦合，对拓展是开放的，对修改是封闭的 典型： Factory Method Absttact Factory Builder Prototype（原型）   Clone   Singleton  简单工厂模式 例  处理从文件里面读出的数据 设计：DataManager类，FileReader类   从不同的去到读取数据，一开始需要每渠道都写一种实现 processDataFromRest 、processDataFromDatabase 等等的方法，而这些方法都要需要相应的dataReader对象去实现。 为了减少  工厂方法 - 目的  定义一个用于创建对象的接口，让子类决定实例化哪一个具体的类 FactoryMethod 使一个类的实例化延迟到其子类 目的：解耦  动机  框架使用抽象类定义和维护对象之间的关系 对象的创建通常也由此框架负责  适用  当一个类不知道它锁必须创建的对象的类的时候 当一个类希望由他的子类来指定它所创建的对象的时候 当类将创建对象的指责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候  结构组成  Produce（DataReader） 定义工厂方法锁创建的对象的接口 ContreteProduct（FileDatareader) :实现Product接口 Creator（DataReaderFactory）：声明工厂方法，该方法返回一个Product类型的对象 ConcreteCreator：重定义工厂方法以创建一个Product对象  总结   Factory Method 主要目的是为了解耦对象使用者和具体类型之间的紧耦合关系
  Factory Method 是一个类的实例化延迟到其子类</description>
    </item>
    
    <item>
      <title>SOLID原则</title>
      <link>https://procarihana.github.io/public/posts/solid%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 20 Sep 2020 15:53:38 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/solid%E5%8E%9F%E5%88%99/</guid>
      <description>面向对象设计基本原则：SOLID原则 单一责任原则  定义：一个类只应承担一种责任 让一个类只做一件事。如果需要承担更多的工作，那么分解这个类  开放封闭原则  定义：实体应该对扩展是开放的，对修改是封闭的 类应该无需改类本身但是却容易扩展 例子： 继承 可以通过继承来扩展，但是不能够修改父类  里氏替换原则  定义：一个 对象在其出现的任何地方，都可以用子类实例做替换 当一个子类可以在任意地方替换基类，且短剑功能不受影响时，不会导致程序的错误 Eg： 多个数据源（SQL与NoSQL）获取用户信息  接口分离原则  定义：多个专门接口比单一的总体接口要好 客户不应被强迫依赖他是不用的方法。即，一个类实现的接口中，包含了他不需要的方法。将接口拆分成更小和更具体的接口，有助于解耦，从而更容易重构与更改  依赖倒置原则  定义：   高层次的模块不应该依赖低层次的模块，他们都应该依赖于抽象。     抽象不应该依赖于具体方法实现，具体实现应该依赖抽象   依赖倒置是实现开闭原则的方法 扩展 IOC DI?  </description>
    </item>
    
    <item>
      <title>LinkedList</title>
      <link>https://procarihana.github.io/public/notes/linkedlist/</link>
      <pubDate>Fri, 18 Sep 2020 17:39:03 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/linkedlist/</guid>
      <description>属性 初始值为0 void push（）  在链条的头部添加元素 addFirst（）  boolrean offer()  在尾部添加元素 实现Queue接口的offer  push()  实质上就是addFirst()  offerLast()/offerFirst ()  实质上执行的addLast()和addFirst()return true  peekFirst()/peekLast()  查看第一个或者最后一个元素，如果list为空则返回null，除此以外什么都不做  poll（）  检索和删除顶元素，如果为null 返回null  pop（）  删除列表的顶元素，如果为null ，则抛出异常  void add(int index, E element)  LinkedList 并没有add（），但是在继承的AbstractSequentiaList里面 有实现add()   add(0, element) 就是把 element 放在first， 原本的first 就会变成second     add(2 ,element) 就是把element 放在第二个的右边，成为第三个元素，原本的第三个就会变成第四个    </description>
    </item>
    
    <item>
      <title>Queue</title>
      <link>https://procarihana.github.io/public/notes/queue/</link>
      <pubDate>Fri, 18 Sep 2020 16:19:46 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/queue/</guid>
      <description>poll  remove head of this queue 不同于 remove 的是当queue为空 的时候会返回null  remove  移出队列的顶元素，队列为空则会抛出异常  offer()  在尾部添加元素  Queue 常用方法            add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常    remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常    element 返回队列头部的元素 如果队列为空，则抛出一个 NoSuchElementException异常   offer 添加一个元素并返回true 如果队列已满，则返回false    poll 移除并返问队列头部的元素 如果队列为空，则返回null    peek 返回队列头部的元素 如果队列为空，则返回null    put 添加一个元素 如果队列满，则阻塞    take 移除并返回队列头部的元素      </description>
    </item>
    
    <item>
      <title>Spring MVC</title>
      <link>https://procarihana.github.io/public/notes/spring-mvc/</link>
      <pubDate>Thu, 17 Sep 2020 23:41:33 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/spring-mvc/</guid>
      <description>Spring MVC   模型model(javabean), 视图view(jsp/img) 控制器Controller(Action/servlet)
  C 存在的目的就是为了保证M和V的一致性 当M发生改变时,C可以把M中的新内容更新到V中.
  使用MVC模式的好处是，Controller专注于业务处理，它的处理结果就是Model。Model可以是一个JavaBean，也可以是一个包含多个对象的Map，Controller只负责把Model传递给View，View只负责把Model给“渲染”出来，这样，三者职责明确，且开发更简单，因为开发Controller时无需关注页面，开发View时无需关心如何创建Model。     SpringMVC是Spring框架内置的MVC的实现，一个Spring内置的MVC框架
MVC框架，它解决WEB开发中常见的问题(参数接收、文件上传、表单验证、国际化、等等)，而且使用简单，与Spring无缝集成。
支持 RESTful风格的 URL 请求 。
采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性。
  为了解决页面代码和后台代码的分离
  </description>
    </item>
    
    <item>
      <title>Servlet</title>
      <link>https://procarihana.github.io/public/notes/servlet/</link>
      <pubDate>Thu, 17 Sep 2020 20:02:18 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/servlet/</guid>
      <description>Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释放其占用的资源</description>
    </item>
    
    <item>
      <title>Set接口</title>
      <link>https://procarihana.github.io/public/notes/set%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Thu, 17 Sep 2020 10:13:05 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/set%E6%8E%A5%E5%8F%A3/</guid>
      <description>addAll  元素不重复 addAll（Colletcion） 如果set里面原本有不属于这个集合的元素，就会被移出，剩下的是原本的set和新集合的交集 不允许添加包含null的集合，否则会出现exception  Add  add（Object） 通过判断Objcet 是否为 null 且是否和集合里面的元素相等，如果Object 已经存在于set里面就不会发生改变并且return false  remove  如果存在这个元素 移出后return true  </description>
    </item>
    
    <item>
      <title>ArryList</title>
      <link>https://procarihana.github.io/public/notes/arrylist/</link>
      <pubDate>Wed, 16 Sep 2020 23:52:09 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/arrylist/</guid>
      <description>初始容量为 10  之后每超过10就添加16个  有设置容量  意义在于先准备一个空间，避免以后不断地扩容造成空间浪费 如果指定初始容量a，数组的容量就为a 如果初始容量为0或者没有指定，就为0 负数就抛出异常  public ArrayList(int initialCapacity) { if (initialCapacity &amp;gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&amp;#34;Illegal Capacity: &amp;#34;+ initialCapacity); } } 扩容的时候自动调整大小  ArrayList 里面有一个Object[] elementData 用于存储实际的元素   包含size   扩容过程    执行add（）的时候会先判断当前未添加前的elementDate.length 是否会等于初始容量 size，如果等于就执行grow()扩容，并把扩容后的新对象组size 赋值到 elementData 里面 Object[]grow（） 增长的最小的目标容量（minCapacity）是当前的目标容量+1   之后执行Object[] grow(int minCapacity) 。先复制就的Array，然后加入扩充好的新容量的数组（newCapacity（int minCapacity））里，复制给elementData并返回这个新的数组       newCapacity(int minCapacity) 新容量的目标容量为旧容量的1.</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://procarihana.github.io/public/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 16 Sep 2020 18:13:34 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>保证一个类只有一个实例，并提供一个访问它的全局访问点   常见的单例模式   Hibernate、Mybatis SessionFactory Spring Bean 每个Bean 都是单例的（依赖倒置原则） Java Runtime  动机  在软件工程里经常有一些特殊类，必须保证他们在系统里有且只有一个实例 绕开 new，提供一种方式来确保一个类只有一个实例 需要由类设计者来考虑实现，而不是类使用者来保证  优势  提供了对唯一实例的受控访问 对频繁使用的对象，可以省略创建对象所花费的时间，对于那些重量级对象而言，是非常可观的一笔系统开销 对于Java语言，额外的好处：由于new操作的次数减少，因而对系统内存的使用频率也会降低。这将减轻GC压力，缩短GC停顿时间  使用场景  当只能有一个实例而且客户可以从一个众所周知的访问点访问 当这个唯一实例应该是通过子类化可拓展，并且客户应该无须更改代码就能使用一个拓展的实例  结构  Singgleton ： 定义一个Instacne操作，允许客户访问的唯一实例  单例模式七种方式 饿汉式 静态常量    当构造器是public的时候，这个类都能通过new()实现新的实例 &amp;ndash;&amp;gt; 构造器使用private     为了让外面能够使用到这个类，直接在创建的时候new出来    public class Singleton{ public static final Singleton INSTANCE = new Singleton(); //private constructor  private Singleton(){} public void doSomething(){……} }   改进模式：使用一个静态工厂，通过调用这个类的方法从而能够使用到这个实例   public class Singleton{ public static final Singleton INSTANCE = new Singleton(); //private constructor  private Singleton(){} public static Singleton getInstance(){ return INSTANCE;} public void doSomething(){……} }  饿汉式 静态代码块  public class Singleton{ private Singleton(){} private static Singleton instance; static{ instance = new Singleton(); } public static Singleton getInstance(){ return instance; } } 懒汉式 线程不安全  只在第一次new(),其余时间通过判断是否为null，不是的话就直接返回，是的话就new一个新的 如果多个线程同时执行if(instance == null),一个线程来不及创建完，就被另一个线程访问，会创建出多个实例来   可以懒加载。但是线程不安全，只能在单线程使用   不能在实际环境中使用  public class Singleton{ private static Singleton instacne; private Singleton(){ public static Singleton getInstance(){ if(instance == null){ instance = new Singleton(); } return instance; } } } 懒汉式 线程安全 同步安全  加锁 能懒加载   加锁导致效率低（程序串行化），每个线程在获得实例时都要进行同步，哪怕已经是读的操作     加锁是有性能开销的     不推荐使用    双重检查 double-check  懒汉式不安全,主要是判断是否为空   双重检查就是通过加锁，获得锁后把判断实例是否为空，如果是的话就new出实例，不是的话就返回已经new出的实例     在new的过程中，因为锁已经被拿走了，所以不会有其他的线程new实例    public class Singleton{ private static Singleton instacne; private Singleton(){ public static Singleton getInstance(){ if(instance == null){ synchrondized(Singleton.</description>
    </item>
    
    <item>
      <title>锁</title>
      <link>https://procarihana.github.io/public/notes/%E9%94%81/</link>
      <pubDate>Wed, 16 Sep 2020 17:27:26 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E9%94%81/</guid>
      <description> volatile的措施，就是   每次从内存中取值，不从缓存中什么的拿值。这就保证了用 volatile修饰的共享变量，每次的更新对于其他线程都是可见的。 volatile保证了其他线程的立即可见性，就没有保证原子性。 3.由于有些时候对 volatile的操作，不会被保存，说明不会造成阻塞。不可用与多线程环境下的计数器。  </description>
    </item>
    
    <item>
      <title>Maven</title>
      <link>https://procarihana.github.io/public/notes/maven/</link>
      <pubDate>Tue, 15 Sep 2020 23:02:35 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/maven/</guid>
      <description>Maven lifeCycle  verify 运行检查确保代码有效 integration-test (继承测试) 相比于 verify位 于maven生命周期的前几个（运行maven 的范围比 verify少）    如有必要，将包处理和部署到可以运行集成测试的环境中。   </description>
    </item>
    
    <item>
      <title>微商电商</title>
      <link>https://procarihana.github.io/public/projects/%E5%BE%AE%E5%95%86%E7%94%B5%E5%95%86/</link>
      <pubDate>Tue, 15 Sep 2020 22:39:33 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/projects/%E5%BE%AE%E5%95%86%E7%94%B5%E5%95%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>测试</title>
      <link>https://procarihana.github.io/public/notes/%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Tue, 15 Sep 2020 20:31:34 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E6%B5%8B%E8%AF%95/</guid>
      <description>白盒测试——把测试对象看作一个打开的盒子，程序内部的逻辑结构和其他信息对测试人员是公开的。 黑盒测试——已知产品的功能设计规格，不考虑程序内部结构，进行测试证明每个实现了的功能是否符合要求 灰盒测试——介于白盒和黑盒测试之间，即关注输出对输入的正确性，也关注程序内部表现。 回归测试——软件或环境的修复或更正后的“再测试”，自动测试工具对这类测试尤其有用。 单元测试——是最小粒度的测试，以测试某个功能或代码块。一般由程序员来做，因为它需要知道内部程序设计和编码的细节。
JUnit JUnit中提供了很多断言方法用来测试不同的条件， assertEquals(a, b) 测试a是否等于b（a和b是原始类型数值(primitive value) 或者必须为实现比较而具有equal方法） assertFalse(a) 测试a是否为false （假），a是一个Boolean数值 。 assertTrue(a) 测试a是否为true （真），a是一个Boolean 数值 assertNotNull(a) 测试a是否非空，a是一个对象或者null 。 assertNull(a) 测试a是否为null，a是一个对象或者null 。 assertNotSame(a, b) 测试a和b是否没有都引用同一个对象 。 assertSame(a, b) 测试a和b是否都引用同一个对象 。  Unit 提供了6大类31组断言方法，包括基础断言、数字断言、字符断言、布尔断言、对象断言。   assertEquals（Object expcted,Object actual)内部逻辑判断使用equals()方法，这表明断言两个实例的内部哈希值是否相等时，最好使用该方法对相应类实例的值进行比较。     而assertSame（Object expected,Object actual）内部逻辑判断使用了Java运算符“==”，这表明该断言判断两个实例是否来自于同一个引用（Reference），最好使用该方法对不同类的实例的值进行比对。     asserEquals(String message,String expected,String actual)该方法对两个字符串进行逻辑比对，如果不匹配则显示着两个字符串有差异的地方。     ComparisonFailure类提供两个字符串的比对，不匹配则给出详细的差异字符。 [https://www.cnblogs.com/bnuvincent/archive/2004/01/13/2079550.html]    Mockito  Mockito并非不是通过代理调用真实实例，而是创建它的一个副本。 默认情况下，对于所有返回值的方法，mock将返回null， 一旦存根，该方法将始终返回一个存根值  Mock Spy  Spy使用真实的实例副本来进行，不会和实例进行交互 所以如果你保留真实的实例并与之交互，不要期望被间谍知道那些交互 及其对实际实例状态的影响。 推论是，当 unstustub 方法被称为on spy，而不在实际实例时， *你不会看到对实际实例的任何影响  MockitoUnit  Mockito使用JUnit运行器使测试保持整洁并改进调试体验。   自动检测存根参数，并设置为默认（Mockito 3.</description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>https://procarihana.github.io/public/notes/sql/</link>
      <pubDate>Tue, 15 Sep 2020 11:03:10 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/sql/</guid>
      <description>SQL Structured Query Language  SQL是结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，通过学习SQL这一种语言，就可以操作各种不同的数据库。  SQL 能力  DDL：Data Definition Language   DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。     DML：Data Manipulation Language     DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。   DQL：Data Query Language   DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。    数据库  解决问题;   读写文件并解析出数据需要大量重复代码；     从成千上万的数据中快速查询出指定数据需要复杂的逻辑。    数据类型 对- 于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：
   名称 类型 说明     INT 整型 4字节整数类型，范围约+/-21亿   BIGINT 长整型 8字节整数类型，范围约+/-922亿亿   REAL 浮点型 4字节浮点数，范围约+/-1038   DOUBLE 浮点型 8字节浮点数，范围约+/-10308   DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算   CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串   VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串   BOOLEAN	布尔类型 存储True或者False    DATE 日期类型 存储日期，例如，2018-06-22   TIME 时间类型 存储时间，例如，12:20:59   DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59    数据模型  A：对于层次模型，采用的是树（二叉树）的结构来表达实体和实体间联系（上下级关系） B：网状模型，采用的是图的结构来表达实体和实体间联系（像城市道路一样连接各个城市） C：关系模型，就是用的二维表  候选键(Candidate Key)：一个或者多个属性的集合，可以唯一确定实体的一个实例； 主键(Primary Key):从候选键中，选中用来作为唯一标识的属性或者属性组被称为主键； 可选键(Alternative Key):候选键中没有选中的其他键，称为可选键； 而表的外键是另一表的主键, 外键可以有重复的, 可以是空值。</description>
    </item>
    
    <item>
      <title>计算机基础</title>
      <link>https://procarihana.github.io/public/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 15 Sep 2020 10:40:07 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</guid>
      <description>物理层：中继器、集线器 链路层：网桥、交换机 网络层：路由器
TCP/IP: 数据链路层：ARP,RARP 网络层： IP,ICMP,IGMP 传输层：TCP ,UDP,UGP 应用层：Telnet,FTP,SMTP,SNMP.
OSI: 物理层：EIA/TIA-232, EIA/TIA-499, V.35, V.24, RJ45, Ethernet, 802.3, 802.5, FDDI, NRZI, NRZ, B8ZS 数据链路层：Frame Relay, HDLC, PPP, IEEE 802.3/802.2, FDDI, ATM, IEEE 802.5/802.2 网络层：IP，IPX，AppleTalk DDP 传输层：TCP，UDP，SPX 会话层：RPC,SQL,NFS,NetBIOS,names,AppleTalk,ASP,DECnet,SCP 表示层:TIFF,GIF,JPEG,PICT,ASCII,EBCDIC,encryption,MPEG,MIDI,HTML 应用层：FTP,WWW,Telnet,NFS,SMTP,Gateway,SNMP
端口 http 80 ftp 20/21 ssh 22 telnet 23 smtp 25
jar 将许多文件组合成一个jar文件 javac 编译 javadoc 它从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。 javah 把java代码声明的JNI方法转化成C\C++头文件。 JNI可参考java核心技术卷二第12章
JTextField单行文本 JTextArea多行文本 JButton按键显示 JLable显示标签 信息
JVM虚拟机 类加载过程  类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。 其中准备、验证、解析3个部分统称为连接（Linking）。 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都已HotSpot为基准。  加载 在加载阶段（可以参考java.</description>
    </item>
    
    <item>
      <title>多线程</title>
      <link>https://procarihana.github.io/public/notes/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 14 Sep 2020 22:21:40 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>多线程一共有三种实现方式 方式1：继承Thread类，并重写run()方法 方式2：实现Runnable接口，实现run()方法 方式3：实现Callable接口，线程结束后可以有返回值，但是该方式是依赖于线程池的。</description>
    </item>
    
    <item>
      <title>Enum</title>
      <link>https://procarihana.github.io/public/notes/enum/</link>
      <pubDate>Mon, 14 Sep 2020 21:56:22 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/enum/</guid>
      <description>题目    enum AccountType { SAVING, FIXED, CURRENT; private AccountType() { System.out.println(“It is a account type”); } } class EnumOne { public static void main(String[]args) { System.out.println(AccountType.FIXED); } }  所有的枚举值都是类静态常量，在初始化时会对所有的枚举值对象进行第一次初始化。 枚举类在后台实现时，实际上是转化为一个继承了java.lang.Enum类的实体类，原先的枚举类型变成对应的实体类型，上例中AccountType变成了个class AccountType，并且会生成一个新的构造函数，若原来有构造函数，则在此基础上添加两个参数，生成新的构造函数，如上例子中：  private AccountType(){ System.out.println(“It is a account type”); } 会变成：
private AccountType(String s, int i){ super(s,i); System.out.println(“It is a account type”); }
而在这个类中，会添加若干字段来代表具体的枚举类型： ```java public static final AccountType SAVING; public static final AccountType FIXED; public static final AccountType CURRENT; 而且还会添加一段static代码段：</description>
    </item>
    
    <item>
      <title>数组</title>
      <link>https://procarihana.github.io/public/notes/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 14 Sep 2020 21:01:00 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E6%95%B0%E7%BB%84/</guid>
      <description>初始化为{5,3,1} nums.add(6)后list为{5,3,1,6} nums.add(0,4)是在0号索引上添加数字4得到list为{4,5,3,1,6} nums.remove(1)是将1号索引上的5进行remove得到list为{4,3,1,6}</description>
    </item>
    
    <item>
      <title>待处理</title>
      <link>https://procarihana.github.io/public/notes/%E5%BE%85%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 14 Sep 2020 20:44:10 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E5%BE%85%E5%A4%84%E7%90%86/</guid>
      <description>Java通过synchronized进行访问的同步，synchronized作用非静态成员方法和静态成员方法上同步的目标是不同的
character流和byte流的区别 字符流和字节流每次读入的字节数是不确定的，可能相同也可能不相同；字符流和字节流都有缓冲流
完全二叉树
get是立即加载，load是延迟加载。 hibernate
重载的概念是：
方法名称相同，参数个数、次序、类型不同
因此重载对返回值没有要求，可以相同，也可以不同
但是如果参数的个数、类型、次序都相同，方法名也相同，仅返回值不同，则无法构成重载
Java的静态方法属于类的成员，实例方法属于对象的成员。 java不允许单独的方法，过程或函数存在,需要隶属于某一类中。 java语言中的方法属于对象的成员,而不是类的成员。不过，其中静态方法属于类的成员。
从java虚拟机的角度讲，只有两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用的是c++实现的，是虚拟机的一部分，另一类是就是所有其他类加载器，这些类加载器都由java语言实现，独立于虚拟机外部，并且全都继承自抽象类。 从开发人员的角度看，类加载器还可以划分为3种系统类加载器，启动类加载器（Bootstrap ClassLoader），负责加载存放在&amp;lt;JAVA_HOME&amp;gt;/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符的类库即使放在lib目录中也不会被加载）类库加载到虚拟机中内存中。启动类加载器无法被java程序直接引用，用户在编写自定义类加载器是，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。 扩展类加载器（Extension ClassLoader）：这个类加载器有sun.misc.Launcher$ExtClassLoader实现，负责加载&amp;lt;JAVA_HOME&amp;gt;/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。 应用类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以也称它为系统类加载器（System ClassLoader）。他负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。对此，如果有必要开发者可以加入自己定义的类加载器。 一般对于我们java程序员来说，类的加载使用的是双亲委派模型，即当一个类需要加载时，会将类传给Application ClassLoader，但是Application ClassLoader并不会加载，不管它是否能加载，而是传给它的&amp;quot;父类&amp;rdquo; Extension ClassLoader，Extension ClassLoader同样不会加载，同样传给 Bootstrap ClassLoader（注意不是我们常说的那种父类，但是可以这样理解）,这时Bootstrap ClassLoader会判断它是否能加载，能加载就直接加载了，不能加载就传给Extension ClassLoader，Extension ClassLoader同样的判断是否能加载，能加载就直接加载，不能加载就传给Application ClassLoader，然后Application ClassLoader也判断能否加载，如果还是不能加载应该就是报ClassNotFoundException了。这就是双亲委托模型的简单理解了。 对于上面的&amp;quot;父类&amp;quot;为什么要打引号，因为它们并不是真的像java中继承的关系，而是组合的关系，即在&amp;quot;子类&amp;quot;中存在一个成员变量指向&amp;quot;父类&amp;quot;的引用。 所以AE对DF错了。 对于C，很容易理解，因为我们知道一个类只需要加载一次就够了，所以要保证线程安全。 难点就在B了，其实也好理解，就是体现双亲委托模型的优势的时候了，之所以使用双亲委托机制是为了保证java程序的稳定运作，比如当你使用的不是双亲委托模型的时候，然后刚好开发者又定义了一个类，一个java.lang.String这样一个类，如果不使用双亲委托模型，当类加载的时候就有可能会加载开发者定义的String类，这导致了java代码的一片混乱，可读性极差。（PS：但这并不意味着类加载器只要双亲委托模型就行了，没有完美的模型，只有最合适的模型，有不同的需求使用不同的模型。比如破坏双亲委派模型，有兴趣的牛友可以自行了解），所以可以这么说，不同的类加载器加载出来的类是不一样的，不同的类加载器加载同一个类会在方法区产生两个不同的类，彼此不可见，并且在堆中生成不同的Class实例。对于接口，其实就是一个特殊的类，和类一样，在堆中产生不同的class对象。 纯手打，个人理解，欢迎大佬指出错误。
A.Java系统提供3种类加载器：启动类加载器（Bootstrap ClassLoader） 扩展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader）. A正确  B.《深入理解Java虚拟机》P228：对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类必定不相等。接口类是一种特殊类，因此对于同一接口不同的类装载器装载所获得的类是不相同的。B错误 C.类只需加载一次就行，因此要保证类加载过程线程安全，防止类加载多次。C正确 D. Java程序的类加载器采用双亲委派模型，实现双亲委派的代码集中在java.lang.ClassLoader的loadClass()方法中，此方法实现的大致逻辑是：先检查是否已经被加载，若没有加载则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出ClassNotFoundException异常。D错误 E.双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。E正确 F.应用程序类加载器（Application ClassLoader）负责加载用户类路径（ClassPath）上所指定的类库，不是所有的ClassLoader都加载此路径。F错误
链接：https://www.nowcoder.com/questionTerminal/b82e4a85a66e4dc488a5ab49094976e9 来源：牛客网
1、ThreadLocal的类声明： public class ThreadLocal可以看出ThreadLocal并没有继承自Thread，也没有实现Runnable接口。所以AB都不对。 2、ThreadLocal类为每一个线程都维护了自己独有的变量拷贝。每个线程都拥有了自己独立的一个变量。 所以ThreadLocal重要作用并不在于多线程间的数据共享，而是数据的独立，C选项错。 由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问， 变量被彻底封闭在每个访问的线程中。所以E对。 3、ThreadLocal中定义了一个哈希表用于为每个线程都提供一个变量的副本： static class ThreadLocalMap {</description>
    </item>
    
    <item>
      <title>Cookie and Session</title>
      <link>https://procarihana.github.io/public/notes/cookie/</link>
      <pubDate>Sat, 12 Sep 2020 16:08:36 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/cookie/</guid>
      <description>Session 一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。
Session 和 cookie  会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。 Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。  Session 和 cookie 区别  Cookie与Session的区别cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的； cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session； session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；  什么是 Cookie？   Cookie 是浏览器访问服务器后，服务器传给浏览器的一段数据。 浏览器需要保存这段数据，不得轻易删除。 此后每次浏览器访问该服务器，都必须带上这段数据。    Cookie 是一些数据, 存储于你电脑上的文本文件中。   当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。   Cookie 的作用就是用于解决 &amp;ldquo;如何记录客户端的用户信息&amp;rdquo;:   当用户访问 web 页面时，他的名字可以记录在 cookie 中。 在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。   设置了新的 cookie，旧的 cookie 不会被覆盖。 Cookies提供了一种在服务器和浏览器之间交换信息的方法，以管理会话（登录，购物车，游戏得分），记住用户首选项（主题，隐私策略接受）以及跟踪整个站点的用户行为。Cookies在一定程度上解放了服务器端的压力，因为将一部分数据放在浏览器端存储，所以这部分数据不能是涉及应用安全的数据。  Cookie 作用   第一个作用是识别用户身份。
   比如用户 A 用浏览器访问了 http://a.</description>
    </item>
    
    <item>
      <title>List</title>
      <link>https://procarihana.github.io/public/notes/list/</link>
      <pubDate>Fri, 11 Sep 2020 20:17:55 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/list/</guid>
      <description>List add  添加元素在右边（最后）  LinkedList 和 ArrayList 区别 ArrayList  继承 AbstraciList （实现List接口中除了size()和get（int location）之外的方法和Collection接口）  public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable{ LinkdeList  继承 AbstractSequentialList（继承 AbstractCollectionm,实现了“链表中，根据index索引值操作链表的全部方法”）Deque接口） 双端 &amp;ndash;&amp;gt; 可以被当做站、队列或者双端队列使用  public class LinkedList&amp;lt;E&amp;gt; extends AbstractSequentialList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable { transient int size = 0; /** * Pointer to first node. * Invariant: (first == null &amp;amp;&amp;amp; last == null) || * (first.prev == null &amp;amp;&amp;amp; first.</description>
    </item>
    
    <item>
      <title>Stack</title>
      <link>https://procarihana.github.io/public/notes/stack/</link>
      <pubDate>Fri, 11 Sep 2020 20:06:05 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/stack/</guid>
      <description>stack  stack 继承Vector  Vector  Vector 是 AbstractList 子类  public class Vector&amp;lt;E&amp;gt;extends AbstractList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable{  Vector 实现了 List 接口   ArrayList 也是继承了 AbstructList&amp;lt;&amp;gt;    public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable{ &amp;mdash;&amp;gt; Stack 和 ArrayList 都是继承 AbstructList &amp;mdash;&amp;gt; Stack 本质也是一个 List
 List 子类实现了 RandomAccess 接口，那表示它能快速随机访问存储的元素， 这时候你想到的可能是数组，通过下标 index 访问，实现了该接口的 ArrayList 底层实现就是数组，同样是通过下标访问，只是我们需要用 get() 方法的形式， ArrayList 底层仍然是数组的访问形式。 stack 的 search 能够通过下标查找对象  Stack 方法  初始化  Stack stack = new Stack(); Stack&amp;lt;&amp;gt; stack = new Stack&amp;lt;&amp;gt;();  栈顶元素出栈，并返回  public synchronized E pop() { E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; }  判断是否为空  isEmpty()  添加元素   push 和 list add 实现是一样的    push(ElementItem item)  获取栈顶值，元素不出栈（栈为空时抛出异常）就喵一眼啥也不干  public synchronized E peek() { int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); }  是否存在object   返回值为int，若存在，返回值为obj距离栈顶的位置，若不存在，返回 -1    public synchronized int search(Object o) { int i = lastIndexOf(o); if (i &amp;gt;= 0) { return size() - i; } return -1; }  stack 作为list 也具备List 常用方法  //获取stack长度 size() //下标处添加 add(int index, E element) //添加集合 addAll(Collection&amp;lt;?</description>
    </item>
    
    <item>
      <title>命令行</title>
      <link>https://procarihana.github.io/public/notes/%E5%91%BD%E4%BB%A4%E8%A1%8C/</link>
      <pubDate>Wed, 09 Sep 2020 15:11:56 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E5%91%BD%E4%BB%A4%E8%A1%8C/</guid>
      <description>查看历史   history | grep 关键字   查看端口   lsof -i:80   kill 端口进程   kill -9 进程号   查看流量   ping com   获得本机局域网IP地址，由路由器分配 -&amp;gt; 192.168.1.7   ifconfig    lo0: flags=8049&amp;lt;UP,LOOPBACK,RUNNING,MULTICAST&amp;gt; mtu 16384 options=1203&amp;lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP&amp;gt; inet 127.0.0.1 netmask 0xff000000 inet6 ::1 prefixlen 128 inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1 nd6 options=201&amp;lt;PERFORMNUD,DAD&amp;gt; gif0: flags=8010&amp;lt;POINTOPOINT,MULTICAST&amp;gt; mtu 1280 stf0: flags=0&amp;lt;&amp;gt; mtu 1280 XHC20: flags=0&amp;lt;&amp;gt; mtu 0 en0: flags=8863&amp;lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&amp;gt; mtu 1500 ether ac:bc:32:8b:8d:55 inet6 fe80::1810:c22d:afa:8bf9%en0 prefixlen 64 secured scopeid 0x5 inet 192.</description>
    </item>
    
    <item>
      <title>题目</title>
      <link>https://procarihana.github.io/public/posts/%E9%A2%98%E7%9B%AE/</link>
      <pubDate>Tue, 08 Sep 2020 20:10:37 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/%E9%A2%98%E7%9B%AE/</guid>
      <description>基础 Java程序的运行原理  编译过程.java -编译器Compiler（编译）-&amp;gt; .class[字节码]   编译的结果存放在tarket、classes 里面   字节码通过JVM识别后解析成不同系统的调用，从而实现java 的跨平台   Object 里面有native()是一个空白的类,jvm里native实现能够让运行平台决定如何实现，    JDK/JRE 有什么区别  JDK = JRE + javac   JDK 完成java源代码到字节码的编译和运行过程，包含JRE   JRE 完成字节码到底层调用的解析和运行过程，如果只是运行java 程序，只安装JRE就可以了，不需要安装JDK。其中JVM就是完成java 实现跨平台的核心部分。  Java 的基础类型  char/string/short/byte/long/int/boolean/float   String 是基本数据类型？         Java 的参数传递是传值还是传引用  在Java里所有的对象都只是一个指针，传递的时候只是传递地址的拷贝，所以是传引用   一切对象都是指针（地址）     函数调用永远是传值。函数调用的过程中，把对象作为参数传递到函数里面的时候，传递的是一个复制的地址，地址里面包含对象的数据。这个传送复制的地址的过程就是传值。    引用数据类型(Reference data type)如一个对象(object)的传递，是以值的形式传进方法(are also passed into methods by value)。这意味着当函数执行完（when the method returns），传进去的引用（the passed-in reference）仍然参考(指向)之前的对象(still references the same object as before)。但是，对象的值(字段)可以在方法中被改变。</description>
    </item>
    
    <item>
      <title>简历</title>
      <link>https://procarihana.github.io/public/notes/%E7%AE%80%E5%8E%86/</link>
      <pubDate>Tue, 08 Sep 2020 19:44:00 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E7%AE%80%E5%8E%86/</guid>
      <description>技能    =======
项目一   描述：多人在线博客平台
   基于SpringBoot搭建框架     利用Mybatis完成连接数据库     通过Spring Security完成用户认证和授权     通过UIDD和迭代完成密码的加密     使用Java Mockito 完成集成测试     通过Docker 使用Mysql、Jenkins完成数据库和自动化部署；使用NGINX进行分布式部署    项目二  描述：记账系统 =======   通过Spring Security完成认证和授权     通过UIDD和迭代完成密码的加密     使用Java Mockito 完成集成测试     通过Docker 使用Mysql、Jenkins完成数据库和自动化部署     在阿里云里发布    项目二  描述：   基于SpringBoot框架搭建框架     使用Mybatis链接数据库     通过Shiro完成 认证、授权和web集成     使用CheckStyle、Jacoco和Spotbugs完成代码检查     使用Swagger 生成API文档     通过Docker 使用Mysql、Redis完成数据库的建立和数据缓存    </description>
    </item>
    
    <item>
      <title>MYSQL</title>
      <link>https://procarihana.github.io/public/notes/mysql/</link>
      <pubDate>Tue, 08 Sep 2020 11:24:13 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/mysql/</guid>
      <description>数据库主键  UUID是无序的，所以不能用UUID进行数据库主键查找  主键 -- 唯一标识一条记录，不能有重复的，不允许为空 外键 -- 表的外键不一定是另一表的主键，但必须是唯一性索引,外键可以有重复的, 可以是空值 索引 -- 该字段没有重复值，但可以有一个空值 作用： 主键 -- 用来保证数据完整性 外键 -- 用来和其他表建立联系用的 索引 -- 是提高查询排序的速度 个数： 主键 -- 主键只能有一个 外键 -- 一个表可以有多个外键 索引 -- 一个表可以有多个唯一索引 SQL标准事务  原子性：事物内的业务全部完成才算成功，有一步失败都会回滚到最初。 一致性：满足数据库完整性的约束，就是建表的时候数据的类型约束、数据范围等，都会满足。 隔离性：写的内容没有提交前，其他读的对象是只能够执行没有改变前的数据内容，只有写的内容提交后才能够读到变更后的内容。 持久性：事物一旦提交，就会永久保存到数据库里面，即使系统发生故障，数据库也能够将数据恢复。  隔离级别  read-commited 云服务器一般都会用这个，因为隔离级别比较高 Console begin并不是开始，只有执行语句才是真正的开始 read uncommitted 读未提交： 一个事务还没提交时，它做的变更就能被别的事务看到。    脏读： 没有commit 的数据被 另一个console读取到了 可以获得最新的数据，    读提交（READ COMMITTED）只能看到提交的事物，但是不可重复度，因为执行多次的查询可能会得到不同的结果（因为多次查询中间如果其他事务进行了commit，查询的结果就会出现不同） 可重复读：在同一个事务中，多次进行查询的到的结果也是一样的，即使在多次读取的中间有其他事务进行了commit，读取的结果也不会因为其他的commit而改变。(没有commit也不能够读取到)    但是可能会出现幻读：在其他事务已经插入了某个ID的数据且commit，在可重复读的事务里不能够查询到这个数据，还能够用同样的ID进行数据的插入和查询，没有出现主键冲突的现象，commit后查询能够看到同一个ID插入了两条不一样的数据   但是在mysql 8 后就禁用了，一般都不会出现   在一个事务中SELECT操作一致，就是依靠ReadView(一致性视图的生成)    可串行化（SERIAIZABLE）：   事务查询数据时，如果其他事务在进行数据的变更时候没有commit，就必须等待直到其他事务commit后才能够查询出数据结果，否则会一直等待到超时     对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。     实现serializable(可串行)采用加锁的策略通过牺牲并发能力而保证数据安全)   事务隔离级别就是系统并发能力和数据安全性间的妥协，隔离性越高，数据库的性能就越差  Mysql 事务  在不同的隔离级别下，数据库通过 MVCC 和隔离级别，让事务之间并行操作遵循了某种规则，来保证单个事务内前后数据的一致性 Multiversion concurrency control 多版本并发控制   并发访问（读或者写）数据库时，对正在事务内处理的数据做多版本的管理，用来避免由于写操作的堵塞，而引发读操作失败的并发问题。     MVCC机制下基于生成的Undo log链和一致性视图ReadView来实现的    MYISAM并不支持事务  独立于操作系统，可以轻松地将其从Windows服务器移植到LIinux 里面 选择密集型的表。 MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。 插入密集型的表。 MyISAM的并发插入特性允许同时选择和插入数据。  InnoDB实现了MVCC的事务并发处理机  需要事务支持，并且有较高的并发读取频率选择InnDB    单纯的MVCC机制并不能解决幻读问题,InnoDB也是通过加间隙锁来防止幻读    InnoDB 下的 MVCC 实现原理（Undo log）    在InnoDB中MVCC的实现通过两个重要的字段进行连接：DB_TRX_ID和DB_ROLL_PT，在多个事务并行操作某行数据的情况下，不同事务对该行数据的UPDATE会产生多个版本，数据库通过DB_TRX_ID来标记版本，然后用DB_ROLL_PT回滚指针将这些版本以先后顺序连接成一条 Undo Log 链。   DB_TRX_ID: 事务id，6byte，每处理一个事务，值自动加一。     InnoDB中每个事务有一个唯一的事务ID叫做 transaction id。在事务开始时向InnoDB事务系统申请得到，是按申请顺序严格递增的     每行数据是有多个版本的，每次事务更新数据时都会生成一个新的数据版本，并且把transaction id赋值给这个数据行的DB_TRX_ID    DB_ROLL_PT: 回滚指针，7byte     指向当前记录的ROLLBACK SEGMENT 的undolog记录，通过这个指针获得之前版本的数据。该行记录上所有旧版本在 undolog 中都通过链表的形式组织。    还有一个DB_ROW_ID(隐含id,6byte，由innodb自动产生)，      InnoDB下聚簇索引B+Tree的构造规则:</description>
    </item>
    
    <item>
      <title>Web页面  前后端渲染</title>
      <link>https://procarihana.github.io/public/posts/web%E9%A1%B5%E9%9D%A2-%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Mon, 07 Sep 2020 14:59:13 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/web%E9%A1%B5%E9%9D%A2-%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93/</guid>
      <description>前端渲染：前端发送静态的html，浏览器下载html里面的JS、CSS文件，等待下载完后就加载并初始化JS代码，可运行后就想后端请求数据，等待后端完成数据返回。客户端从无到完整，把数据渲染为响应页面 后端渲染：服务器端请求数据（内网请求快），服务器初始渲染（服务端性能较快），服务端返回已经有正确内容的HTML，客户端请求JS/CSS文件，等待下载完成且加载并初始化完成 前端渲染：前端发送静态的html数据 后端渲染：后端发送htlm数据  渲染模板  index.html -&amp;gt; 静态模板  &amp;lt;!DOCTYPE heml&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h2&amp;gt;商品排行榜&amp;lt;/h2&amp;gt; &amp;lt;table&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;排名&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;商品名&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;成交金额&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;西瓜&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;400&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;2&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;香蕉&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;200&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;3&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;...&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;...&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  动态模板引擎 -&amp;gt; spring-freemarker   模板引擎就是能够然数据替换   maven  &amp;lt;!-- spring-boot-starter-freemarker --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-freemarker&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;  文件结构 (View) resources/templaes/~.ftl -&amp;gt; 存放动态模板   其中list 为结果集 name-&amp;gt;items    &amp;lt;table&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;排名&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;商品名&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;成交金额&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;#list items as item&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;${item.</description>
    </item>
    
    <item>
      <title>MYSQL记录合集</title>
      <link>https://procarihana.github.io/public/notes/mysql%E8%AE%B0%E5%BD%95%E5%90%88%E9%9B%86/</link>
      <pubDate>Sun, 06 Sep 2020 15:43:53 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/mysql%E8%AE%B0%E5%BD%95%E5%90%88%E9%9B%86/</guid>
      <description>1.联接查询作为数据
insert into AddressList (name,address) select a.UserName,b.address from SYSTEM_Users a inner join BASE_Customer b on a.code=b.code
问题：
 &amp;ldquo;Error attempting to get column &amp;lsquo;goods_name&amp;rsquo; from result set. Cause: java.sql.SQLDataException: Cannot determine value type from string &amp;lsquo;桃子&amp;rsquo;\n; Cannot determine value type from string &amp;lsquo;桃子&amp;rsquo;; nested exception is java.sql.SQLDataException: Cannot determine value type from string &amp;lsquo;桃子&amp;rsquo;&amp;rdquo; 缺少无参数构造函数 moudle 四件套   @Builder     @Data     @AllArgsConstructor     @NoArgsConstructor    记录 Select  select ~ from ~ right join ~ on ~ group by ~ order by ~   as 别名 case when 条件 then 满足条件结果 else 不满足条件结果 case when ?</description>
    </item>
    
    <item>
      <title>Flyaway and Flyway</title>
      <link>https://procarihana.github.io/public/notes/flyaway-and-flyway/</link>
      <pubDate>Sun, 06 Sep 2020 11:42:45 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/flyaway-and-flyway/</guid>
      <description>Docker mysal 迁移h2 的数据库  建立一个储存数据库的目录（datadir） mkdir   mkdir mysql-data  在docker 上面开设mysql的数据库   docker run --name mockNews-mysql -v `pwd`/mysql-mockNewsData:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=hana -e MYSQL_DATABSE=databasename -p 3306:3306 -d mysql    pwd只要MAC能够，Windows要用全路径名   更改有flyway的连接（用户名为root，密码为docker run 上面设置的密码）和Mybatis的config.xml里面的url，    config
    flyway 数据库自动化管理 pom.xml
 &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.flywaydb&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;flyway-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.4&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;url&amp;gt;jdbc:mysql://localhost:3306/NEWS&amp;lt;/url&amp;gt; &amp;lt;user&amp;gt;root&amp;lt;/user&amp;gt; &amp;lt;password&amp;gt;hana&amp;lt;/password&amp;gt; &amp;lt;/configuration&amp;gt; or  &amp;lt;configuration&amp;gt; &amp;lt;url&amp;gt;jdbc:mysql://localhost:3306/news&amp;lt;/url&amp;gt; &amp;lt;user&amp;gt;root&amp;lt;/user&amp;gt; &amp;lt;password&amp;gt;hana&amp;lt;/password&amp;gt; &amp;lt;property name=&amp;quot;url&amp;quot;value=&amp;quot;jdbc:mysql://localhost:3306/news?characterEncoding=utf-8&amp;quot;/&amp;gt; 在src/main/resources/db/migration添加数据库需要重置的内容</description>
    </item>
    
    <item>
      <title>AOP和装饰器模式以及Redis</title>
      <link>https://procarihana.github.io/public/posts/aop%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8Aredis/</link>
      <pubDate>Fri, 04 Sep 2020 16:40:35 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/aop%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8Aredis/</guid>
      <description>代理  静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。 基于 JDK 实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。(jdk动- 态代理是由java内部的反射机制来实例化代理对象，并代理的调用委托类方法) 基于CGlib 动态代理模式 基于继承被代理类生成代理子类，不用实现接口。只需要被代理类是非final 类即可。(cglib动态代理底层是借助asm字节码技术 基于 Aspectj 实现动态代理（修改目标类的字节，织入代理的字节，在程序编译的时候 插入动态代理的字节码，不会生成全新的Class ） 基于 instrumentation 实现动态代理（修改目标类的字节码、类装载的时候动态拦截去修改，基于javaagent） -javaagent:spring-instrument-4.3.8.RELEASE.jar （类装载的时候 插入动态代理的字节码，不会生成全新的Class ）  CGlib  基于CGlib 技术动态代理代理类实现 (基于继承) Cglib是针对类来实现代理的，他的原理是对代理的目标类生成一个子类，并覆盖其中方法实现增强，因为底层是基于创建被代理类的一个子类，所以它避免了JDK动态代理类的缺陷。  但因为采用的是继承，所以不能对final修饰的类进行代理。final修饰的类不可继承。
JDK 动态代理  InvocationHandler接口被Proxy类回调处理，一般实现 InvocationHandler 接口的类具有委托类引用，接口方法 invoke 中添加公共代码并调用委托类的接口方法。(PersonInvocationHandler.java) JDK提供生成动态代理类的核心类Proxy ( JDK 提供的Proxy.java)  【https://cloud.tencent.com/developer/article/1461796】
一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤： 1、通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(&amp;hellip;);
2、通过为Proxy类指定ClassLoader对象和一组interface代理类需要实现的接口，创建动态代理类类文件，默认JDK并不会保存这个文件到文件中；可以保存起来观察生成的代理类结构Class clazz = Proxy.getProxyClass(classLoader,new Class[]{&amp;hellip;});
3、通过上面新建的代理clazz的反射机制获取动态代理类的一个构造函数，其构造函数入参类型是调用处理器接口(IvocationHandler)类型 Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});
4、通过构造函数实例创建代理类实例，此时需将调用处理器对象作为参数被传入 Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler)); 为了简化对象创建过程，Proxy类中的newInstance工具方法封装了2~4，只需两步即可完成代理对象的创建。</description>
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://procarihana.github.io/public/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Wed, 02 Sep 2020 23:44:15 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>正则表达式  ⽤于描述⽂本/字符串的⼀组规则   你可以使⽤⼀些强⼤的规则来：   处理⽂本 提取信息  常⽤的元字符          ^ 开始位置   $ 结束位置   . 单个任意字符（不⼀定包含换⾏符）   \w 单个“word”字符 字⺟/数字/下划线/汉字   \s 单个空⽩字符（\n\r\t）   \d 单个数字字符   \b 单词的开始或结束    重复          |0次或多次   |1次或多次 ? |0次或1次 {n} |n次 {n,} |&amp;gt;=n次 {n,m} |n到m次  选择          [aeiou] 单个的a/e/i/o/u字符之⼀   [0-9] 单个数字字符   [A-Z] 单个⼤写字⺟   [A-Z0-9_] ⼤写字⺟或者数字或者下划线   Hi hi 等价于    反义          [^aeiou] 单个的除a/e/i/o/u之外的字符   [^A] 单个⾮x字符   \W 单个⾮\w（字⺟/数字/下划线/汉字）   \S 单个⾮\s（空⽩）   \D 单个⾮\d（数字）字符   \B ⾮开头/结束位置    Java中的正则表达式  String split() 划分的标准   line 为”\n“   replaceAll/replaceFirst matches    尽量少⽤或者少编译，因为效率低 Java中的正则表达式是⽐较昂贵的 正则表达式需要解析，代码⾮常昂贵 匹配过程⾮常昂贵   分组与捕获  想要将所有符合正则表达式的⽂本抓出来处理 使⽤括号来指定⼀个被捕获的分组 分组的编号从1开始 分组的编号计算只看左括号 (?</description>
    </item>
    
    <item>
      <title>Docker的原理和应用</title>
      <link>https://procarihana.github.io/public/posts/docker%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/</link>
      <pubDate>Tue, 01 Sep 2020 18:41:11 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/docker%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/</guid>
      <description>虚拟机有一套完整独立的操作系统，非常占内存和资源,虚拟机内即使有空闲的资源也不能够集中利用，只能够浪费 docker 启动的容器用于运行程序，剩余的内存能够继续用于新的容器，从而节省内存 阿里云的镜像加速所向无敌  { &amp;#34;registry-mirrors&amp;#34;: [ &amp;#34;https://t8svkgrf.mirror.aliyuncs.com&amp;#34; ], &amp;#34;debug&amp;#34;: true, &amp;#34;experimental&amp;#34;: false } Docker  保证开发、测试、交付、部署的环境完全一致 保证资源的隔离   通过fastjson 任意代码执行漏洞，通过java进程获得来操控别的进程从而过得Linux的控制权限。而Docker 资源隔离只能够获得Docker内的权限，对宿主机没有任何影响   启动临时的、用完即弃的环境，例如测试 迅速（秒级）超大规模部署和扩容   可以迅速扩容大量的容器，且环境是一模一样的    Docker 的基本概念  镜像 image   一个预定好的模板文件，Docker 引擎可以按照这个模板文件启动无数个一模一样，互不干扰的容器     像是一份清单一样，每次启动这个镜像就按照这份清单来启动   容器 container   一台虚拟的计算机，拥有独立的：      网络 文件系统 进程      默认和宿主机不发生任何交互      意味着数据是没有持久化的   Docker 指令 docker run : 启动一个全新的控制资源隔离的docker容器  一台独立的计算机 每个容器都有一个ID，支持缩写 docker run -it &amp;lt;镜像名&amp;gt;&amp;lt;镜像中要运行的命令和参数&amp;gt;   交互式命令行模式，当前shell中运行。Ctrl-c退出（启动一个容器，并立刻进入内部进行操作）   docker run -d   daemon模式，在后台运行   &amp;ndash; name 为容器指定一个名字 &amp;ndash; restart=always 遇到错误马上重启 -&amp;gt; 用于NGINX等    docker run &amp;ndash;name springboot-nginx &amp;ndash;restart=always -v pwd/nginx/nginx.</description>
    </item>
    
    <item>
      <title>Spring</title>
      <link>https://procarihana.github.io/public/notes/spring/</link>
      <pubDate>Tue, 01 Sep 2020 11:37:47 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/spring/</guid>
      <description>Spring 容器原理  Ioc 容器的事实标准 Ioc (Inverse of Control控制反转) :只需要告诉容器对象的依赖关系，容器就会自动完成依赖和Beans的生成，通过依赖注入完成依赖，整个过程就是控制反转 Java对象是Bean 当A对象必须使用B对象才能完成自己的工作的时候，就是A依赖B  Spring 注解  @RestController （Spring4.0）   继承 @Controller，在SpringMvc当中使用@Controller来标识当前类是一个控制器Servlet。     包含@Target(value=TYPE) @Retention(value=RUNTIME)、@Documented 、@Controller 、@ResponseBody   @RequestMapping，提供路由信息，告诉Spring 任何来自”/“路径的HTTP请求都会被映射到home 方法，@RestController注解告诉Spring 以字符串的形式渲染结果，并直接返回给调用者。    两者都是SpringMvc 的注解，不是SpringBoot特定部分    @EnableAutoConfiguration   告诉SpringBoot 根据添加的Jar 依赖猜测配置Spring。 而Spring-boot-start-web添加了Tomcat 和SpringMvc ，所以auto-configutation 会嘉定你正在开发一个web应用并对Spring 进行设置。     如果有不想自动配置的类可以通过 来禁止使用      @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})    @Configuration   @Configuration注解该类，等价 与XML中配置beans；用@Bean标注方法等价于XML中配置bean   @SpringBootApplication == @Configuration ， @EnableAutoConfiguration 和 @ComponentScan   能够自动在Application 中完成配置   @ResponseBody   表示该方法的返回结果直接写入HTTP response body中     一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上 @responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如 异步获取json数据，加上@responsebody后，会直接返回json数据。   @Resposotory诗句持久层DAO @Component   泛指组件，当组件不好归类的时候，可以使用这个注解进行标注。一般公共的方法会用上这个注解。非Controller、Service、DAO部分的注解   @Service   一般用于修饰service层的组件   @ComponentScan   表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。   @AutoWired   byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构 造函数进行标注，完成自动装配的工作。     当加上（required=false）时，就算找不到bean也不报错。   @RequestParam   用在方法的参数前面。   @PathVariable   路径变量。   @ControllerAdvice   包含@Component。可以被扫描到。     统一处理异常。   @ExceptionHandler（Exception.</description>
    </item>
    
    <item>
      <title>Mybatis</title>
      <link>https://procarihana.github.io/public/notes/mybatis/</link>
      <pubDate>Tue, 01 Sep 2020 10:57:12 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/mybatis/</guid>
      <description>Environment DataSource   dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。
  大多数 MyBatis 应用程序会按示例中的例子来配置数据源。虽然数据源配置是可选的，但如果要启用延迟加载特性，就必须配置数据源。 有三种内建的数据源类型（也就是 type=&amp;rdquo;[UNPOOLED|POOLED|JNDI]&amp;quot;）：
   UNPOOLED– 这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢，但对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择。 性能表现则依赖于使用的数据库，对某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性：      driver – 这是 JDBC 驱动的 Java 类全限定名（并不是 JDBC 驱动中可能包含的数据源类）。 url – 这是数据库的 JDBC URL 地址。 username – 登录数据库的用户名。 password – 登录数据库的密码。 defaultTransactionIsolationLevel – 默认的连接事务隔离级别。 defaultNetworkTimeout – 等待数据库操作完成的默认网络超时时间（单位：毫秒）。查看 java.sql.Connection#setNetworkTimeout() 的 API 文档以获取更多信息。 作为可选项，你也可以传递属性给数据库驱动。只需在属性名加上“driver.”前缀即可，例如：driver.encoding=UTF8这将通过 DriverManager.getConnection(url, driverProperties) 方法传递值为 UTF8 的 encoding 属性给数据库驱动。      POOLED– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求。    除了上述提到 UNPOOLED 下的属性外，还有更多属性用来配置 POOLED 的数据源：</description>
    </item>
    
    <item>
      <title>Bean</title>
      <link>https://procarihana.github.io/public/notes/bean/</link>
      <pubDate>Tue, 01 Sep 2020 10:04:08 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/bean/</guid>
      <description>Bean生成   一个对象生成Bean只能用一个方法配置，不能每个方法都对同一个对象生成bean
  class从java下一个文件夹开始~
class=java.com.service.OrderService&amp;ndash;&amp;gt;class=com.service.OrderService
  Bean 配置
   xml（旧的）   新建一个src/main/resources/applicationContext.xml 复制  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot; xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt; &amp;lt;!-- &amp;lt;context:component-scan base-package=&amp;quot;com.in28minutes.spring.basics&amp;quot;/&amp;gt; --&amp;gt; &amp;lt;bean id=&amp;quot;xmlStringBean1&amp;quot; class=&amp;quot;java.lang.String&amp;quot;&amp;gt; &amp;lt;constructor-arg value=&amp;quot;stringBean1&amp;quot; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;quot;xmlStringBean2&amp;quot; class=&amp;quot;java.lang.String&amp;quot;&amp;gt; &amp;lt;constructor-arg value=&amp;quot;stringBean2&amp;quot; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/beans&amp;gt;  修改bean id 和所在的class,不需要参数可以删掉 添加一个配置类(Eg:XmlConfiguration.class)，Bean会被加载。最好是放在一个包里面方便管理  @Configuration @ImportResource({&amp;#34;classpath*:applicationContext.xml&amp;#34;}) public class XmlConfiguration { } @ammunition   新建一个配置类(Eg:JavaConfiguration.class)  package com.</description>
    </item>
    
    <item>
      <title>SpringBoot Blog</title>
      <link>https://procarihana.github.io/public/projects/springboot-blog/</link>
      <pubDate>Tue, 01 Sep 2020 08:01:27 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/projects/springboot-blog/</guid>
      <description>Spring Security
 就是一个Spring生态中关于安全方面的框架,是一个基于Spring AOP和Servlet过滤器的安全框架,充分利用了依赖注入（DI，Dependency Injection）和面向切面技术 SecurityContextHolder用于存储安全上下文（security context）的信息。当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权限…这些都被保存在SecurityContextHolder中。SecurityContextHolder默认使用ThreadLocal 策略来存储认证信息。看到ThreadLocal 也就意味着，这是一种与线程绑定的策略。Spring Security在用户登录时自动绑定认证信息到当前线程，在用户退出时，自动清除当前线程的认证信息。 通过 @EnableWebSecurity注解开启Spring Security的功能 Authentication是spring security包中的接口，直接继承自Principal类，而Principal是位于java.security包中的。   Authentication在spring security中是最高级别的身份/认证的抽象。     由这个顶级接口，我们可以得到用户拥有的权限信息列表，密码，用户细节信息，用户身份信息，认证信息。 一个简单的使用Spring Security来进行验证用户名字密码的登录   Maven  ## Servlet #### HTTP 超文本传输协议 - 能够给任何人传送任何类型的文件 #### Tomcat - servlet容器 - catalina #### Filter 过滤器 - 是一个执行过滤任务的对象， - doFilter 请求响应，也能够通过FilterChain传给下一个filter，实现过滤的功能 #### listerner - Tomcat 容器启动是需要时间的，必须等待Tomcat容器启动之后，Servlet才能够启动 - 用于启动和关闭Spring容器的本体 #### Docker - 用统一的环境处理软件交互，运行速度比虚拟机要快 - Docker一个进程就是一个虚拟机，监听一个端口，和宿主机没有任何的交互关系 - docker的端口和本机的端口没有关系，除非绑定 #### index.html ##### 渲染 - 后端渲染:根据用户请求的内容的不同，决定返回的内容 - 前端渲染：把后端返回的内容填充到页面上面 - 渲染模板：渲染的过程发生的地方是由在前端还是后端的进行渲染决定的 ##### 浏览器 - 浏览器栏发出的请求都是GET - 要调试post请求需要用到其他工具，例如postman - HTTP请求是无状态的，每一次的请求对于服务器和浏览器来说都是一样的 #### JVM - Java 10编译器 能不能运行Java 8编译出来的文件，取决于Java 10 生成出来的文件版本，如果编译出来的.</description>
    </item>
    
    <item>
      <title>Try/catch</title>
      <link>https://procarihana.github.io/public/notes/catch/</link>
      <pubDate>Tue, 01 Sep 2020 07:07:27 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/catch/</guid>
      <description>Try/catch    try { int i = 10 / 0; } finally { System.out.println(&amp;#34;last&amp;#34;); }  能够成功执行，并且会返回last，同时也会返回Exeception 提示：: / by zero  finally 不一定都会被执行   try里面包含System.exit() finally 里包含异常就会抛出异常并终止执行  try { System.out.println(&amp;#34;try&amp;#34;); } catch (Exception e) { System.out.println(&amp;#34;catch&amp;#34;); } finally { int k = 3 / 0; System.out.println(&amp;#34;finally&amp;#34;); } System.out.println(&amp;#34;main&amp;#34;); </description>
    </item>
    
    <item>
      <title>算法和数据结构</title>
      <link>https://procarihana.github.io/public/posts/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 31 Aug 2020 20:15:50 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>空接口:只是说明有这个功能，使用这个框架，但是不提供实现
例如：RandomAccess…… 随机访问  时间复杂度与常数时间的哈希表  时间复杂度   最好时间复杂度     最坏时间复杂度     平均时间复杂度     O(1) - 哈希桶/数组随机寻址（常数时间复杂度）     哈希表的时间复杂度指的是品均时间复杂度      无论问题的规模多大，都可以在常数时间范围内求得解 解决的题的时间和问题的规模没有关系 O(1) = O(2) =O(3) = …… 因为只要是常数都是等价的   内存寻址：内存寻址的时间和内存的大小、内存存放的位置无关，和硬件电路有关     数组：array、arrayList（继承object）   哈希桶、哈希表   把对象映射成整数，然后这个整数放进哈希表里（数组）       数组的容量是有限的，但是对象的变化是无限的，造成在有限中存放无限，就会产生碰撞，而碰撞就通过链表来解决。（但是在java8发生了改变）       Hashmap 如何扩容……  indexFor 当hashmap 被恶意放进大量相同的value，就会出现hashmap退化成列表，查询时间就会变成O(n),所以为了防止这种情况，就在Java7 的时候把算法改成列表加红黑树  时间复杂度算法  O(1)=O(2)=O(3)/常数 - 哈希桶/数组随机寻址（常数）   O(n) - 遍历（线性）     O(log(n)) - 二分查找，二叉树（对数）     O(n*log(n))- 基于比较的排序算法下限     O(lg(n)) - 二分查找，二叉树（对数）     O(n*lg(n))- 基于比较的排序算法下限     O(n^2) - 冒泡排序（平方）     O(n^3) 普通的没有优化过的二维矩阵的乘法   时间复杂度的计算是忽略常数的   O(n)=O(2n)   时间复杂度的计算中，高阶复杂度会吞并低阶复杂度   O(n^2)+O(n)=O(n^2)    时间复杂度的合并与乘方  基于比较的排序时间复杂度的上限是O(Nlg(n))[所有基于比较算法最好的时间复杂度都是nlg(n)]  线性时间复杂度与链表  求问题解的时间和问题的规模成正比 示例   求数组、链表的最大值     寻找数组中的重复元素     判断链表是否存在环（快慢指针）      快指针每次移动2步，慢指针每次移动1步 快慢指针相遇的时候就能够测出有闭环      求阶乘     合并两个链表     翻转链表 解决：   先把数据遍历一遍 排序（O(n*log(n))）比遍历慢  对数时间复杂度  二叉树、N叉数（B树、B+树）   在二叉树中查找某个值      二叉树： node left， node right      二叉树遍历（深度优先遍历）Depth first Search      深度优先会在最底层的节点返回 前序遍历 123 根-&amp;gt;子 中（根）序 213 子-&amp;gt;根-&amp;gt;子 后序 231 子-&amp;gt;子-&amp;gt;根      广度优先遍历 （ 队列 -&amp;gt; 先进先出）Broadth first Search      123456 1—&amp;gt;queue queue-&amp;gt;1;2,3-&amp;gt;queue queue-&amp;gt;2;4,5-&amp;gt;queue /queue:3、4、5 queue-&amp;gt;3;6-&amp;gt;queue /queue:4、5、6 直到队列为空，循环结束 queue.</description>
    </item>
    
    <item>
      <title>Java 部署</title>
      <link>https://procarihana.github.io/public/posts/java-%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Sun, 30 Aug 2020 17:47:43 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java-%E9%83%A8%E7%BD%B2/</guid>
      <description>应用开发流程  产品调研 产品设计 系统设计 -&amp;gt; 全后端文档等 开发 测试 部署  Web应用是怎么工作的  默认443端口 每个HTTP请求背后都是一台主机  分布式  解决用户量大的问题   垂直扩展 ：购入更好的机器     水平扩展 ： 购入更多的机器（分布式）      负载均衡器 Load Balance   负载均衡 容灾（单点故障）：一个服务器故障也不会影响到业务    如何保持数据一致性   让负载均衡器保证同一个用户的请求都发到同一台机器上，但是HTTP是无状态的，同一个用户的不同请求是没有先后顺序的，没有用户标识，都是HTTP请求，即使有Cookie也不行     单一数据源：数据都存在同一个数据库，即使服务器杀死重启复原数据都不会改变，但是不能够避免单点故障的问题，数据库会出问题      大多数情况下，数据库都是稳定的。 数据库会有备份   部署  将开发好的程序放在服务器上   监听端口     相应HTTP请求     进行预定义的业务逻辑处理   产品不停迭代   灰度发布：部分停止服务器进行更新。剩余的服务器有可能承受不了业务请求的数量而垮掉，即使停止的重新工作也不一定能够解决。 半夜更新     部署的版本需要不停进行更新     分布式更新   环境问题   开发环境（测试环境）     预发布环境（预生产环境，可能是生产环境的副本）     生产魂晶（正式环境）   环境的兼容性问题   硬件、软件      开发的软件、运行的软件、服务器系统      数据库等      数据库版本、内容、结构   发布和部署程序  如何在生产环境下运行 解决   编写的代码     依赖的第三方库     依赖的特殊环境配置（数据库、缓存）     稳定性     升级和回滚    使用Maven exec plugin  自动将所有的传递性依赖加入   优点：简单     缺点： 不适用与自动化的场景      运行的时候需要把代码都下载下来，才能够运行。不能够把代码编译成字节码，所以需要绑定到编译后的阶段才能够运行    自动运行的部分记得不要加生命周期！！！不然就会卡在那里的！ configuration 要放在 execution 外面，否则会识别不到executable exec:exec -&amp;gt; 在一个独立的进程中执行一个程序 exec:java -&amp;gt; 在同一个JVM里执行java  &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>JAVA IO</title>
      <link>https://procarihana.github.io/public/posts/io/</link>
      <pubDate>Sun, 30 Aug 2020 15:29:44 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/io/</guid>
      <description>cpu 负责所有运算
  3GHz 每秒运行30亿条指令，做一件事情只需要0.38纳秒
   SSD（固态硬盘）：寻址时间太慢了，和CPU形成矛盾     内存：存数据，断电丢失     硬盘（硬盘驱动器） 存数据容量大，断电不丢失    一个文件本质上是一段字节流，由一个执行程序决定怎么执行一段字节流（16进制）
  字节范围 0～255
一切文件的本质  一段字节流：   文本文件（txt/代码/HTML等）     二进制文件   每个程序负责解释文件中的字节流  输入输出是站在程序的角度
InputStream/PutputStream  抽象的输入/输出操作   从文件读取字节流 【实战】    value ==-1 的时候，循环结束
 -从网络读取字节流【实战】 -从其他
最好使用绝对路径
抽象类不能直接实例化，因为抽象类里面包含还没有实现的方法 InputStream…… 这种只是抽象方法，不能够直接实现 用ProcessBuilder建立新的进程  Java中的File   file 代表的是文件路径</description>
    </item>
    
    <item>
      <title>计算机网络TCP and Socket</title>
      <link>https://procarihana.github.io/public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Ctcp-and-socket/</link>
      <pubDate>Sun, 30 Aug 2020 11:39:13 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Ctcp-and-socket/</guid>
      <description>没有100%可靠的通信协议  红军/蓝军 计算机网络：虚电路分组，A服务器把报文给离目标IP最近的力所能及的设备（过程为HOP），这个设备再把报文发给下一个设备，如果中间某个最佳的设备被毁，就选择另一个设备绕过，直到到达目标IP（快递发货）   网络分层模型  TCP/IP模型（应用层、传输层【四层交换机、四层路由器】、网络层【路由器，三层交换机】） TCP Transmisson Control ProTocal 传输控制协议   TCP的握手与断开       三次握手建立连接        SYN SENT seq = x 发送请求建立连接的请求 -&amp;gt; 获得SYN seq=y,ACK x+1 （同意建立请求） ACK =y+1 表明收到同意建立连接 ==&amp;gt; 连接建立，        四次挥手断开连接        FIN seq = x+2 ACK = y+1发送断链接的请求 -&amp;gt; 获得ACK x+3 表示收到，又获得 FIN seq= y+1 表示断开链接 ACK = y+2 表示收到同意断开链接        如果中间有信息丢掉没有成功收到，会通过请求超时来知道链接断开成功     TCP 协议无法传递数据包，只能把所有数据包拆、黏包   TCP 没有规定包的界限，需要自己设计协议、分隔符、结束符来设计包的边界   TCP 中的数据包含TCP 包首部和数据两个部分，而IP中的数据包含前两个部分，在加上IP包首部 TCP 只有两个字节的端口（65536），端口数量有限制（同时使用），而每个端口访问的对象是不限制   TCP数据里面有确认号码，如果接受的没有收到，就需要重传。校验和可以检验数据是否有被串改，如果有则向发送的一方放再次发送请求 的   以太网则在IP数据的基础杀昂添加以太网包首部 TCP特点   面向连接     点对点 需要有目标端口     可靠交付 校验和、序列号码、确认号码 保证数据正确     面向字节流   UDP 协议（用于视频）   无连接的 无法保证数据是否到达     尽最大可能交付     面向报文的    Scoket  TCP包含客户端和服务器双方的ip和port。这四个元素是四元组（client的src源ip、port和dest目标ip。port），也就是socket/socket的链接。   ip &amp;ndash;&amp;gt; 唯一确定一台计算机，port &amp;ndash;&amp;gt; 端口可以唯一确定监听端口的一个程序   socket 只要制定目标ip和port 就可以发送信息，自身ip会自动提供，如果有指定的port就会使用，如果没有就会自动挑选一个空闲的端口   查询网站ip地址： $ nslookup + 地址    public class SocketTest { public static void main(String[] args) throws IOException { Socket socket = new Socket(&amp;#34;182.</description>
    </item>
    
    <item>
      <title>AccountingService</title>
      <link>https://procarihana.github.io/public/projects/accountingservice/</link>
      <pubDate>Mon, 10 Aug 2020 20:48:22 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/projects/accountingservice/</guid>
      <description>.ignore放什么 1 *.iml 是 intellij idea的工程配置文件，里面是当前project的一些配置信息。.Idea存放项目的配置信息，包括历史记录，版本控制信息等。 2. .idea/ 3. target/
项目结构和模型转换  external 用于存放外部团队的接口和服务，然后再Manager里面放。在接口处写注析。 exception 异常处理 config 存放MybatisBean等等的Bean Controller 存放SpringBoot对外接口（API接口）   不要有过多的处理逻辑 参数校验越早做越好  manager 组合各个业务的逻辑 先写接口后写实现 Dao Converter 用于转换 Moudle的common向service等等的转换但是不能够用于Http、数据库、IO等操作 Service 部分是给前段展示的内容，不能直接返回密码（加密后的还是可以的）等内容  添加Maven  通过Maven getting start  SpringBoot Spring boot 开发四大步  添加相应依赖   SpringBoot 引入       基础Maven引入：、spring-boot-starter-web、plugin     添加相应注解   添加Appliation类作为SpringBoot入口，并添加注解@SpringBootApplication     添加Controller类，并添加注解@RestController      @RestController == @Controller + @ResponseBodymapping    编写代码 添加相应配置   在resources里添加application.</description>
    </item>
    
    <item>
      <title>Spring Web</title>
      <link>https://procarihana.github.io/public/posts/spring-web/</link>
      <pubDate>Mon, 06 Jul 2020 15:29:45 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/spring-web/</guid>
      <description>Web 和 HTTP  Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。  从零开始⼀个Spring应⽤ • pom.xml • src/main/java/hello/Application.java • src/main/java/hello/HelloController.java
Query String 最简单的HTTP请求（查询字符串），就是</description>
    </item>
    
    <item>
      <title>HTML 标签</title>
      <link>https://procarihana.github.io/public/posts/html-%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Sat, 04 Jul 2020 17:11:23 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/html-%E6%A0%87%E7%AD%BE/</guid>
      <description>A标签  作用   跳转外部页面     跳转内部锚点     跳转到邮箱或电话等    href  超级链接  &amp;lt;body&amp;gt; &amp;lt;a herf = &amp;#34;https://google.com&amp;#34; target=&amp;#34;_blank&amp;#34; download&amp;gt;超链&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; target  在哪个窗口打开超级链接   在空白页打开超级链接     在    download rel=noopener target  在哪个窗口打开超级链接   在空白页打开    &amp;lt;a href=&amp;#34;//goole.com&amp;#34; target=_blank&amp;gt;top&amp;lt;/a&amp;gt;    在顶层打开链接（正常打开链接）&amp;ndash; top     在本层打开（Google 不允许用iframe指向，所以打不开，如果可以打开，则可以再其他页面直接打开）    如何在编辑过程中正确打开html  http-server   安装    $ yarn global add http-server   启动并点击任一网址，要编写路径</description>
    </item>
    
    <item>
      <title>Java面向对象————多态</title>
      <link>https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</link>
      <pubDate>Mon, 11 May 2020 17:20:16 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</guid>
      <description>面向对象的三大特征 封装 继承 多态 多态：不同类的不同的实现方法
 方法名字变量都一样，但是子类继承后的实现不一样  重载：两个类同一个方法的不同实现,根据最接近的类型进行匹配
 方法名相同，参数表不一样  多态 实例方法本身是多态的 实例：一个方法不是静态的就是实例方法
通过区分有无Statci
 在运行时根据this（当前对象的实际类型）来决定调用哪个方法 []方法接收者  obj.method(1)
消息接受者.消息（参数）//接受者会根据消息的不同自行决定如何响应消息
 静态方法没有多态 参数静态绑定，接受者动态绑定 覆盖：重写父类中的方法，方法名、参数不能改变，但是返回值可以改变   多态只对方法的接受者生效     多态只选择接受者的类型，不选择参数的类型    public class Base { public void print(ParamBase param) { System.out.println(&amp;#34;I am Base,the param is ParamBase&amp;#34;); } public void print(ParamSub param){ System.out.println(&amp;#34;I am Base,the param is ParamSub&amp;#34;); } } public class Sub extends Base { @Override public void print(ParamBase param){ System.</description>
    </item>
    
    <item>
      <title>Java面向对象——组合与继承</title>
      <link>https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Mon, 11 May 2020 17:19:33 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/</guid>
      <description>三大特征 封装 继承 public class Animal { protected String name;
public Animal(String name) { this.name = name; } public void sayMyName() { System.out.println(&amp;quot;我的名字是&amp;quot; + name); } public class Cat extends Animal{ public Cat(String name) { super(name); } public void meow() { System.out.println(&amp;quot;喵&amp;quot; + name); } } public class Main { public static void main(String[] args) { Cat cat = new Cat(&amp;quot;ABC&amp;quot;); cat.meow(); cat.sayMyName(); }  多态 继承 DRY（Donot Repeat Yourself）  事不过三，三则重构  继承的本质是提炼出公用代码，避免重复 继承一个类就会自动继承类的行为</description>
    </item>
    
    <item>
      <title>Java 面向对象初步——封装与隐藏</title>
      <link>https://procarihana.github.io/public/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F/</link>
      <pubDate>Mon, 11 May 2020 17:18:58 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F/</guid>
      <description>面向对象的三大特征 封装 优点：实现细节可以发生变化，只要接口不变，就不会对使用产生影响 理念：对外暴露尽可能少的细节
继承 多态 封装 封装隐藏了内部实现细节，只暴露出接口 电灯对象 高、低耦合
  你只访问他的“开关”接口，不关心内部的“电路”细节
 public static void main(String[] args) { Light light = new Light(); light.turnOn();//低耦合 Light light2 = new Light(); light2.打开电路1(); light2.打开电路2(); light2.打开电路3(); //高耦合,比低耦合更难扩展 //Home类和Light类之间建立联系——&amp;gt;耦合（让改变变得困难） //一方进行改变时，另一方也需要进行改变 public class Light {  public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节
} public void 打开电路1(){
} public void 打开电路2(){
} public void 打开电路3(){
}
  废弃后使用自动停止，不影响其他代码的运行
public class Light { @Deprecated public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节 } public static void main(String[] args) { Light light = new Light();  light.</description>
    </item>
    
    <item>
      <title>Java 面向对象初步</title>
      <link>https://procarihana.github.io/public/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5/</link>
      <pubDate>Mon, 11 May 2020 17:18:01 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5/</guid>
      <description>面向对象的三大特征 封装 优点：实现细节可以发生变化，只要接口不变，就不会对使用产生影响
继承 多态 封装 封装隐藏了内部实现细节，只暴露出接口 电灯对象   你只访问他的“开关”接口，不关心内部的“电路”细节
 public static void main(String[] args) { Light light = new Light(); light.turnOn();//低耦合 Light light2 = new Light(); light2.打开电路1(); light2.打开电路2(); light2.打开电路3(); //高耦合,比低耦合更难扩展 //Home类和Light类之间建立联系——&amp;gt;耦合（让改变变得困难） //一方进行改变时，另一方也需要进行改变 public class Light {  public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节
} public void 打开电路1(){
} public void 打开电路2(){
} public void 打开电路3(){
}
  废弃后使用自动停止，不影响其他代码的运行
public class Light { @Deprecated public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节 } public static void main(String[] args) { Light light = new Light();  light.</description>
    </item>
    
    <item>
      <title>Java面向对象系统基础</title>
      <link>https://procarihana.github.io/public/posts/java%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 07 May 2020 16:40:59 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</guid>
      <description>对象（引用类型）  对象是数据和行为的集合（主观能动性） 一切使用new运算符创建出来的都是对象   new Object（）     特例： Integer i=2/String s= &amp;ldquo;2&amp;rdquo; 自动装拆箱的时候后会自动new 出一个新的对象     特例：new Object[]    对象组成？  所有的对象都在堆上分配 每个对象都包含⾃⼰的数据（成员变量）   初始化
声明int age = 0; 和int age;是相同的，因为默认初始化的值为0 【整数类型】
String 等引用类型的为null   原⽣类型的成员 引⽤类型的成员  栈、堆 栈：方法栈，main执行后需要用到的方法都会放到方法栈里面执行 堆：存放对象
对象的构造函数  新建对象的唯⼀途径 在堆上分配空间 执⾏必要的初始化⼯作 执⾏构造器函数 如果没有任何构造器，编译器会偷偷摸摸帮你⽣成⼀个  对象的方法  数据：有什么 方法：做什么  方法的重载(overload)  重载（overload）与重写/覆盖（override）    重载</description>
    </item>
    
    <item>
      <title>Java的控制流</title>
      <link>https://procarihana.github.io/public/posts/java%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/</link>
      <pubDate>Wed, 06 May 2020 21:05:25 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/</guid>
      <description>控制流 控制流：方法调用 方法调用就是一个方法栈，每当开始一个新的方法调用的时候就会开启一个方法栈的栈针，方法调用之后方法针会被销毁。当有新的方法调用的时候就会开始新一轮的方法栈，循环往复。
while与 do while 循环   while（返回boolean语句)
{
……
}
  do {无论真假就先执行一遍}
while{(返回 boolean语句）;}
  控制流：for 循环   fori
 for（int i = 0;//任何语句，包括空语句 1️⃣ i &amp;lt; 100;//返回boolean的语句，包括空语句 2️⃣ i++){//任何语句，包括空语句） 4️⃣ System.out.println(i); //3️⃣ }    for each
for（String s :Iterable）{ …… }
  对象能够实现Iterabie接口（可迭代）
List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;); //遍历列表，把元素拿出来 for (int i = ;i&amp;lt;list.size(); i++){ System.out.println(list.get(i)); } == for(String element : list){ System.</description>
    </item>
    
    <item>
      <title>爬虫项目</title>
      <link>https://procarihana.github.io/public/posts/%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Wed, 06 May 2020 17:07:22 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/</guid>
      <description>原则  使用GitHub+主干/分支模型进行开发 禁止直接push master 所有的变更通过PR进行 自动化代码质量检查+测试 Checkstyle/SpotBugs 最基本的自动化测试覆盖 一切工作自动化 规范化提交流程   创建仓库流程   Github -new
  建立新项目 newBranch 的时候选Apache License 2.0
   Mvn archetype 项目骨架     IDEA - new     copy （cp -r ../* .）    .gitigonre
  git commit &amp;ndash;amend 就可以把这一次的commit和上一次的合并起来
   记得要把.iml 放进（vi .gitignore）： *.iml和target/(放在最后一行就好) 更改pom 里面的groundId，artifactId cp -r ～/.circleci . (因为之前cp ～* 的时候并不会cp到.</description>
    </item>
    
    <item>
      <title>爬虫项目</title>
      <link>https://procarihana.github.io/public/projects/%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Wed, 06 May 2020 17:07:22 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/projects/%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/</guid>
      <description>原则  使用GitHub+主干/分支模型进行开发 禁止直接push master 所有的变更通过PR进行 自动化代码质量检查+测试 Checkstyle/SpotBugs 最基本的自动化测试覆盖 一切工作自动化 规范化提交流程   创建仓库流程   Github -new
  建立新项目 newBranch 的时候选Apache License 2.0
   Mvn archetype 项目骨架     IDEA - new     copy （cp -r ../* .）    .gitigonre
  git commit &amp;ndash;amend 就可以把这一次的commit和上一次的合并起来
   记得要把.iml 放进（vi .gitignore）： *.iml和target/(放在最后一行就好) 更改pom 里面的groundId，artifactId cp -r ～/.circleci . (因为之前cp ～* 的时候并不会cp到.</description>
    </item>
    
    <item>
      <title>IDEAMaven调试器的基本使用</title>
      <link>https://procarihana.github.io/public/posts/ideamaven%E8%B0%83%E8%AF%95%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 06 May 2020 17:06:17 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/ideamaven%E8%B0%83%E8%AF%95%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid>
      <description>SpotBugs  Maven 生命周期
设置生命周期后的Maven会在相应的阶段执行 Picture 设置 生命周期对应执行的工作需要绑定插件进行设置   complie —— goal ——&amp;gt; maven-compilen-plugin test —— goal ——&amp;gt; surefire 测试插件 verlfy —— goal ——&amp;gt; checkstyle（非核心插件可以绑定到任何阶段  Maven 生命周期  编译源代码   mvn compile   发布项目   mvn deploy   编译测试源代码   mvn test-compile   运行应用程序中的单元测试   mvn test   生成项目相关信息的网站   mvn site   编译源代码   mvn compile   清除项目目录中的生成结果   mvn clean 根据项目生成的jar mvn package 在本地Repository中安装jar mvn install 生成eclipse项目文件 mvn eclipse:eclipse 启动jetty服务 mvn jetty:run 启动tomcat服务 mvn tomcat:run 清除以前的包后重新打包，跳过测试类 mvn clean package -Dmaven.</description>
    </item>
    
    <item>
      <title>Java的运算系统</title>
      <link>https://procarihana.github.io/public/posts/java%E7%9A%84%E8%BF%90%E7%AE%97%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 01 May 2020 16:42:24 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java%E7%9A%84%E8%BF%90%E7%AE%97%E7%B3%BB%E7%BB%9F/</guid>
      <description>基本运算   /
int b = 5/2; &amp;ndash;&amp;gt;结果为 &amp;lsquo;2&amp;rsquo;（地板除）
  取余运算
5/2=2……1
System.out.println(9 % 5);——&amp;gt;2 System.out.println(-9 % 5);——&amp;gt;-2(余数)      判断奇偶
通过取余是否为零完成
//判断一个整数是不是奇数 public static boolean isOdd(int number){ return number % 2 != 0; }    运算符
    += ，-= ，*=，/=
Eg：a+=2 | a = a+2
  += a +=3 ==&amp;gt; a = a + 3
  -= a -=3 ==&amp;gt;a - e</description>
    </item>
    
    <item>
      <title>Java的数据类型</title>
      <link>https://procarihana.github.io/public/posts/java%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 29 Apr 2020 15:16:54 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>数据类型  Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节。 两种数据类型   原生数据 赋值的是值本身 引用数据类型 对象 本质上就都是地址 赋值的是地址     原生数据 字节 最小值 最大值     byte 1     short 2  0*7fffffff(21亿)   int 4     long 8  2^63-1   float 4     double 8     char 2        基本数据类型的运算，会自动向上转型。 boolean不可以和其他基本数据类型相互转换。 byte-&amp;gt;short,char -&amp;gt; int -&amp;gt; long float -&amp;gt; double int -&amp;gt; float long -&amp;gt; double    boolean true/false void    存储数据超过最大值会溢出</description>
    </item>
    
    <item>
      <title>Java程序的基本结构</title>
      <link>https://procarihana.github.io/public/posts/java%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 28 Apr 2020 16:58:28 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/java%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</guid>
      <description>Java程序的基本结构 Java 简述  强类型：在内存的每一个数据都需要和一个类型相绑定   即使数据相同，但是类型不一样，解释的方式也不一样  静态   Java code &amp;ndash;&amp;gt; 字节码 （编译）  跨平台性能   操作系统  Linux、windows、mac…… 不同的操作系统有不同的语言 （API 【Application Programming Interface】 应用编程接口）&amp;ndash;&amp;gt;实现跨平台就要通过JVM实现   JVM 【Java Vitual Mach】（Java虚拟机） 字节码   最小单位为字节，八个字节为一个字节码   Java 成句基本结构 类和包的关系  基本结构&amp;ndash;类，Java 程序的最小的结构单元，按照约定放在自己同名的&amp;rsquo;.java&amp;rsquo; 文件中 每个 Class 都处于一个package中 Package 的名字是相对于src决定的，也就是由目录结构确定的，名字通常用域名的倒叙 如果class 直接放在java文件夹下面，就不会显示package 因为处于默认包里面  包的意义  类的名字是一个简单的字符串，通过包更容易区分 Eg：通过运用全限定类名，可以用于区分不同的同名类   全限定类名 ：包含包名的类&amp;ndash;&amp;gt;package.class  可以通过import引入包，可以让引用类的编写更加便捷  第三方包的引用  Maven 当方法属于Java.</description>
    </item>
    
    <item>
      <title>The Second Test</title>
      <link>https://procarihana.github.io/public/posts/the-second-test/</link>
      <pubDate>Sun, 26 Apr 2020 18:49:13 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/the-second-test/</guid>
      <description>Test Second </description>
    </item>
    
    <item>
      <title></title>
      <link>https://procarihana.github.io/public/posts/%E9%81%87%E5%88%B0%E7%9A%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/%E9%81%87%E5%88%B0%E7%9A%84/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>