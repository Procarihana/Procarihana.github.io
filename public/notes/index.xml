<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes on FAFA Blog</title>
    <link>https://procarihana.github.io/public/notes/</link>
    <description>Recent content in Notes on FAFA Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Wed, 30 Sep 2020 10:45:24 +0800</lastBuildDate>
    
	<atom:link href="https://procarihana.github.io/public/notes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Set</title>
      <link>https://procarihana.github.io/public/notes/set/</link>
      <pubDate>Wed, 30 Sep 2020 10:45:24 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/set/</guid>
      <description> Set 用于存储无序（存入和取出的顺序不一定相同）元素，值不能重复  对象相等性 </description>
    </item>
    
    <item>
      <title>LinkedList</title>
      <link>https://procarihana.github.io/public/notes/linkedlist/</link>
      <pubDate>Fri, 18 Sep 2020 17:39:03 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/linkedlist/</guid>
      <description>属性 初始值为0 void push（）  在链条的头部添加元素 addFirst（）  boolrean offer()  在尾部添加元素 实现Queue接口的offer  push()  实质上就是addFirst()  offerLast()/offerFirst ()  实质上执行的addLast()和addFirst()return true  peekFirst()/peekLast()  查看第一个或者最后一个元素，如果list为空则返回null，除此以外什么都不做  poll（）  检索和删除顶元素，如果为null 返回null  pop（）  删除列表的顶元素，如果为null ，则抛出异常  void add(int index, E element)  LinkedList 并没有add（），但是在继承的AbstractSequentiaList里面 有实现add()   add(0, element) 就是把 element 放在first， 原本的first 就会变成second     add(2 ,element) 就是把element 放在第二个的右边，成为第三个元素，原本的第三个就会变成第四个    </description>
    </item>
    
    <item>
      <title>Queue</title>
      <link>https://procarihana.github.io/public/notes/queue/</link>
      <pubDate>Fri, 18 Sep 2020 16:19:46 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/queue/</guid>
      <description>poll  remove head of this queue 不同于 remove 的是当queue为空 的时候会返回null  remove  移出队列的顶元素，队列为空则会抛出异常  offer()  在尾部添加元素  Queue 常用方法            add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常    remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常    element 返回队列头部的元素 如果队列为空，则抛出一个 NoSuchElementException异常   offer 添加一个元素并返回true 如果队列已满，则返回false    poll 移除并返问队列头部的元素 如果队列为空，则返回null    peek 返回队列头部的元素 如果队列为空，则返回null    put 添加一个元素 如果队列满，则阻塞    take 移除并返回队列头部的元素      </description>
    </item>
    
    <item>
      <title>Spring MVC</title>
      <link>https://procarihana.github.io/public/notes/spring-mvc/</link>
      <pubDate>Thu, 17 Sep 2020 23:41:33 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/spring-mvc/</guid>
      <description>Spring MVC   模型model(javabean), 视图view(jsp/img) 控制器Controller(Action/servlet)
  C 存在的目的就是为了保证M和V的一致性 当M发生改变时,C可以把M中的新内容更新到V中.
  使用MVC模式的好处是，Controller专注于业务处理，它的处理结果就是Model。Model可以是一个JavaBean，也可以是一个包含多个对象的Map，Controller只负责把Model传递给View，View只负责把Model给“渲染”出来，这样，三者职责明确，且开发更简单，因为开发Controller时无需关注页面，开发View时无需关心如何创建Model。     SpringMVC是Spring框架内置的MVC的实现，一个Spring内置的MVC框架
MVC框架，它解决WEB开发中常见的问题(参数接收、文件上传、表单验证、国际化、等等)，而且使用简单，与Spring无缝集成。
支持 RESTful风格的 URL 请求 。
采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性。
  为了解决页面代码和后台代码的分离
  </description>
    </item>
    
    <item>
      <title>Servlet</title>
      <link>https://procarihana.github.io/public/notes/servlet/</link>
      <pubDate>Thu, 17 Sep 2020 20:02:18 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/servlet/</guid>
      <description>Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释放其占用的资源</description>
    </item>
    
    <item>
      <title>Set接口</title>
      <link>https://procarihana.github.io/public/notes/set%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Thu, 17 Sep 2020 10:13:05 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/set%E6%8E%A5%E5%8F%A3/</guid>
      <description>addAll  元素不重复 addAll（Colletcion） 如果set里面原本有不属于这个集合的元素，就会被移出，剩下的是原本的set和新集合的交集 不允许添加包含null的集合，否则会出现exception  Add  add（Object） 通过判断Objcet 是否为 null 且是否和集合里面的元素相等，如果Object 已经存在于set里面就不会发生改变并且return false  remove  如果存在这个元素 移出后return true  </description>
    </item>
    
    <item>
      <title>ArryList</title>
      <link>https://procarihana.github.io/public/notes/arrylist/</link>
      <pubDate>Wed, 16 Sep 2020 23:52:09 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/arrylist/</guid>
      <description>初始容量为 10  之后每超过10就添加16个  有设置容量  意义在于先准备一个空间，避免以后不断地扩容造成空间浪费 如果指定初始容量a，数组的容量就为a 如果初始容量为0或者没有指定，就为0 负数就抛出异常  public ArrayList(int initialCapacity) { if (initialCapacity &amp;gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&amp;#34;Illegal Capacity: &amp;#34;+ initialCapacity); } } 扩容的时候自动调整大小  ArrayList 里面有一个Object[] elementData 用于存储实际的元素   包含size   扩容过程    执行add（）的时候会先判断当前未添加前的elementDate.length 是否会等于初始容量 size，如果等于就执行grow()扩容，并把扩容后的新对象组size 赋值到 elementData 里面 Object[]grow（） 增长的最小的目标容量（minCapacity）是当前的目标容量+1   之后执行Object[] grow(int minCapacity) 。先复制就的Array，然后加入扩充好的新容量的数组（newCapacity（int minCapacity））里，复制给elementData并返回这个新的数组       newCapacity(int minCapacity) 新容量的目标容量为旧容量的1.</description>
    </item>
    
    <item>
      <title>锁</title>
      <link>https://procarihana.github.io/public/notes/%E9%94%81/</link>
      <pubDate>Wed, 16 Sep 2020 17:27:26 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E9%94%81/</guid>
      <description> volatile的措施，就是   每次从内存中取值，不从缓存中什么的拿值。这就保证了用 volatile修饰的共享变量，每次的更新对于其他线程都是可见的。 volatile保证了其他线程的立即可见性，就没有保证原子性。 3.由于有些时候对 volatile的操作，不会被保存，说明不会造成阻塞。不可用与多线程环境下的计数器。  </description>
    </item>
    
    <item>
      <title>Maven</title>
      <link>https://procarihana.github.io/public/notes/maven/</link>
      <pubDate>Tue, 15 Sep 2020 23:02:35 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/maven/</guid>
      <description>Maven lifeCycle  verify 运行检查确保代码有效 integration-test (继承测试) 相比于 verify位 于maven生命周期的前几个（运行maven 的范围比 verify少）    如有必要，将包处理和部署到可以运行集成测试的环境中。   </description>
    </item>
    
    <item>
      <title>测试</title>
      <link>https://procarihana.github.io/public/notes/%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Tue, 15 Sep 2020 20:31:34 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E6%B5%8B%E8%AF%95/</guid>
      <description>白盒测试——把测试对象看作一个打开的盒子，程序内部的逻辑结构和其他信息对测试人员是公开的。 黑盒测试——已知产品的功能设计规格，不考虑程序内部结构，进行测试证明每个实现了的功能是否符合要求 灰盒测试——介于白盒和黑盒测试之间，即关注输出对输入的正确性，也关注程序内部表现。 回归测试——软件或环境的修复或更正后的“再测试”，自动测试工具对这类测试尤其有用。 单元测试——是最小粒度的测试，以测试某个功能或代码块。一般由程序员来做，因为它需要知道内部程序设计和编码的细节。
JUnit JUnit中提供了很多断言方法用来测试不同的条件， assertEquals(a, b) 测试a是否等于b（a和b是原始类型数值(primitive value) 或者必须为实现比较而具有equal方法） assertFalse(a) 测试a是否为false （假），a是一个Boolean数值 。 assertTrue(a) 测试a是否为true （真），a是一个Boolean 数值 assertNotNull(a) 测试a是否非空，a是一个对象或者null 。 assertNull(a) 测试a是否为null，a是一个对象或者null 。 assertNotSame(a, b) 测试a和b是否没有都引用同一个对象 。 assertSame(a, b) 测试a和b是否都引用同一个对象 。  Unit 提供了6大类31组断言方法，包括基础断言、数字断言、字符断言、布尔断言、对象断言。   assertEquals（Object expcted,Object actual)内部逻辑判断使用equals()方法，这表明断言两个实例的内部哈希值是否相等时，最好使用该方法对相应类实例的值进行比较。     而assertSame（Object expected,Object actual）内部逻辑判断使用了Java运算符“==”，这表明该断言判断两个实例是否来自于同一个引用（Reference），最好使用该方法对不同类的实例的值进行比对。     asserEquals(String message,String expected,String actual)该方法对两个字符串进行逻辑比对，如果不匹配则显示着两个字符串有差异的地方。     ComparisonFailure类提供两个字符串的比对，不匹配则给出详细的差异字符。 [https://www.cnblogs.com/bnuvincent/archive/2004/01/13/2079550.html]    Mockito  Mockito并非不是通过代理调用真实实例，而是创建它的一个副本。 默认情况下，对于所有返回值的方法，mock将返回null， 一旦存根，该方法将始终返回一个存根值  Mock Spy  Spy使用真实的实例副本来进行，不会和实例进行交互 所以如果你保留真实的实例并与之交互，不要期望被间谍知道那些交互 及其对实际实例状态的影响。 推论是，当 unstustub 方法被称为on spy，而不在实际实例时， *你不会看到对实际实例的任何影响  MockitoUnit  Mockito使用JUnit运行器使测试保持整洁并改进调试体验。   自动检测存根参数，并设置为默认（Mockito 3.</description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>https://procarihana.github.io/public/notes/sql/</link>
      <pubDate>Tue, 15 Sep 2020 11:03:10 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/sql/</guid>
      <description>SQL Structured Query Language  SQL是结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，通过学习SQL这一种语言，就可以操作各种不同的数据库。  SQL 能力  DDL：Data Definition Language   DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。     DML：Data Manipulation Language     DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。   DQL：Data Query Language   DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。    数据库  解决问题;   读写文件并解析出数据需要大量重复代码；     从成千上万的数据中快速查询出指定数据需要复杂的逻辑。    数据类型 对- 于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：
   名称 类型 说明     INT 整型 4字节整数类型，范围约+/-21亿   BIGINT 长整型 8字节整数类型，范围约+/-922亿亿   REAL 浮点型 4字节浮点数，范围约+/-1038   DOUBLE 浮点型 8字节浮点数，范围约+/-10308   DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算   CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串   VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串   BOOLEAN	布尔类型 存储True或者False    DATE 日期类型 存储日期，例如，2018-06-22   TIME 时间类型 存储时间，例如，12:20:59   DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59    数据模型  A：对于层次模型，采用的是树（二叉树）的结构来表达实体和实体间联系（上下级关系） B：网状模型，采用的是图的结构来表达实体和实体间联系（像城市道路一样连接各个城市） C：关系模型，就是用的二维表  候选键(Candidate Key)：一个或者多个属性的集合，可以唯一确定实体的一个实例； 主键(Primary Key):从候选键中，选中用来作为唯一标识的属性或者属性组被称为主键； 可选键(Alternative Key):候选键中没有选中的其他键，称为可选键； 而表的外键是另一表的主键, 外键可以有重复的, 可以是空值。</description>
    </item>
    
    <item>
      <title>计算机基础</title>
      <link>https://procarihana.github.io/public/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 15 Sep 2020 10:40:07 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</guid>
      <description>物理层：中继器、集线器 链路层：网桥、交换机 网络层：路由器
TCP/IP: 数据链路层：ARP,RARP 网络层： IP,ICMP,IGMP 传输层：TCP ,UDP,UGP 应用层：Telnet,FTP,SMTP,SNMP.
OSI: 物理层：EIA/TIA-232, EIA/TIA-499, V.35, V.24, RJ45, Ethernet, 802.3, 802.5, FDDI, NRZI, NRZ, B8ZS 数据链路层：Frame Relay, HDLC, PPP, IEEE 802.3/802.2, FDDI, ATM, IEEE 802.5/802.2 网络层：IP，IPX，AppleTalk DDP 传输层：TCP，UDP，SPX 会话层：RPC,SQL,NFS,NetBIOS,names,AppleTalk,ASP,DECnet,SCP 表示层:TIFF,GIF,JPEG,PICT,ASCII,EBCDIC,encryption,MPEG,MIDI,HTML 应用层：FTP,WWW,Telnet,NFS,SMTP,Gateway,SNMP
端口 http 80 ftp 20/21 ssh 22 telnet 23 smtp 25
jar 将许多文件组合成一个jar文件 javac 编译 javadoc 它从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。 javah 把java代码声明的JNI方法转化成C\C++头文件。 JNI可参考java核心技术卷二第12章
JTextField单行文本 JTextArea多行文本 JButton按键显示 JLable显示标签 信息
JVM虚拟机 类加载过程  类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。 其中准备、验证、解析3个部分统称为连接（Linking）。 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都已HotSpot为基准。  加载 在加载阶段（可以参考java.</description>
    </item>
    
    <item>
      <title>多线程</title>
      <link>https://procarihana.github.io/public/notes/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 14 Sep 2020 22:21:40 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>多线程一共有三种实现方式 方式1：继承Thread类，并重写run()方法 方式2：实现Runnable接口，实现run()方法 方式3：实现Callable接口，线程结束后可以有返回值，但是该方式是依赖于线程池的。</description>
    </item>
    
    <item>
      <title>Enum</title>
      <link>https://procarihana.github.io/public/notes/enum/</link>
      <pubDate>Mon, 14 Sep 2020 21:56:22 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/enum/</guid>
      <description>题目    enum AccountType { SAVING, FIXED, CURRENT; private AccountType() { System.out.println(“It is a account type”); } } class EnumOne { public static void main(String[]args) { System.out.println(AccountType.FIXED); } }  所有的枚举值都是类静态常量，在初始化时会对所有的枚举值对象进行第一次初始化。 枚举类在后台实现时，实际上是转化为一个继承了java.lang.Enum类的实体类，原先的枚举类型变成对应的实体类型，上例中AccountType变成了个class AccountType，并且会生成一个新的构造函数，若原来有构造函数，则在此基础上添加两个参数，生成新的构造函数，如上例子中：  private AccountType(){ System.out.println(“It is a account type”); } 会变成：
private AccountType(String s, int i){ super(s,i); System.out.println(“It is a account type”); }
而在这个类中，会添加若干字段来代表具体的枚举类型： ```java public static final AccountType SAVING; public static final AccountType FIXED; public static final AccountType CURRENT; 而且还会添加一段static代码段：</description>
    </item>
    
    <item>
      <title>数组</title>
      <link>https://procarihana.github.io/public/notes/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 14 Sep 2020 21:01:00 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E6%95%B0%E7%BB%84/</guid>
      <description>初始化为{5,3,1} nums.add(6)后list为{5,3,1,6} nums.add(0,4)是在0号索引上添加数字4得到list为{4,5,3,1,6} nums.remove(1)是将1号索引上的5进行remove得到list为{4,3,1,6}</description>
    </item>
    
    <item>
      <title>待处理</title>
      <link>https://procarihana.github.io/public/notes/%E5%BE%85%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 14 Sep 2020 20:44:10 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E5%BE%85%E5%A4%84%E7%90%86/</guid>
      <description>Java通过synchronized进行访问的同步，synchronized作用非静态成员方法和静态成员方法上同步的目标是不同的
character流和byte流的区别 字符流和字节流每次读入的字节数是不确定的，可能相同也可能不相同；字符流和字节流都有缓冲流
完全二叉树
get是立即加载，load是延迟加载。 hibernate
重载的概念是：
方法名称相同，参数个数、次序、类型不同
因此重载对返回值没有要求，可以相同，也可以不同
但是如果参数的个数、类型、次序都相同，方法名也相同，仅返回值不同，则无法构成重载
Java的静态方法属于类的成员，实例方法属于对象的成员。 java不允许单独的方法，过程或函数存在,需要隶属于某一类中。 java语言中的方法属于对象的成员,而不是类的成员。不过，其中静态方法属于类的成员。
从java虚拟机的角度讲，只有两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用的是c++实现的，是虚拟机的一部分，另一类是就是所有其他类加载器，这些类加载器都由java语言实现，独立于虚拟机外部，并且全都继承自抽象类。 从开发人员的角度看，类加载器还可以划分为3种系统类加载器，启动类加载器（Bootstrap ClassLoader），负责加载存放在&amp;lt;JAVA_HOME&amp;gt;/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符的类库即使放在lib目录中也不会被加载）类库加载到虚拟机中内存中。启动类加载器无法被java程序直接引用，用户在编写自定义类加载器是，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。 扩展类加载器（Extension ClassLoader）：这个类加载器有sun.misc.Launcher$ExtClassLoader实现，负责加载&amp;lt;JAVA_HOME&amp;gt;/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。 应用类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以也称它为系统类加载器（System ClassLoader）。他负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。对此，如果有必要开发者可以加入自己定义的类加载器。 一般对于我们java程序员来说，类的加载使用的是双亲委派模型，即当一个类需要加载时，会将类传给Application ClassLoader，但是Application ClassLoader并不会加载，不管它是否能加载，而是传给它的&amp;quot;父类&amp;rdquo; Extension ClassLoader，Extension ClassLoader同样不会加载，同样传给 Bootstrap ClassLoader（注意不是我们常说的那种父类，但是可以这样理解）,这时Bootstrap ClassLoader会判断它是否能加载，能加载就直接加载了，不能加载就传给Extension ClassLoader，Extension ClassLoader同样的判断是否能加载，能加载就直接加载，不能加载就传给Application ClassLoader，然后Application ClassLoader也判断能否加载，如果还是不能加载应该就是报ClassNotFoundException了。这就是双亲委托模型的简单理解了。 对于上面的&amp;quot;父类&amp;quot;为什么要打引号，因为它们并不是真的像java中继承的关系，而是组合的关系，即在&amp;quot;子类&amp;quot;中存在一个成员变量指向&amp;quot;父类&amp;quot;的引用。 所以AE对DF错了。 对于C，很容易理解，因为我们知道一个类只需要加载一次就够了，所以要保证线程安全。 难点就在B了，其实也好理解，就是体现双亲委托模型的优势的时候了，之所以使用双亲委托机制是为了保证java程序的稳定运作，比如当你使用的不是双亲委托模型的时候，然后刚好开发者又定义了一个类，一个java.lang.String这样一个类，如果不使用双亲委托模型，当类加载的时候就有可能会加载开发者定义的String类，这导致了java代码的一片混乱，可读性极差。（PS：但这并不意味着类加载器只要双亲委托模型就行了，没有完美的模型，只有最合适的模型，有不同的需求使用不同的模型。比如破坏双亲委派模型，有兴趣的牛友可以自行了解），所以可以这么说，不同的类加载器加载出来的类是不一样的，不同的类加载器加载同一个类会在方法区产生两个不同的类，彼此不可见，并且在堆中生成不同的Class实例。对于接口，其实就是一个特殊的类，和类一样，在堆中产生不同的class对象。 纯手打，个人理解，欢迎大佬指出错误。
A.Java系统提供3种类加载器：启动类加载器（Bootstrap ClassLoader） 扩展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader）. A正确  B.《深入理解Java虚拟机》P228：对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类必定不相等。接口类是一种特殊类，因此对于同一接口不同的类装载器装载所获得的类是不相同的。B错误 C.类只需加载一次就行，因此要保证类加载过程线程安全，防止类加载多次。C正确 D. Java程序的类加载器采用双亲委派模型，实现双亲委派的代码集中在java.lang.ClassLoader的loadClass()方法中，此方法实现的大致逻辑是：先检查是否已经被加载，若没有加载则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出ClassNotFoundException异常。D错误 E.双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。E正确 F.应用程序类加载器（Application ClassLoader）负责加载用户类路径（ClassPath）上所指定的类库，不是所有的ClassLoader都加载此路径。F错误
链接：https://www.nowcoder.com/questionTerminal/b82e4a85a66e4dc488a5ab49094976e9 来源：牛客网
1、ThreadLocal的类声明： public class ThreadLocal可以看出ThreadLocal并没有继承自Thread，也没有实现Runnable接口。所以AB都不对。 2、ThreadLocal类为每一个线程都维护了自己独有的变量拷贝。每个线程都拥有了自己独立的一个变量。 所以ThreadLocal重要作用并不在于多线程间的数据共享，而是数据的独立，C选项错。 由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问， 变量被彻底封闭在每个访问的线程中。所以E对。 3、ThreadLocal中定义了一个哈希表用于为每个线程都提供一个变量的副本： static class ThreadLocalMap {</description>
    </item>
    
    <item>
      <title>Cookie and Session</title>
      <link>https://procarihana.github.io/public/notes/cookie/</link>
      <pubDate>Sat, 12 Sep 2020 16:08:36 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/cookie/</guid>
      <description>Session 一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。
Session 和 cookie  会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。 Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。  Session 和 cookie 区别  Cookie与Session的区别cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的； cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session； session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；  什么是 Cookie？   Cookie 是浏览器访问服务器后，服务器传给浏览器的一段数据。 浏览器需要保存这段数据，不得轻易删除。 此后每次浏览器访问该服务器，都必须带上这段数据。    Cookie 是一些数据, 存储于你电脑上的文本文件中。   当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。   Cookie 的作用就是用于解决 &amp;ldquo;如何记录客户端的用户信息&amp;rdquo;:   当用户访问 web 页面时，他的名字可以记录在 cookie 中。 在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。   设置了新的 cookie，旧的 cookie 不会被覆盖。 Cookies提供了一种在服务器和浏览器之间交换信息的方法，以管理会话（登录，购物车，游戏得分），记住用户首选项（主题，隐私策略接受）以及跟踪整个站点的用户行为。Cookies在一定程度上解放了服务器端的压力，因为将一部分数据放在浏览器端存储，所以这部分数据不能是涉及应用安全的数据。  Cookie 作用   第一个作用是识别用户身份。
   比如用户 A 用浏览器访问了 http://a.</description>
    </item>
    
    <item>
      <title>List</title>
      <link>https://procarihana.github.io/public/notes/list/</link>
      <pubDate>Fri, 11 Sep 2020 20:17:55 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/list/</guid>
      <description>List add  添加元素在右边（最后）  LinkedList 和 ArrayList 区别 ArrayList  继承 AbstraciList （实现List接口中除了size()和get（int location）之外的方法和Collection接口）  public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable{ LinkdeList  继承 AbstractSequentialList（继承 AbstractCollectionm,实现了“链表中，根据index索引值操作链表的全部方法”）Deque接口） 双端 &amp;ndash;&amp;gt; 可以被当做站、队列或者双端队列使用  public class LinkedList&amp;lt;E&amp;gt; extends AbstractSequentialList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable { transient int size = 0; /** * Pointer to first node. * Invariant: (first == null &amp;amp;&amp;amp; last == null) || * (first.prev == null &amp;amp;&amp;amp; first.</description>
    </item>
    
    <item>
      <title>Stack</title>
      <link>https://procarihana.github.io/public/notes/stack/</link>
      <pubDate>Fri, 11 Sep 2020 20:06:05 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/stack/</guid>
      <description>stack  stack 继承Vector  Vector  Vector 是 AbstractList 子类  public class Vector&amp;lt;E&amp;gt;extends AbstractList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable{  Vector 实现了 List 接口   ArrayList 也是继承了 AbstructList&amp;lt;&amp;gt;    public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable{ &amp;mdash;&amp;gt; Stack 和 ArrayList 都是继承 AbstructList &amp;mdash;&amp;gt; Stack 本质也是一个 List
 List 子类实现了 RandomAccess 接口，那表示它能快速随机访问存储的元素， 这时候你想到的可能是数组，通过下标 index 访问，实现了该接口的 ArrayList 底层实现就是数组，同样是通过下标访问，只是我们需要用 get() 方法的形式， ArrayList 底层仍然是数组的访问形式。 stack 的 search 能够通过下标查找对象  Stack 方法  初始化  Stack stack = new Stack(); Stack&amp;lt;&amp;gt; stack = new Stack&amp;lt;&amp;gt;();  栈顶元素出栈，并返回  public synchronized E pop() { E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; }  判断是否为空  isEmpty()  添加元素   push 和 list add 实现是一样的    push(ElementItem item)  获取栈顶值，元素不出栈（栈为空时抛出异常）就喵一眼啥也不干  public synchronized E peek() { int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); }  是否存在object   返回值为int，若存在，返回值为obj距离栈顶的位置，若不存在，返回 -1    public synchronized int search(Object o) { int i = lastIndexOf(o); if (i &amp;gt;= 0) { return size() - i; } return -1; }  stack 作为list 也具备List 常用方法  //获取stack长度 size() //下标处添加 add(int index, E element) //添加集合 addAll(Collection&amp;lt;?</description>
    </item>
    
    <item>
      <title>命令行</title>
      <link>https://procarihana.github.io/public/notes/%E5%91%BD%E4%BB%A4%E8%A1%8C/</link>
      <pubDate>Wed, 09 Sep 2020 15:11:56 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E5%91%BD%E4%BB%A4%E8%A1%8C/</guid>
      <description>查看历史   history | grep 关键字   查看端口   lsof -i:80   kill 端口进程   kill -9 进程号   查看流量   ping com   获得本机局域网IP地址，由路由器分配 -&amp;gt; 192.168.1.7   ifconfig    lo0: flags=8049&amp;lt;UP,LOOPBACK,RUNNING,MULTICAST&amp;gt; mtu 16384 options=1203&amp;lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP&amp;gt; inet 127.0.0.1 netmask 0xff000000 inet6 ::1 prefixlen 128 inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1 nd6 options=201&amp;lt;PERFORMNUD,DAD&amp;gt; gif0: flags=8010&amp;lt;POINTOPOINT,MULTICAST&amp;gt; mtu 1280 stf0: flags=0&amp;lt;&amp;gt; mtu 1280 XHC20: flags=0&amp;lt;&amp;gt; mtu 0 en0: flags=8863&amp;lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&amp;gt; mtu 1500 ether ac:bc:32:8b:8d:55 inet6 fe80::1810:c22d:afa:8bf9%en0 prefixlen 64 secured scopeid 0x5 inet 192.</description>
    </item>
    
    <item>
      <title>简历</title>
      <link>https://procarihana.github.io/public/notes/%E7%AE%80%E5%8E%86/</link>
      <pubDate>Tue, 08 Sep 2020 19:44:00 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/%E7%AE%80%E5%8E%86/</guid>
      <description>技能    =======
项目一   描述：多人在线博客平台
   基于SpringBoot搭建框架     利用Mybatis完成连接数据库     通过Spring Security完成用户认证和授权     通过UIDD和迭代完成密码的加密     使用Java Mockito 完成集成测试     通过Docker 使用Mysql、Jenkins完成数据库和自动化部署；使用NGINX进行分布式部署    项目二  描述：记账系统 =======   通过Spring Security完成认证和授权     通过UIDD和迭代完成密码的加密     使用Java Mockito 完成集成测试     通过Docker 使用Mysql、Jenkins完成数据库和自动化部署     在阿里云里发布    项目二  描述：   基于SpringBoot框架搭建框架     使用Mybatis链接数据库     通过Shiro完成 认证、授权和web集成     使用CheckStyle、Jacoco和Spotbugs完成代码检查     使用Swagger 生成API文档     通过Docker 使用Mysql、Redis完成数据库的建立和数据缓存    </description>
    </item>
    
    <item>
      <title>MYSQL</title>
      <link>https://procarihana.github.io/public/notes/mysql/</link>
      <pubDate>Tue, 08 Sep 2020 11:24:13 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/mysql/</guid>
      <description>数据库主键  UUID是无序的，所以不能用UUID进行数据库主键查找  主键 -- 唯一标识一条记录，不能有重复的，不允许为空 外键 -- 表的外键不一定是另一表的主键，但必须是唯一性索引,外键可以有重复的, 可以是空值 索引 -- 该字段没有重复值，但可以有一个空值 作用： 主键 -- 用来保证数据完整性 外键 -- 用来和其他表建立联系用的 索引 -- 是提高查询排序的速度 个数： 主键 -- 主键只能有一个 外键 -- 一个表可以有多个外键 索引 -- 一个表可以有多个唯一索引 SQL标准事务  原子性：事物内的业务全部完成才算成功，有一步失败都会回滚到最初。 一致性：满足数据库完整性的约束，就是建表的时候数据的类型约束、数据范围等，都会满足。 隔离性：写的内容没有提交前，其他读的对象是只能够执行没有改变前的数据内容，只有写的内容提交后才能够读到变更后的内容。 持久性：事物一旦提交，就会永久保存到数据库里面，即使系统发生故障，数据库也能够将数据恢复。  隔离级别  read-commited 云服务器一般都会用这个，因为隔离级别比较高 Console begin并不是开始，只有执行语句才是真正的开始 read uncommitted 读未提交： 一个事务还没提交时，它做的变更就能被别的事务看到。    脏读： 没有commit 的数据被 另一个console读取到了 可以获得最新的数据，    读提交（READ COMMITTED）只能看到提交的事物，但是不可重复度，因为执行多次的查询可能会得到不同的结果（因为多次查询中间如果其他事务进行了commit，查询的结果就会出现不同） 可重复读：在同一个事务中，多次进行查询的到的结果也是一样的，即使在多次读取的中间有其他事务进行了commit，读取的结果也不会因为其他的commit而改变。(没有commit也不能够读取到)    但是可能会出现幻读：在其他事务已经插入了某个ID的数据且commit，在可重复读的事务里不能够查询到这个数据，还能够用同样的ID进行数据的插入和查询，没有出现主键冲突的现象，commit后查询能够看到同一个ID插入了两条不一样的数据   但是在mysql 8 后就禁用了，一般都不会出现   在一个事务中SELECT操作一致，就是依靠ReadView(一致性视图的生成)    可串行化（SERIAIZABLE）：   事务查询数据时，如果其他事务在进行数据的变更时候没有commit，就必须等待直到其他事务commit后才能够查询出数据结果，否则会一直等待到超时     对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。     实现serializable(可串行)采用加锁的策略通过牺牲并发能力而保证数据安全)   事务隔离级别就是系统并发能力和数据安全性间的妥协，隔离性越高，数据库的性能就越差  Mysql 事务  在不同的隔离级别下，数据库通过 MVCC 和隔离级别，让事务之间并行操作遵循了某种规则，来保证单个事务内前后数据的一致性 Multiversion concurrency control 多版本并发控制   并发访问（读或者写）数据库时，对正在事务内处理的数据做多版本的管理，用来避免由于写操作的堵塞，而引发读操作失败的并发问题。     MVCC机制下基于生成的Undo log链和一致性视图ReadView来实现的    MYISAM并不支持事务  独立于操作系统，可以轻松地将其从Windows服务器移植到LIinux 里面 选择密集型的表。 MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。 插入密集型的表。 MyISAM的并发插入特性允许同时选择和插入数据。  InnoDB实现了MVCC的事务并发处理机  需要事务支持，并且有较高的并发读取频率选择InnDB    单纯的MVCC机制并不能解决幻读问题,InnoDB也是通过加间隙锁来防止幻读    InnoDB 下的 MVCC 实现原理（Undo log）    在InnoDB中MVCC的实现通过两个重要的字段进行连接：DB_TRX_ID和DB_ROLL_PT，在多个事务并行操作某行数据的情况下，不同事务对该行数据的UPDATE会产生多个版本，数据库通过DB_TRX_ID来标记版本，然后用DB_ROLL_PT回滚指针将这些版本以先后顺序连接成一条 Undo Log 链。   DB_TRX_ID: 事务id，6byte，每处理一个事务，值自动加一。     InnoDB中每个事务有一个唯一的事务ID叫做 transaction id。在事务开始时向InnoDB事务系统申请得到，是按申请顺序严格递增的     每行数据是有多个版本的，每次事务更新数据时都会生成一个新的数据版本，并且把transaction id赋值给这个数据行的DB_TRX_ID    DB_ROLL_PT: 回滚指针，7byte     指向当前记录的ROLLBACK SEGMENT 的undolog记录，通过这个指针获得之前版本的数据。该行记录上所有旧版本在 undolog 中都通过链表的形式组织。    还有一个DB_ROW_ID(隐含id,6byte，由innodb自动产生)，      InnoDB下聚簇索引B+Tree的构造规则:</description>
    </item>
    
    <item>
      <title>MYSQL记录合集</title>
      <link>https://procarihana.github.io/public/notes/mysql%E8%AE%B0%E5%BD%95%E5%90%88%E9%9B%86/</link>
      <pubDate>Sun, 06 Sep 2020 15:43:53 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/mysql%E8%AE%B0%E5%BD%95%E5%90%88%E9%9B%86/</guid>
      <description>1.联接查询作为数据
insert into AddressList (name,address) select a.UserName,b.address from SYSTEM_Users a inner join BASE_Customer b on a.code=b.code
问题：
 &amp;ldquo;Error attempting to get column &amp;lsquo;goods_name&amp;rsquo; from result set. Cause: java.sql.SQLDataException: Cannot determine value type from string &amp;lsquo;桃子&amp;rsquo;\n; Cannot determine value type from string &amp;lsquo;桃子&amp;rsquo;; nested exception is java.sql.SQLDataException: Cannot determine value type from string &amp;lsquo;桃子&amp;rsquo;&amp;rdquo; 缺少无参数构造函数 moudle 四件套   @Builder     @Data     @AllArgsConstructor     @NoArgsConstructor    记录 Select  select ~ from ~ right join ~ on ~ group by ~ order by ~   as 别名 case when 条件 then 满足条件结果 else 不满足条件结果 case when ?</description>
    </item>
    
    <item>
      <title>Flyaway and Flyway</title>
      <link>https://procarihana.github.io/public/notes/flyaway-and-flyway/</link>
      <pubDate>Sun, 06 Sep 2020 11:42:45 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/flyaway-and-flyway/</guid>
      <description>Docker mysal 迁移h2 的数据库  建立一个储存数据库的目录（datadir） mkdir   mkdir mysql-data  在docker 上面开设mysql的数据库   docker run --name mockNews-mysql -v `pwd`/mysql-mockNewsData:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=hana -e MYSQL_DATABSE=databasename -p 3306:3306 -d mysql    pwd只要MAC能够，Windows要用全路径名   更改有flyway的连接（用户名为root，密码为docker run 上面设置的密码）和Mybatis的config.xml里面的url，    config
    flyway 数据库自动化管理 pom.xml
 &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.flywaydb&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;flyway-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.4&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;url&amp;gt;jdbc:mysql://localhost:3306/NEWS&amp;lt;/url&amp;gt; &amp;lt;user&amp;gt;root&amp;lt;/user&amp;gt; &amp;lt;password&amp;gt;hana&amp;lt;/password&amp;gt; &amp;lt;/configuration&amp;gt; or  &amp;lt;configuration&amp;gt; &amp;lt;url&amp;gt;jdbc:mysql://localhost:3306/news&amp;lt;/url&amp;gt; &amp;lt;user&amp;gt;root&amp;lt;/user&amp;gt; &amp;lt;password&amp;gt;hana&amp;lt;/password&amp;gt; &amp;lt;property name=&amp;quot;url&amp;quot;value=&amp;quot;jdbc:mysql://localhost:3306/news?characterEncoding=utf-8&amp;quot;/&amp;gt; 在src/main/resources/db/migration添加数据库需要重置的内容</description>
    </item>
    
    <item>
      <title>Spring</title>
      <link>https://procarihana.github.io/public/notes/spring/</link>
      <pubDate>Tue, 01 Sep 2020 11:37:47 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/spring/</guid>
      <description>Spring 容器原理  Ioc 容器的事实标准 Ioc (Inverse of Control控制反转) :只需要告诉容器对象的依赖关系，容器就会自动完成依赖和Beans的生成，通过依赖注入完成依赖，整个过程就是控制反转 Java对象是Bean 当A对象必须使用B对象才能完成自己的工作的时候，就是A依赖B  Spring 注解  @RestController （Spring4.0）   继承 @Controller，在SpringMvc当中使用@Controller来标识当前类是一个控制器Servlet。     包含@Target(value=TYPE) @Retention(value=RUNTIME)、@Documented 、@Controller 、@ResponseBody   @RequestMapping，提供路由信息，告诉Spring 任何来自”/“路径的HTTP请求都会被映射到home 方法，@RestController注解告诉Spring 以字符串的形式渲染结果，并直接返回给调用者。    两者都是SpringMvc 的注解，不是SpringBoot特定部分    @EnableAutoConfiguration   告诉SpringBoot 根据添加的Jar 依赖猜测配置Spring。 而Spring-boot-start-web添加了Tomcat 和SpringMvc ，所以auto-configutation 会嘉定你正在开发一个web应用并对Spring 进行设置。     如果有不想自动配置的类可以通过 来禁止使用      @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})    @Configuration   @Configuration注解该类，等价 与XML中配置beans；用@Bean标注方法等价于XML中配置bean   @SpringBootApplication == @Configuration ， @EnableAutoConfiguration 和 @ComponentScan   能够自动在Application 中完成配置   @ResponseBody   表示该方法的返回结果直接写入HTTP response body中     一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上 @responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如 异步获取json数据，加上@responsebody后，会直接返回json数据。   @Resposotory诗句持久层DAO @Component   泛指组件，当组件不好归类的时候，可以使用这个注解进行标注。一般公共的方法会用上这个注解。非Controller、Service、DAO部分的注解   @Service   一般用于修饰service层的组件   @ComponentScan   表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。   @AutoWired   byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构 造函数进行标注，完成自动装配的工作。     当加上（required=false）时，就算找不到bean也不报错。   @RequestParam   用在方法的参数前面。   @PathVariable   路径变量。   @ControllerAdvice   包含@Component。可以被扫描到。     统一处理异常。   @ExceptionHandler（Exception.</description>
    </item>
    
    <item>
      <title>Mybatis</title>
      <link>https://procarihana.github.io/public/notes/mybatis/</link>
      <pubDate>Tue, 01 Sep 2020 10:57:12 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/mybatis/</guid>
      <description>Environment DataSource   dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。
  大多数 MyBatis 应用程序会按示例中的例子来配置数据源。虽然数据源配置是可选的，但如果要启用延迟加载特性，就必须配置数据源。 有三种内建的数据源类型（也就是 type=&amp;rdquo;[UNPOOLED|POOLED|JNDI]&amp;quot;）：
   UNPOOLED– 这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢，但对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择。 性能表现则依赖于使用的数据库，对某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性：      driver – 这是 JDBC 驱动的 Java 类全限定名（并不是 JDBC 驱动中可能包含的数据源类）。 url – 这是数据库的 JDBC URL 地址。 username – 登录数据库的用户名。 password – 登录数据库的密码。 defaultTransactionIsolationLevel – 默认的连接事务隔离级别。 defaultNetworkTimeout – 等待数据库操作完成的默认网络超时时间（单位：毫秒）。查看 java.sql.Connection#setNetworkTimeout() 的 API 文档以获取更多信息。 作为可选项，你也可以传递属性给数据库驱动。只需在属性名加上“driver.”前缀即可，例如：driver.encoding=UTF8这将通过 DriverManager.getConnection(url, driverProperties) 方法传递值为 UTF8 的 encoding 属性给数据库驱动。      POOLED– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求。    除了上述提到 UNPOOLED 下的属性外，还有更多属性用来配置 POOLED 的数据源：</description>
    </item>
    
    <item>
      <title>Bean</title>
      <link>https://procarihana.github.io/public/notes/bean/</link>
      <pubDate>Tue, 01 Sep 2020 10:04:08 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/bean/</guid>
      <description>Bean生成   一个对象生成Bean只能用一个方法配置，不能每个方法都对同一个对象生成bean
  class从java下一个文件夹开始~
class=java.com.service.OrderService&amp;ndash;&amp;gt;class=com.service.OrderService
  Bean 配置
   xml（旧的）   新建一个src/main/resources/applicationContext.xml 复制  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot; xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt; &amp;lt;!-- &amp;lt;context:component-scan base-package=&amp;quot;com.in28minutes.spring.basics&amp;quot;/&amp;gt; --&amp;gt; &amp;lt;bean id=&amp;quot;xmlStringBean1&amp;quot; class=&amp;quot;java.lang.String&amp;quot;&amp;gt; &amp;lt;constructor-arg value=&amp;quot;stringBean1&amp;quot; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;quot;xmlStringBean2&amp;quot; class=&amp;quot;java.lang.String&amp;quot;&amp;gt; &amp;lt;constructor-arg value=&amp;quot;stringBean2&amp;quot; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/beans&amp;gt;  修改bean id 和所在的class,不需要参数可以删掉 添加一个配置类(Eg:XmlConfiguration.class)，Bean会被加载。最好是放在一个包里面方便管理  @Configuration @ImportResource({&amp;#34;classpath*:applicationContext.xml&amp;#34;}) public class XmlConfiguration { } @ammunition   新建一个配置类(Eg:JavaConfiguration.class)  package com.</description>
    </item>
    
    <item>
      <title>Try/catch</title>
      <link>https://procarihana.github.io/public/notes/catch/</link>
      <pubDate>Tue, 01 Sep 2020 07:07:27 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/notes/catch/</guid>
      <description>Try/catch    try { int i = 10 / 0; } finally { System.out.println(&amp;#34;last&amp;#34;); }  能够成功执行，并且会返回last，同时也会返回Exeception 提示：: / by zero  finally 不一定都会被执行   try里面包含System.exit() finally 里包含异常就会抛出异常并终止执行  try { System.out.println(&amp;#34;try&amp;#34;); } catch (Exception e) { System.out.println(&amp;#34;catch&amp;#34;); } finally { int k = 3 / 0; System.out.println(&amp;#34;finally&amp;#34;); } System.out.println(&amp;#34;main&amp;#34;); </description>
    </item>
    
  </channel>
</rss>