<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="Hana ">
<meta name="description" content="函数式编程 1、减少工作量 2、提高效率 3、减少Bug
 Java8的新引入，包含函数式的设计，接口都有@FunctionalInterface的注解。注解在接口层面，且注解的接口要有且仅有一个抽象方法。&amp;ndash;&amp;gt;
 Lambada 表达式 Lambda允许把函数作为一个方法的参数（函数）作为参数传递进方法中
 Filter Pradicate 判断，用来判断一个东西是否满足条件    （user -&amp;gt; user.id%2==0）// 方法列表-&amp;gt;方法体，如果方法体太多要加括号，但一般精简. 满足 方法列表能够映射成布尔值，就能够转化成函数接口 方法应用有名字能够解释方法的用处，函数接口简单，但是没有任何注释；    满足类名::静态方法名字，且方法为布尔函数的时候，可以使用::     接口 输入 -&amp;gt; 输出  接口 输入 -&amp;gt; 输出     Supplier &amp;lt;Object&amp;gt; 虚无 -&amp;gt; Object  Function&amp;lt;User,String&amp;gt; User -&amp;gt; String   Lambad() -&amp;gt; new Object() void -&amp;gt; Object  Lambda user -&amp;gt; user.getName() User -&amp;gt; String   static Object create() void -&amp;gt; Object  static String getName(User user) User -&amp;gt; String   Object :: new void -&amp;gt; Object  User::getName User -&amp;gt; String      任何只包含一个抽象方法的接口都可以被自动转换为函数接口 抽象类：没有方法体    Supplier :从虚空里获得一个对象 &amp;ndash;&amp;gt; void -&amp;gt; OBject new 也同样是从虚空获得一个对象  public static void main (String [] agrs){ create(() -&amp;gt; new Object()); create(() -&amp;gt; &amp;#34;&amp;#34;); create(() -&amp;gt; new User(1,&amp;#34;A&amp;#34;)); create(Object :: new); } private static Object create(Supplier&amp;lt;Object&amp;gt; supplier){ return supplier." />
<meta name="keywords" content=", Lambda, " />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://procarihana.github.io/public/posts/java-8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" />


    <title>
        
            Java 8 函数式编程 :: FAFA Blog  — Just for fun
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="https://procarihana.github.io/public/main.d1ea4af8fd04fb24a4f8b882ea54bd04eb245427ca4baf527c81a5dab071410b.css">






<meta itemprop="name" content="Java 8 函数式编程">
<meta itemprop="description" content="函数式编程 1、减少工作量 2、提高效率 3、减少Bug
 Java8的新引入，包含函数式的设计，接口都有@FunctionalInterface的注解。注解在接口层面，且注解的接口要有且仅有一个抽象方法。&ndash;&gt;
 Lambada 表达式 Lambda允许把函数作为一个方法的参数（函数）作为参数传递进方法中
 Filter Pradicate 判断，用来判断一个东西是否满足条件    （user -&gt; user.id%2==0）// 方法列表-&gt;方法体，如果方法体太多要加括号，但一般精简. 满足 方法列表能够映射成布尔值，就能够转化成函数接口 方法应用有名字能够解释方法的用处，函数接口简单，但是没有任何注释；    满足类名::静态方法名字，且方法为布尔函数的时候，可以使用::     接口 输入 -&gt; 输出  接口 输入 -&gt; 输出     Supplier &lt;Object&gt; 虚无 -&gt; Object  Function&lt;User,String&gt; User -&gt; String   Lambad() -&gt; new Object() void -&gt; Object  Lambda user -&gt; user.getName() User -&gt; String   static Object create() void -&gt; Object  static String getName(User user) User -&gt; String   Object :: new void -&gt; Object  User::getName User -&gt; String      任何只包含一个抽象方法的接口都可以被自动转换为函数接口 抽象类：没有方法体    Supplier :从虚空里获得一个对象 &ndash;&gt; void -&gt; OBject new 也同样是从虚空获得一个对象  public static void main (String [] agrs){ create(() -&gt; new Object()); create(() -&gt; &#34;&#34;); create(() -&gt; new User(1,&#34;A&#34;)); create(Object :: new); } private static Object create(Supplier&lt;Object&gt; supplier){ return supplier.">
<meta itemprop="datePublished" content="2020-09-28T16:28:56&#43;08:00" />
<meta itemprop="dateModified" content="2020-09-28T16:28:56&#43;08:00" />
<meta itemprop="wordCount" content="194">
<meta itemprop="image" content="https://procarihana.github.io/public/"/>



<meta itemprop="keywords" content="Lambda,," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://procarihana.github.io/public/"/>

<meta name="twitter:title" content="Java 8 函数式编程"/>
<meta name="twitter:description" content="函数式编程 1、减少工作量 2、提高效率 3、减少Bug
 Java8的新引入，包含函数式的设计，接口都有@FunctionalInterface的注解。注解在接口层面，且注解的接口要有且仅有一个抽象方法。&ndash;&gt;
 Lambada 表达式 Lambda允许把函数作为一个方法的参数（函数）作为参数传递进方法中
 Filter Pradicate 判断，用来判断一个东西是否满足条件    （user -&gt; user.id%2==0）// 方法列表-&gt;方法体，如果方法体太多要加括号，但一般精简. 满足 方法列表能够映射成布尔值，就能够转化成函数接口 方法应用有名字能够解释方法的用处，函数接口简单，但是没有任何注释；    满足类名::静态方法名字，且方法为布尔函数的时候，可以使用::     接口 输入 -&gt; 输出  接口 输入 -&gt; 输出     Supplier &lt;Object&gt; 虚无 -&gt; Object  Function&lt;User,String&gt; User -&gt; String   Lambad() -&gt; new Object() void -&gt; Object  Lambda user -&gt; user.getName() User -&gt; String   static Object create() void -&gt; Object  static String getName(User user) User -&gt; String   Object :: new void -&gt; Object  User::getName User -&gt; String      任何只包含一个抽象方法的接口都可以被自动转换为函数接口 抽象类：没有方法体    Supplier :从虚空里获得一个对象 &ndash;&gt; void -&gt; OBject new 也同样是从虚空获得一个对象  public static void main (String [] agrs){ create(() -&gt; new Object()); create(() -&gt; &#34;&#34;); create(() -&gt; new User(1,&#34;A&#34;)); create(Object :: new); } private static Object create(Supplier&lt;Object&gt; supplier){ return supplier."/>







    <meta property="article:published_time" content="2020-09-28 16:28:56 &#43;0800 CST" />








    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://procarihana.github.io/public/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">知っているでしょう。</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://procarihana.github.io/public/posts">CNotes</a></li><li><a href="https://procarihana.github.io/public/tags">Tags</a></li><li><a href="https://procarihana.github.io/public/notes">PNotes</a></li><li><a href="https://procarihana.github.io/public/projects">Projects</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        One minute

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="https://procarihana.github.io/public/posts/java-8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">Java 8 函数式编程</a>
      </h1>

      

      <div class="post-content">
        <p>函数式编程
1、减少工作量
2、提高效率
3、减少Bug</p>
<hr>
<p><code>Java8的新引入，包含函数式的设计，接口都有@FunctionalInterface的注解。</code>注解在接口层面，且注解的接口要有且仅有一个抽象方法。&ndash;&gt;</p>
<hr>
<h2 id="lambada-表达式">Lambada 表达式</h2>
<p><strong>Lambda允许把函数作为一个方法的参数（函数）作为参数传递进方法中</strong></p>
<ul>
<li>Filter</li>
<li>Pradicate 判断，用来判断一个东西是否满足条件</li>
</ul>
<blockquote>
<ul>
<li>（user -&gt; user.id%2==0）// 方法列表-&gt;方法体，如果方法体太多要加括号，但一般精简.</li>
<li>满足 方法列表能够映射成布尔值，就能够转化成函数接口</li>
<li>方法应用有名字能够解释方法的用处，函数接口简单，但是没有任何注释；</li>
</ul>
</blockquote>
<ul>
<li>满足类名<code>::</code>静态方法名字，且方法为布尔函数的时候，可以使用<code>::</code></li>
</ul>
<table>
<thead>
<tr>
<th>接口</th>
<th>输入 -&gt; 输出</th>
<th></th>
<th>接口</th>
<th>输入 -&gt; 输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>Supplier <code>&lt;Object&gt;</code></td>
<td>虚无 -&gt; Object</td>
<td></td>
<td>Function<code>&lt;User,String&gt;</code></td>
<td>User -&gt; String</td>
</tr>
<tr>
<td>Lambad<code>() -&gt; new Object()</code></td>
<td>void -&gt; Object</td>
<td></td>
<td>Lambda <code>user -&gt; user.getName()</code></td>
<td>User -&gt; String</td>
</tr>
<tr>
<td>static Object create()</td>
<td>void -&gt; Object</td>
<td></td>
<td>static String getName(User user)</td>
<td>User -&gt; String</td>
</tr>
<tr>
<td>Object :: new</td>
<td>void -&gt; Object</td>
<td></td>
<td>User::getName</td>
<td>User -&gt; String</td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li>任何只包含一个抽象方法的接口都可以被自动转换为函数接口</li>
<li>抽象类：没有方法体</li>
</ul>
<hr>
<ul>
<li>Supplier :从虚空里获得一个对象 &ndash;&gt; void -&gt; OBject</li>
<li>new 也同样是从虚空获得一个对象</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span> <span style="color:#f92672">(</span>String <span style="color:#f92672">[]</span> agrs<span style="color:#f92672">){</span>
    create<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">());</span>
    create<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>
    create<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">new</span> User<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span><span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">));</span>
    create<span style="color:#f92672">(</span>Object <span style="color:#f92672">::</span> <span style="color:#66d9ef">new</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Object <span style="color:#a6e22e">create</span><span style="color:#f92672">(</span>Supplier<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> supplier<span style="color:#f92672">){</span>
    <span style="color:#66d9ef">return</span> supplier<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>BiConsumer</li>
<li>
<ul>
<li>有两个映射相加后变成一个新的映射，类似于a+b=c</li>
</ul>
</li>
<li>
<ul>
<li>接口接收两个泛型参数，跟Consumer一样，都有一个 accept方法，只不过，这里的，接收两个泛型参数，对这两个参数做下消费处理；使用这个函数式接口的终端操作有map的遍历</li>
</ul>
</li>
<li>
<ul>
<li>BiConsumer函数接口还有一个默认函数，andThen，接收一个BiConsumer接口，先执行本接口的，再执行传入的参数。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">
<span style="color:#a6e22e">@FunctionalInterface</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">BiConsumer</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">,</span> U<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
 
    
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">accept</span><span style="color:#f92672">(</span>T t<span style="color:#f92672">,</span> U u<span style="color:#f92672">);</span>
 
	<span style="color:#75715e">/**本接口中的accept先执行，传入的BiConsumer 接口类型的参数，后执行accept*/</span>
    <span style="color:#66d9ef">default</span> BiConsumer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">,</span> U<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">andThen</span><span style="color:#f92672">(</span>BiConsumer<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> T<span style="color:#f92672">,</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">super</span> U<span style="color:#f92672">&gt;</span> after<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">requireNonNull</span><span style="color:#f92672">(</span>after<span style="color:#f92672">);</span>
 
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>l<span style="color:#f92672">,</span> r<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
            accept<span style="color:#f92672">(</span>l<span style="color:#f92672">,</span> r<span style="color:#f92672">);</span>
            after<span style="color:#f92672">.</span><span style="color:#a6e22e">accept</span><span style="color:#f92672">(</span>l<span style="color:#f92672">,</span> r<span style="color:#f92672">);</span>
        <span style="color:#f92672">};</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<ul>
<li>HashMap</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>Map接口的终端操作，forEach的参数就是BiConsumer函数接口，对HashMap 的数据进行消费；</li>
</ul>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Map<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span> Integer<span style="color:#f92672">&gt;</span> map <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;();</span>
        map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 1<span style="color:#f92672">);</span>
        map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>2<span style="color:#f92672">,</span> 2<span style="color:#f92672">);</span>
        map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>3<span style="color:#f92672">,</span> 3<span style="color:#f92672">);</span>
        map<span style="color:#f92672">.</span><span style="color:#a6e22e">forEach</span><span style="color:#f92672">((</span>k<span style="color:#f92672">,</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>k<span style="color:#f92672">);</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
        <span style="color:#f92672">});</span>
    <span style="color:#f92672">}</span>
</code></pre></div><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>BiConsumer&lt;T,U&gt;</td>
<td>一个接受两个输入参数的操作，并且不返回任何记过</td>
</tr>
<tr>
<td>BiFunction&lt;T,U,R&gt;</td>
<td>一个接受两个输入参数的方法，并且返回一个结果</td>
</tr>
<tr>
<td>Consumer<code>&lt;T&gt;</code></td>
<td>接受一个参数并且无返回操作</td>
</tr>
<tr>
<td>Predicate<code>&lt;T&gt;</code></td>
<td>接受一个输入值，返回一个布尔值结果</td>
</tr>
<tr>
<td>Supplier<code>&lt;T&gt;</code></td>
<td>无参数，返回一个结果</td>
</tr>
</tbody>
</table>

      </div>
    </article>

    <hr />

    <div class="post-info">
        <p>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon">
            <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
            <line x1="7" y1="7" x2="7" y2="7"></line>
          </svg><span class="tag"><a href="https://procarihana.github.io/public/tags/lambda/">Lambda</a></span><span class="tag"><a href="https://procarihana.github.io/public/tags//"></a></span>
        </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        194 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        2020-09-28 16:28 &#43;0800
      </p>
    </div>

    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>

        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="https://procarihana.github.io/public/posts/java-%E6%B3%9B%E5%9E%8B/">
                <span class="button__icon">←</span>
                <span class="button__text">Java 泛型</span>
              </a>
            </span>
          

          
            <span class="button next">
              <a href="https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/">
                <span class="button__text">Java面向对象  接口和抽象类</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    


    

  </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2020</span>
            
                <span><a href="https://procarihana.github.io/public/">Hana</a></span>
            
            
                <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span>
            
            <span> <a href="https://procarihana.github.io/public/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">Djordje Atlialp</a></span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="https://procarihana.github.io/public/bundle.min.dc716e9092c9820b77f96da294d0120aeeb189b5bcea9752309ebea27fd53bbe6b13cffb2aca8ecf32525647ceb7001f76091de4199ac5a3caa432c070247f5b.js" integrity="sha512-3HFukJLJggt3&#43;W2ilNASCu6xibW86pdSMJ6&#43;on/VO75rE8/7KsqOzzJSVkfOtwAfdgkd5BmaxaPKpDLAcCR/Ww=="></script>



    </body>
</html>
