<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on FAFA Blog</title>
        <link>https://procarihana.github.io/public/posts/</link>
        <description>Recent content in Posts on FAFA Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-Hans</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Tue, 22 Sep 2020 10:20:53 +0800</lastBuildDate>
        <atom:link href="https://procarihana.github.io/public/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>多线程</title>
            <link>https://procarihana.github.io/public/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
            <pubDate>Tue, 22 Sep 2020 10:20:53 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
            <description></description>
            <content type="html"><![CDATA[]]></content>
        </item>
        
        <item>
            <title>操作系统与计算机原理</title>
            <link>https://procarihana.github.io/public/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/</link>
            <pubDate>Mon, 21 Sep 2020 23:40:37 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/</guid>
            <description>计算机体系原理 核心 ：CPU 中央处理器 包含控制器和运算器    寄存器 ：临时存放 register 是CPU的内置，容量小，但是速度极快的内存     内存 ：包含数据和指令（说明书）冯诺依曼结构&amp;ndash;&amp;gt; 将程序指令和数据存储一起的结构     汇编指令    程序的装载和执行  可执行程序 exe、executable： 执行指令和数据的共同体   一个exe 可以执行多个进程 &amp;ndash;&amp;gt; 装载到内存不同的进程里，两个进程是不相同的      物理寻址 通过指令完成 物理地址：真是的内存地址 虚拟地址空间：对于每一个进程而言，操作系统随机分配给进程的内存空间   每个程序是独立的，程序间数据不共享，程序不会窃取别的程序，互不干扰，一个崩溃另一个也不会出事   跨平台性   不同架构的CUP执行指令是不一样的，所以不同平台的CPU不能执行其他CUP的指令     而模拟器能够实现      动态链接库 静态链接库    CPU 在执行指令的时候，有的方法是存在另外的地方，需要用的时候就去加载。能够节省空间，共用方法，升级的时候也比较简单。但是如果不存在的话就会出现错误，也有可能出现和系统不兼容的问题    《链接、装载与库》  程序的分时复用调度  CPU 速度 &amp;raquo; memory &amp;raquo; IO 操作系统根据实际采用调度 时间片轮转：不停地轮流做不同的事情，基于CUP运行速度快 每个程序轮流占用CPU的时间片（进程、线程）   什么时候放弃占用CUP时间片      程序时间片到时间 请求慢速设备（把数据储存到磁盘） CPU需要响应中断（磁盘处理完后向CPU发出中断，CPU 就马上去完成中断后的工作）     上下文切换</description>
            <content type="html"><![CDATA[<h2 id="计算机体系原理">计算机体系原理</h2>
<h4 id="核心-cpu-中央处理器-包含控制器和运算器">核心 ：CPU 中央处理器 包含控制器和运算器</h4>
<ul>
<li>
<ul>
<li>寄存器 ：临时存放 register 是CPU的内置，容量小，但是速度极快的内存</li>
</ul>
</li>
<li>
<ul>
<li>内存 ：包含数据和指令（说明书）冯诺依曼结构&ndash;&gt; 将程序指令和数据存储一起的结构</li>
</ul>
</li>
<li>
<ul>
<li>汇编指令</li>
</ul>
</li>
</ul>
<h4 id="程序的装载和执行">程序的装载和执行</h4>
<ul>
<li>可执行程序 exe、executable： 执行指令和数据的共同体</li>
<li>
<ul>
<li>一个exe 可以执行多个进程 &ndash;&gt; 装载到内存不同的进程里，两个进程是不相同的</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>物理寻址 通过指令完成</li>
<li>物理地址：真是的内存地址</li>
<li>虚拟地址空间：对于每一个进程而言，操作系统随机分配给进程的内存空间</li>
<li>
<ul>
<li>每个程序是独立的，程序间数据不共享，程序不会窃取别的程序，互不干扰，一个崩溃另一个也不会出事</li>
</ul>
</li>
<li>跨平台性</li>
<li>
<ul>
<li>不同架构的CUP执行指令是不一样的，所以不同平台的CPU不能执行其他CUP的指令</li>
</ul>
</li>
<li>
<ul>
<li>而模拟器能够实现</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>动态链接库 静态链接库</li>
</ul>
<blockquote>
<ul>
<li>CPU 在执行指令的时候，有的方法是存在另外的地方，需要用的时候就去加载。能够节省空间，共用方法，升级的时候也比较简单。但是如果不存在的话就会出现错误，也有可能出现和系统不兼容的问题</li>
</ul>
</blockquote>
<ul>
<li>《链接、装载与库》</li>
</ul>
<h4 id="程序的分时复用调度">程序的分时复用调度</h4>
<ul>
<li>CPU 速度 &raquo; memory &raquo; IO</li>
<li>操作系统根据实际采用调度</li>
<li>时间片轮转：不停地轮流做不同的事情，基于CUP运行速度快</li>
<li>每个程序轮流占用CPU的时间片（进程、线程）</li>
<li>
<ul>
<li>什么时候放弃占用CUP时间片</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>程序时间片到时间</li>
<li>请求慢速设备（把数据储存到磁盘）</li>
<li>CPU需要响应中断（磁盘处理完后向CPU发出中断，CPU 就马上去完成中断后的工作）</li>
</ul>
</blockquote>
<ul>
<li>
<p>上下文切换</p>
</li>
<li>
<p>上下文context：程序的环境（寄存器、PC），CPU在运行任何任务前，必须的依赖环境</p>
</li>
<li>
<ul>
<li>CP 程序计算器“用来存储CPU正在执行的指令位置，或者即将执行的吓一跳指令位置</li>
</ul>
</li>
<li>
<ul>
<li>就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</li>
</ul>
</li>
<li>
<ul>
<li>放弃CPU时，保存上下文</li>
</ul>
</li>
<li>
<ul>
<li>拥有CPU时，恢复上下文</li>
</ul>
</li>
<li>
<p>协程 用户态线程，内存小，但是要自己写调度算法。是编译层概念，在操作系统上Linxu 并没有线层的概念</p>
</li>
</ul>
<h2 id="操作系统">操作系统</h2>
<ul>
<li>欺上瞒下</li>
<li>
<ul>
<li>对上层提供统一的API，简化应用开发逻辑</li>
</ul>
</li>
<li>
<ul>
<li>对下层通过硬件驱动提供兼容性</li>
</ul>
</li>
<li>例如：</li>
<li>
<ul>
<li>通过windows的CreateProcessA方法创建新的进程</li>
</ul>
</li>
<li>
<ul>
<li>通过Unix的fork系统调用创建新的进程 &ndash;&gt;posix （Linux、Macos）可移植的操作标准（unix、*nix） 和 windows系统不一样</li>
</ul>
</li>
<li>
<ul>
<li>通过不同的抽象（中间件）来完成不同的地方进行兼容实现同一方便。但是效率低，因为不同的部件要完成这些抽象传来的指令就需要有属于自己程序运行</li>
</ul>
</li>
<li>驱动：负责操作系统的指令传递到硬件</li>
<li>JVM ：不同的指令在不同的系统内兼容</li>
</ul>
<h2 id="进程与线程">进程与线程</h2>
<ul>
<li>进程是资源分配的最小单位，线程是CPU调度的最小单位</li>
<li>共同点</li>
<li>
<ul>
<li>都拥有独立的PC，可以独立地执行程序</li>
</ul>
</li>
<li>
<ul>
<li>在Linxu上甚至用同一种数据结构处理进程和线程</li>
</ul>
</li>
<li>进程：拥有独立的内存空间、文件等资源</li>
<li>线程：处于进程内部，所以每个线程可以独立地运行。和其他的线程共享内存地址空间。文件等资源</li>
<li>Linux 线程是轻量级进程，线程和进程都是任务，两者刚好运用同一个地址内存空间</li>
</ul>
<h2 id="文件iofilesystem硬盘">文件IO、FileSystem（硬盘）</h2>
<ul>
<li>文件的本质是字节流</li>
<li>文件与文件指针</li>
<li>
<ul>
<li>文件指针不断地移动从文件流里读取数据块</li>
</ul>
</li>
<li>缓冲区 buffer 硬盘数据读取和cpu 没有关系，读取一块信息后给CPU进行操作</li>
</ul>
<h2 id="源代码到ast抽象语法树编译器前端">源代码到AST(抽象语法树)编译器前端</h2>
<ul>
<li>源代码 -&gt; tokens</li>
<li>
<ul>
<li>解析成一个个的关键字</li>
</ul>
</li>
<li>tokens -&gt; AST</li>
<li>
<ul>
<li>通过语法规则生成语法数</li>
</ul>
</li>
</ul>
<h2 id="从ast到目标代码编译器后端">从AST到目标代码（编译器后端）</h2>
<ul>
<li>AST -&gt; 字节码</li>
<li>AST -&gt;  平台相关到的目标代码</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>工厂方法</title>
            <link>https://procarihana.github.io/public/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</link>
            <pubDate>Mon, 21 Sep 2020 18:23:42 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</guid>
            <description>对象创建模式  避免用new创建过程中需要依赖具体类，从而支持对象创建的稳定 避免紧耦合，对拓展是开放的，对修改是封闭的 典型： Factory Method Absttact Factory Builder Prototype（原型）   Clone   Singleton  简单工厂模式 例  处理从文件里面读出的数据 设计：DataManager类，FileReader类   从不同的去到读取数据，一开始需要每渠道都写一种实现 processDataFromRest 、processDataFromDatabase 等等的方法，而这些方法都要需要相应的dataReader对象去实现。 为了减少  </description>
            <content type="html"><![CDATA[<h2 id="对象创建模式">对象创建模式</h2>
<ul>
<li>避免用new创建过程中需要依赖具体类，从而支持对象创建的稳定</li>
<li>避免紧耦合，对拓展是开放的，对修改是封闭的</li>
<li>典型：</li>
<li>Factory Method</li>
<li>Absttact Factory</li>
<li>Builder</li>
<li>Prototype（原型）</li>
<li>
<ul>
<li>Clone</li>
</ul>
</li>
<li>Singleton</li>
</ul>
<h2 id="简单工厂模式">简单工厂模式</h2>
<h4 id="例">例</h4>
<ul>
<li>处理从文件里面读出的数据</li>
<li>设计：DataManager类，FileReader类</li>
</ul>
<ol>
<li>从不同的去到读取数据，一开始需要每渠道都写一种实现 processDataFromRest 、processDataFromDatabase 等等的方法，而这些方法都要需要相应的dataReader对象去实现。</li>
<li>为了减少</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>SOLID原则</title>
            <link>https://procarihana.github.io/public/posts/solid%E5%8E%9F%E5%88%99/</link>
            <pubDate>Sun, 20 Sep 2020 15:53:38 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/solid%E5%8E%9F%E5%88%99/</guid>
            <description>面向对象设计基本原则：SOLID原则 单一责任原则  定义：一个类只应承担一种责任 让一个类只做一件事。如果需要承担更多的工作，那么分解这个类  开放封闭原则  定义：实体应该对扩展是开放的，对修改是封闭的 类应该无需改类本身但是却容易扩展 例子： 继承 可以通过继承来扩展，但是不能够修改父类  里氏替换原则  定义：一个 对象在其出现的任何地方，都可以用子类实例做替换 当一个子类可以在任意地方替换基类，且短剑功能不受影响时，不会导致程序的错误 Eg： 多个数据源（SQL与NoSQL）获取用户信息  接口分离原则  定义：多个专门接口比单一的总体接口要好 客户不应被强迫依赖他是不用的方法。即，一个类实现的接口中，包含了他不需要的方法。将接口拆分成更小和更具体的接口，有助于解耦，从而更容易重构与更改  依赖倒置原则  定义：   高层次的模块不应该依赖低层次的模块，他们都应该依赖于抽象。     抽象不应该依赖于具体方法实现，具体实现应该依赖抽象   依赖倒置是实现开闭原则的方法 扩展 IOC DI?  </description>
            <content type="html"><![CDATA[<h1 id="面向对象设计基本原则solid原则">面向对象设计基本原则：SOLID原则</h1>
<h2 id="单一责任原则">单一责任原则</h2>
<ul>
<li>定义：一个类只应承担一种责任</li>
<li>让一个类只做一件事。如果需要承担更多的工作，那么分解这个类</li>
</ul>
<h2 id="开放封闭原则">开放封闭原则</h2>
<ul>
<li>定义：实体应该对扩展是开放的，对修改是封闭的</li>
<li>类应该无需改类本身但是却容易扩展</li>
<li>例子： 继承 可以通过继承来扩展，但是不能够修改父类</li>
</ul>
<h2 id="里氏替换原则">里氏替换原则</h2>
<ul>
<li>定义：一个 对象在其出现的任何地方，都可以用子类实例做替换</li>
<li>当一个子类可以在任意地方替换基类，且短剑功能不受影响时，不会导致程序的错误</li>
<li>Eg： 多个数据源（SQL与NoSQL）获取用户信息</li>
</ul>
<h2 id="接口分离原则">接口分离原则</h2>
<ul>
<li>定义：多个专门接口比单一的总体接口要好</li>
<li>客户不应被强迫依赖他是不用的方法。即，一个类实现的接口中，包含了他不需要的方法。将接口拆分成更小和更具体的接口，有助于解耦，从而更容易重构与更改</li>
</ul>
<h2 id="依赖倒置原则">依赖倒置原则</h2>
<ul>
<li>定义：</li>
<li>
<ul>
<li>高层次的模块不应该依赖低层次的模块，他们都应该依赖于抽象。</li>
</ul>
</li>
<li>
<ul>
<li>抽象不应该依赖于具体方法实现，具体实现应该依赖抽象</li>
</ul>
</li>
<li>依赖倒置是实现开闭原则的方法</li>
<li>扩展 IOC DI?</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>单例模式</title>
            <link>https://procarihana.github.io/public/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
            <pubDate>Wed, 16 Sep 2020 18:13:34 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
            <description>保证一个类只有一个实例，并提供一个访问它的全局访问点   常见的单例模式   Hibernate、Mybatis SessionFactory Spring Bean 每个Bean 都是单例的（依赖倒置原则） Java Runtime  动机  在软件工程里经常有一些特殊类，必须保证他们在系统里有且只有一个实例 绕开 new，提供一种方式来确保一个类只有一个实例 需要由类设计者来考虑实现，而不是类使用者来保证  优势  提供了对唯一实例的受控访问 对频繁使用的对象，可以省略创建对象所花费的时间，对于那些重量级对象而言，是非常可观的一笔系统开销 对于Java语言，额外的好处：由于new操作的次数减少，因而对系统内存的使用频率也会降低。这将减轻GC压力，缩短GC停顿时间  使用场景  当只能有一个实例而且客户可以从一个众所周知的访问点访问 当这个唯一实例应该是通过子类化可拓展，并且客户应该无须更改代码就能使用一个拓展的实例  结构  Singgleton ： 定义一个Instacne操作，允许客户访问的唯一实例  单例模式七种方式 饿汉式 静态常量    当构造器是public的时候，这个类都能通过new()实现新的实例 &amp;ndash;&amp;gt; 构造器使用private     为了让外面能够使用到这个类，直接在创建的时候new出来    public class Singleton{ public static final Singleton INSTANCE = new Singleton(); //private constructor  private Singleton(){} public void doSomething(){……} }   改进模式：使用一个静态工厂，通过调用这个类的方法从而能够使用到这个实例   public class Singleton{ public static final Singleton INSTANCE = new Singleton(); //private constructor  private Singleton(){} public static Singleton getInstance(){ return INSTANCE;} public void doSomething(){……} }  饿汉式 静态代码块  public class Singleton{ private Singleton(){} private static Singleton instance; static{ instance = new Singleton(); } public static Singleton getInstance(){ return instance; } } 懒汉式 线程不安全  只在第一次new(),其余时间通过判断是否为null，不是的话就直接返回，是的话就new一个新的 如果多个线程同时执行if(instance == null),一个线程来不及创建完，就被另一个线程访问，会创建出多个实例来   可以懒加载。但是线程不安全，只能在单线程使用   不能在实际环境中使用  public class Singleton{ private static Singleton instacne; private Singleton(){ public static Singleton getInstance(){ if(instance == null){ instance = new Singleton(); } return instance; } } } 懒汉式 线程安全 同步安全  加锁 能懒加载   加锁导致效率低（程序串行化），每个线程在获得实例时都要进行同步，哪怕已经是读的操作     加锁是有性能开销的     不推荐使用    双重检查 double-check  懒汉式不安全,主要是判断是否为空   双重检查就是通过加锁，获得锁后把判断实例是否为空，如果是的话就new出实例，不是的话就返回已经new出的实例     在new的过程中，因为锁已经被拿走了，所以不会有其他的线程new实例    public class Singleton{ private static Singleton instacne; private Singleton(){ public static Singleton getInstance(){ if(instance == null){ synchrondized(Singleton.</description>
            <content type="html"><![CDATA[<ul>
<li>保证一个类只有一个实例，并提供一个访问它的全局访问点</li>
<li>
<ul>
<li>常见的单例模式</li>
</ul>
</li>
<li>Hibernate、Mybatis SessionFactory</li>
<li>Spring Bean 每个Bean 都是单例的（依赖倒置原则）</li>
<li>Java Runtime</li>
</ul>
<h2 id="动机">动机</h2>
<ul>
<li>在软件工程里经常有一些特殊类，必须保证他们在系统里有且只有一个实例</li>
<li>绕开 new，提供一种方式来确保一个类只有一个实例</li>
<li>需要由类设计者来考虑实现，而不是类使用者来保证</li>
</ul>
<h2 id="优势">优势</h2>
<ul>
<li>提供了对唯一实例的受控访问</li>
<li>对频繁使用的对象，可以省略创建对象所花费的时间，对于那些重量级对象而言，是非常可观的一笔系统开销</li>
<li>对于Java语言，额外的好处：由于new操作的次数减少，因而对系统内存的使用频率也会降低。这将减轻GC压力，缩短GC停顿时间</li>
</ul>
<h2 id="使用场景">使用场景</h2>
<ul>
<li>当只能有一个实例而且客户可以从一个众所周知的访问点访问</li>
<li>当这个唯一实例应该是通过子类化可拓展，并且客户应该无须更改代码就能使用一个拓展的实例</li>
</ul>
<h2 id="结构">结构</h2>
<ul>
<li>Singgleton ： 定义一个Instacne操作，允许客户访问的唯一实例</li>
</ul>
<h2 id="单例模式七种方式">单例模式七种方式</h2>
<h4 id="饿汉式-静态常量">饿汉式 静态常量</h4>
<ul>
<li>
<ul>
<li>当构造器是public的时候，这个类都能通过new()实现新的实例 &ndash;&gt; 构造器使用private</li>
</ul>
</li>
<li>
<ul>
<li>为了让外面能够使用到这个类，直接在创建的时候new出来</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Singleton INSTANCE <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton<span style="color:#f92672">();</span>
    <span style="color:#75715e">//private constructor
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Singleton</span><span style="color:#f92672">(){}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doSomething</span><span style="color:#f92672">(){</span><span style="color:#960050;background-color:#1e0010">……</span><span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<ul>
<li>改进模式：使用一个静态工厂，通过调用这个类的方法从而能够使用到这个实例</li>
</ul>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Singleton INSTANCE <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton<span style="color:#f92672">();</span>
    <span style="color:#75715e">//private constructor
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Singleton</span><span style="color:#f92672">(){}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Singleton <span style="color:#a6e22e">getInstance</span><span style="color:#f92672">(){</span> <span style="color:#66d9ef">return</span> INSTANCE<span style="color:#f92672">;}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doSomething</span><span style="color:#f92672">(){</span><span style="color:#960050;background-color:#1e0010">……</span><span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>饿汉式 静态代码块</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Singleton</span><span style="color:#f92672">(){}</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Singleton instance<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">static</span><span style="color:#f92672">{</span>
        instance <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Singleton <span style="color:#a6e22e">getInstance</span><span style="color:#f92672">(){</span>
        <span style="color:#66d9ef">return</span> instance<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

<span style="color:#f92672">}</span>
</code></pre></div><h4 id="懒汉式-线程不安全">懒汉式 线程不安全</h4>
<ul>
<li>只在第一次new(),其余时间通过判断是否为null，不是的话就直接返回，是的话就new一个新的</li>
<li>如果多个线程同时执行if(instance == null),一个线程来不及创建完，就被另一个线程访问，会创建出多个实例来</li>
<li>
<ul>
<li>可以懒加载。但是线程不安全，只能在单线程使用</li>
</ul>
</li>
<li>不能在实际环境中使用</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Singleton instacne<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Singleton</span><span style="color:#f92672">(){</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Singleton <span style="color:#a6e22e">getInstance</span><span style="color:#f92672">(){</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>instance <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
                instance <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton<span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">return</span> instance<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="懒汉式-线程安全-同步安全">懒汉式 线程安全 同步安全</h4>
<ul>
<li>加锁</li>
<li>能懒加载</li>
<li>
<ul>
<li>加锁导致效率低（程序串行化），每个线程在获得实例时都要进行同步，哪怕已经是读的操作</li>
</ul>
</li>
<li>
<ul>
<li>加锁是有性能开销的</li>
</ul>
</li>
<li>
<ul>
<li>不推荐使用</li>
</ul>
</li>
</ul>
<h4 id="双重检查-double-check">双重检查 double-check</h4>
<ul>
<li>懒汉式不安全,主要是判断是否为空</li>
<li>
<ul>
<li>双重检查就是通过加锁，获得锁后把判断实例是否为空，如果是的话就new出实例，不是的话就返回已经new出的实例</li>
</ul>
</li>
<li>
<ul>
<li>在new的过程中，因为锁已经被拿走了，所以不会有其他的线程new实例</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Singleton instacne<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Singleton</span><span style="color:#f92672">(){</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Singleton <span style="color:#a6e22e">getInstance</span><span style="color:#f92672">(){</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>instance <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
                synchrondized<span style="color:#f92672">(</span>Singleton<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">){</span>
                    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>instance <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
                        instance <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton<span style="color:#f92672">();</span>
                    <span style="color:#f92672">}</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">return</span> instance<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="静态内部类推荐">静态内部类（推荐！）</h4>
<ul>
<li>静态内部了在Singleton类被装载时并不会立即实例化</li>
<li>类的静态属性只会在第一次在家类的时候初始化，保证了线程安全性</li>
<li>避免了线程不安全，利用静态内部类特点实现延迟加载</li>
</ul>
<blockquote>
<ul>
<li>静态常量 final ，确保不会被改变</li>
<li>在工厂方法里面直接返回new 出的实例对象</li>
<li>先new出对象，就不用考虑多线程的问题</li>
</ul>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Singleton</span><span style="color:#f92672">(){}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SingletonInstance</span><span style="color:#f92672">{</span>
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Singleton INSTANCE <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Singleton <span style="color:#a6e22e">getInstance</span><span style="color:#f92672">(){</span>
        <span style="color:#66d9ef">return</span> SingletonInstance<span style="color:#f92672">.</span><span style="color:#a6e22e">INSTANCE</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

<span style="color:#f92672">}</span>
</code></pre></div><h4 id="枚举">枚举</h4>
<ul>
<li>单元素的枚举类型</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> Singleton<span style="color:#f92672">{</span>
    INSTANCE<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doSomething</span><span style="color:#f92672">(){}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="饿汉式懒汉式">饿汉式、懒汉式</h4>
<ul>
<li>区别在于创建对象的时间</li>
<li>懒汉式 是等到整整使用的时候才会建立这个单例对象</li>
<li>饿汉式 是不管你用不用一开始都给创建上
是否是lazy loading</li>
</ul>
<h2 id="饿汉式总结">饿汉式总结</h2>
<blockquote>
<ul>
<li>构造器private，防止new</li>
<li>类的内部创建对象，对外暴露一个静态公共方法getInstacne</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>优点</li>
</ul>
</li>
</ul>
<ol>
<li>简单明了</li>
<li>依赖JVM类加载机制，保证单例只会被创建一次，即线程安全</li>
<li>在类装载时就完成了实例化，避免了线程同步问题</li>
</ol>
<ul>
<li>
<ul>
<li>缺点</li>
</ul>
</li>
</ul>
<ol>
<li>不能懒加载，有可能会造成内存浪费</li>
<li>可以在工程代码中使用</li>
</ol>
<h2 id="双重检查-double-check总结">双重检查 Double-Check总结</h2>
<ul>
<li>通过两次检查保证线程安全</li>
<li>问题：可能会导致空指针异常（重排序reorder）</li>
<li>
<ul>
<li>空排序：一个类里面的属性顺序可能被编译器作出调整，顺序不一样，导致一下属性获得Instance，一些没有</li>
</ul>
</li>
<li>
<ul>
<li>编译器</li>
</ul>
</li>
<li>实例化只执行一次</li>
<li>线程安全，延迟加载</li>
</ul>
<h4 id="双重检查改进">双重检查改进</h4>
<ul>
<li>在原来的基础上为构造器添加
<code>volatile</code>&ndash;&gt;<code>private static volatile Singleton instance;</code></li>
</ul>
<h2 id="volatile">volatile</h2>
<ul>
<li>保证可见性</li>
<li>
<ul>
<li>确保将变量的更新操作通知到其他线程</li>
</ul>
</li>
<li>
<ul>
<li>变量声明为volatile后，编译器与运行时会注意到这个变量是共享的</li>
</ul>
</li>
<li>
<ul>
<li>读到volatile类型的变量总会返回最新写入的值</li>
</ul>
</li>
<li>防止指令重新排序</li>
<li>
<ul>
<li>被volatile修饰的写变量不能和之前的读写代码调整</li>
</ul>
</li>
<li>
<ul>
<li>读变量不能和之后逇读写代码调整</li>
</ul>
</li>
<li>因此，只要我们简单的吧instance添加上volatile关键字就可以了</li>
</ul>
<h2 id="实例介绍">实例介绍</h2>
<ul>
<li>Runtime class</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Runtime</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Runtime currentRuntime <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Runtime<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Runtime <span style="color:#a6e22e">getRuntiem</span><span style="color:#f92672">(){</span>
        <span style="color:#66d9ef">return</span> currntRuntimel<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>题目</title>
            <link>https://procarihana.github.io/public/posts/%E9%A2%98%E7%9B%AE/</link>
            <pubDate>Tue, 08 Sep 2020 20:10:37 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/%E9%A2%98%E7%9B%AE/</guid>
            <description>基础 Java程序的运行原理  编译过程.java -编译器Compiler（编译）-&amp;gt; .class[字节码]   编译的结果存放在tarket、classes 里面   字节码通过JVM识别后解析成不同系统的调用，从而实现java 的跨平台   Object 里面有native()是一个空白的类,jvm里native实现能够让运行平台决定如何实现，    JDK/JRE 有什么区别  JDK = JRE + javac   JDK 完成java源代码到字节码的编译和运行过程，包含JRE   JRE 完成字节码到底层调用的解析和运行过程，如果只是运行java 程序，只安装JRE就可以了，不需要安装JDK。其中JVM就是完成java 实现跨平台的核心部分。  Java 的基础类型  char/string/short/byte/long/int/boolean/float   String 是基本数据类型？         Java 的参数传递是传值还是传引用  在Java里所有的对象都只是一个指针，传递的时候只是传递地址的拷贝，所以是传引用   一切对象都是指针（地址）     函数调用永远是传值。函数调用的过程中，把对象作为参数传递到函数里面的时候，传递的是一个复制的地址，地址里面包含对象的数据。这个传送复制的地址的过程就是传值。    引用数据类型(Reference data type)如一个对象(object)的传递，是以值的形式传进方法(are also passed into methods by value)。这意味着当函数执行完（when the method returns），传进去的引用（the passed-in reference）仍然参考(指向)之前的对象(still references the same object as before)。但是，对象的值(字段)可以在方法中被改变。</description>
            <content type="html"><![CDATA[<h2 id="基础">基础</h2>
<h4 id="java程序的运行原理">Java程序的运行原理</h4>
<ul>
<li>编译过程<code>.java</code> -编译器Compiler（编译）-&gt; <code>.class</code>[字节码]</li>
<li>
<ul>
<li>编译的结果存放在<code>tarket、classes</code> 里面</li>
</ul>
</li>
<li>字节码通过JVM识别后解析成不同系统的调用，从而实现java 的跨平台</li>
<li>
<ul>
<li>Object 里面有native()是一个空白的类,jvm里native实现能够让运行平台决定如何实现，</li>
</ul>
</li>
</ul>
<h4 id="jdkjre-有什么区别">JDK/JRE 有什么区别</h4>
<ul>
<li>JDK = JRE + javac</li>
<li>
<ul>
<li>JDK 完成java源代码到字节码的编译和运行过程，包含JRE</li>
</ul>
</li>
<li>JRE 完成字节码到底层调用的解析和运行过程，如果只是运行java 程序，只安装JRE就可以了，不需要安装JDK。其中JVM就是完成java 实现跨平台的核心部分。</li>
</ul>
<h4 id="java-的基础类型">Java 的基础类型</h4>
<ul>
<li>char/string/short/byte/long/int/boolean/float</li>
<li>
<ul>
<li>String 是基本数据类型？</li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
<h4 id="java-的参数传递是传值还是传引用">Java 的参数传递是传值还是传引用</h4>
<ul>
<li>在Java里所有的对象都只是一个指针，传递的时候只是传递地址的拷贝，所以是传引用</li>
<li>
<ul>
<li>一切对象都是指针（地址）</li>
</ul>
</li>
<li>
<ul>
<li>函数调用永远是传值。函数调用的过程中，把对象作为参数传递到函数里面的时候，传递的是一个复制的地址，地址里面包含对象的数据。这个传送复制的地址的过程就是传值。</li>
</ul>
</li>
</ul>
<p>引用数据类型(Reference data type)如一个对象(object)的传递，是以值的形式传进方法(are also passed into methods by value)。这意味着当函数执行完（when the method   returns），传进去的引用（the passed-in reference）仍然参考(指向)之前的对象(still references the same object as before)。但是，对象的值(字段)可以在方法中被改变。</p>
<h4 id="stringbuffer-和stringbuilder">StringBuffer 和StringBuilder</h4>
<ul>
<li>如果没有额外声明，所有的类默认都是线程不安全的</li>
<li>StringBuilder 更快，但是线程不安全，更加常用</li>
<li>StringBuffer稍慢，但是线程安全</li>
</ul>
<h3 id="object">Object</h3>
<ul>
<li>clone（）不常用</li>
</ul>
<h4 id="equal">equal</h4>
<ul>
<li>判断两个数据是否相同的时候用<code>==</code></li>
<li>判断两个对象是否相同的时候用<code>equal</code></li>
<li>
<ul>
<li>自反性：自己必须等于自己</li>
</ul>
</li>
<li>
<ul>
<li>对称性：a ==b ，b==a</li>
</ul>
</li>
<li>
<ul>
<li>传递性：a==b,b==c,a==c</li>
</ul>
</li>
<li>
<ul>
<li>持久性：多次调用都能保证结果一直</li>
</ul>
</li>
<li>
<ul>
<li>任何非空对象和null都要为false</li>
</ul>
</li>
<li>覆盖：例 如果是Object 是String 的话，就会覆盖成比较String的每个字符是否相等的方法，里面因为有循环，所以非常耗时</li>
<li>扩展:intern()能够解决这个问题</li>
<li>覆盖2 如果Object 是Integer 的话，就会比较两个数据是否相等</li>
</ul>
<h3 id="string">String</h3>
<ul>
<li>toString（） &ndash;&gt; [,,]</li>
<li>
<ul>
<li>List<!-- raw HTML omitted --> s = Arrays.toString(&ldquo;A,&ldquo;B&rdquo;,&ldquo;C&rdquo;);</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>如果直接print（s）的话，就会通过重载成Object，变成了object.toString() &ndash;&gt; print(s.toString)</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>如果一个String[]{&ldquo;A&rdquo;,&ldquo;B&rdquo;,&ldquo;C&rdquo;} 不适用 toString(),就会变成[L 类名；@Object地址</li>
</ul>
</li>
<li>compareTo 比较大小，被treemap 处理</li>
<li>charAt byte和String 的互换</li>
<li>getBytes</li>
<li>indexOf（String）：int 检查字符在第几个位置出现</li>
<li>isEmpty 是否为空字符串</li>
<li>length（）</li>
<li>split（）用字符切割 （正则表达）</li>
</ul>
<h2 id="面向对象">面向对象</h2>
<h4 id="equal-">equal ==</h4>
<h4 id="浅拷贝-和深拷贝">浅拷贝 和深拷贝</h4>
<ul>
<li>浅：只是把对象的地址拷贝</li>
<li>
<ul>
<li>深：把整个引用类都拷贝，包括类里面的变量、地址都拷贝</li>
</ul>
</li>
</ul>
<h4 id="接口和抽象的区别">接口和抽象的区别</h4>
<ul>
<li>interface 是一种功能一种合约，只是定义一种功能，java8 之前是不能够包含方法体的，之后能够通过default 的方式写入实现，但是不能包含成员变量</li>
<li>抽象类 提供抽象的骨架实现，通过继承能够实现骨架实现，可以包含抽象方法或这具体实现，也可以包含成员变量</li>
<li>
<ul>
<li>Java 是单根继承的只能够继承一个父类，但是能够实现多个接口</li>
</ul>
</li>
<li>如果类里需要成员变量，就用抽象类，否则就用接口。但是类只能够单根继承</li>
</ul>
<h4 id="final">final</h4>
<ul>
<li>final类是不能够被继承的，不能覆盖</li>
<li>final对象不能被修改变量</li>
</ul>
<h4 id="overwrite-和-overload">overwrite 和 overload</h4>
<ul>
<li>overwrite 重写 把继承的方法覆盖重写</li>
<li>overload 方法能够有同样的名字不同的变量，方法被引用继承的时候能够根据实际来实现</li>
</ul>
<h2 id="集合框架">集合框架</h2>
<h4 id="hashmap-集合框架">HashMap 集合框架</h4>
<ul>
<li>扩容/并发</li>
</ul>
<h4 id="listsetmap区别">List/Set/Map区别</h4>
<ul>
<li>List &ndash;&gt; 有序的集合，队列， 所以List 的get(int i)获取List（排列位置i）的值</li>
<li>Set 元素之间是没有顺序，且元素不能重复【集合】，可以用来去重</li>
<li>Map</li>
</ul>
<h4 id="hashmap-和-hashtable-的区别">HashMap 和 HashTable 的区别</h4>
<ul>
<li>数据结构都是基于哈希表的</li>
<li>HashMap 可以接受为null的对象，但是HashTable不能</li>
<li>HashTable 是线程安全的，HashMap不是</li>
</ul>
<blockquote>
<ul>
<li>把所有的方法都添加线程安全的锁（sychronized）</li>
</ul>
</blockquote>
<h4 id="concurrenthashmap-原理">ConcurrentHashMap 原理</h4>
<ul>
<li>HashMap是不安全的 &ndash;&gt;</li>
<li>CHM  里面的hash桶是分区域管理（Segment）的，当用到一个hash桶的时候就可以获得这个区域的锁，不同于这个区域的hash桶就能够被使用</li>
</ul>
<h4 id="hashset">HashSet</h4>
<ul>
<li>包含一个HashMap，使用add()也只是把数据put（）到map里面，所以实际是HashMap</li>
</ul>
<h4 id="treeset">TreeSet</h4>
<ul>
<li>NavigableSet(可导航)，基于TreeMap</li>
</ul>
<blockquote>
<ul>
<li>TreeMap 基于红黑树的可以当行的实现</li>
</ul>
</blockquote>
<ol>
<li>实现元素有序 &ndash;&gt; ArrayList、二叉查找树</li>
</ol>
<blockquote>
<ul>
<li>HashSet 插入删除几乎都是O(1)，但是无序</li>
<li>LinkerHashSet 顺序只是插入的顺序，但是并不能根据数据进行排序</li>
</ul>
</blockquote>
<ul>
<li>二叉查找树每一个节点都有能有两个子节点，左节点比右节点大，左边比右边大，所以查找的时候能够很快地排除一般的数据，所以查找插入几乎是O(logn)</li>
<li>
<ul>
<li>但是如果通过设计，会出现退化成链表的情况出现，而避免这种情况就是红黑树，从而保证红黑树在任何情况下都能够几乎保持平衡（左子树和右子树都接近于相等，在变更后仍然能够保持）
&mdash;&gt; Tree（红黑树），可导航就是可以从小到大排列的 &ndash;&gt; TreeMap 从小到大拍好的，且能够保持平衡的，能够实现高效</li>
</ul>
</li>
</ul>
<ol start="2">
<li>实现插入删除都高效</li>
</ol>
<blockquote>
<ul>
<li>ArrayList 插入删除后后面的元素都需要移动，</li>
<li>LinkedList 插入为O(1)速度很快，但是查找为O(n),需要一个个地进行查找</li>
</ul>
</blockquote>
<h4 id="equa-lshashcode-区别何时使用">equa ls/hashCode 区别、何时使用</h4>
<ul>
<li>equals 同于判断两个对象是否相等</li>
</ul>
<blockquote>
<ul>
<li>三个约定</li>
</ul>
<ol>
<li>一个对象无论何时被调用多于一次的时候，这个对象的HashCode 必须返回相同如一的整数</li>
<li>两个对象equals 相等的话，hashCode一定相等</li>
<li>两个对象equals不相等的话，hashCode也有可能是相等的
&ndash;&gt; 两个对象hashCode 是相等的，equals 不相等的情况发生【Hash桶碰撞】</li>
</ol>
</blockquote>
<h4 id="arraylist和linkedlist-区别">ArrayList和LinkedList 区别</h4>
<ul>
<li>ArrayList 是基于数组（Object[] elementData）的实现</li>
</ul>
<blockquote>
<ul>
<li>动态扩容  把原来的数据复制到新的容量更大的数组里面，然后继续添加新的数据</li>
<li>数据查找都是O(1)</li>
</ul>
</blockquote>
<ul>
<li>LinkedList 双向列表结构
**使用到队列的时候就使用LinkedList，因为ArrayList对头元素进行修改的时候后面的所有元素都要发生移动 **</li>
</ul>
<h4 id="线程安全的集合类">线程安全的集合类</h4>
<p>HashTable（但是非常少用）、ConcurrentHashSet</p>
<h4 id="如何保证一个集合类不被修改">如何保证一个集合类不被修改</h4>
<ul>
<li>通过Collections/.unmodifiable~()生成的也是不可变的，因为里面set（）、remove（）等修改集合的方法都是全都会返回异常</li>
<li>Guava <code>ImmutableSet&lt;&gt;</code>抽象类，继承后能够生成不可变的Set集合</li>
</ul>
<h4 id="arraylistvector">ArrayList/Vector</h4>
<ul>
<li>Vector java1.0引入，但是1.2就被废弃</li>
</ul>
<blockquote>
<ul>
<li>和ArrayList 功能完全相同。都能够实现一个能够增长的Object。（基于数组的自动扩容实现）</li>
<li>Vector 线程安全，但是慢，被废弃了</li>
<li>ArrayList 不安全。但是速度高</li>
</ul>
</blockquote>
<h4 id="collection和collections-区别">Collection和Collections 区别</h4>
<ul>
<li>Collection 是一个类名</li>
<li>Collections 是和Collection相关的集合</li>
</ul>
<p>Vector &amp; ArrayList 的主要区别
1） 同步性:Vector是线程安全的，也就是说是同步的 ，而ArrayList 是线程序不安全的，不是同步的 数2。
2）数据增长:当需要增长时,Vector默认增长为原来一倍 ，而ArrayList却是原来的50%  ，这样,ArrayList就有利于节约内存空间。
如果涉及到堆栈，队列等操作，应该考虑用Vector，如果需要快速随机访问元素，应该使用ArrayList 。</p>
<p>扩展知识：</p>
<ol>
<li>
<p>Hashtable &amp; HashMap
Hashtable和HashMap它们的性能方面的比较类似 Vector和ArrayList，比如Hashtable的方法是同步的,而HashMap的不是。</p>
</li>
<li>
<p>ArrayList &amp; LinkedList</p>
</li>
</ol>
<p>ArrayList的内部实现是基于内部数组Object[],所以从概念上讲,它更象数组，但LinkedList的内部实现是基于一组连接的记录，所以，它更象一个链表结构，所以，它们在性能上有很大的差别：<br>
从上面的分析可知,在ArrayList的前面或中间插入数据时,你必须将其后的所有数据相应的后移,这样必然要花费较多时间，所以,当你的操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能； 而访问链表中的某个元素时,就必须从链表的一端开始沿着连接方向一个一个元素地去查找,直到找到所需的元素为止，所以,当你的操作是在一列数据的前面或中间添加或删除数据，并且按照顺序访问其中的元素时，就应该使用LinkedList了。</p>
<h4 id="listsetmap实现">List/Set/Map实现</h4>
<h2 id="异常">异常</h2>
<h4 id="java-的异常体系结构">Java 的异常体系结构</h4>
<ul>
<li>Throwable 任何异常。错误的祖先类</li>
</ul>
<blockquote>
<ul>
<li>Exception 异常，可以从异常状态中恢复</li>
<li>
<ul>
<li>RuntimeException 预料之外的异常， unchecked ，通常代表一个Bug</li>
</ul>
</li>
<li>
<ul>
<li>其他 Exception 预料之中的异常，checked ， 代表编程中预期的异常状态</li>
</ul>
</li>
<li>Error  无法回复的异常状态 unchecked</li>
</ul>
</blockquote>
<h4 id="checkeduncheckedruntime-exeception">checked/unchecked/runtime exeception</h4>
<h4 id="trychtchfinally">try/chtch/finally</h4>
<ul>
<li>try 执行语句，如果没有异常 后面的catch 会跳过。而出现异常之后，try里面没有执行的语句就会跳过，直接到catch里面</li>
<li>catch（） 里面可以放任何的Throwable 后代。一旦try 出现异常，就会被后面的catch 捕获。catch 的异常按顺序匹配，匹配到后就按catch 的方法处理异常</li>
<li>catch 中return了，finally 还会执行</li>
<li>finally 里return</li>
</ul>
<blockquote>
<ul>
<li>finally 里 的return 会替代掉原本的return值（生产中不能够用！！）</li>
</ul>
</blockquote>
<h4 id="throwthrows-区别">throw/throws 区别</h4>
<ul>
<li>throw 一个普通的语句，用于抛出异常，阻止当前的方法执行。</li>
<li>throws 用于方法声明异常。声明调用这个方法的时候会有可能出现这个异常</li>
</ul>
<h4 id="final-1">final/</h4>
<ul>
<li>final 用于类或者方法是不能够被继承，覆盖的，变量的话是指针指向的对象不能够更改</li>
<li>finally try/catch 过程中执行保险开关或者垃圾清理</li>
<li>finalize 被标注废弃的一个方法。 一个对象调用这个方法后就能够逃脱被垃圾回收，但是不推荐使用，而且垃圾回收什么时候进行是没有人知道的</li>
</ul>
<h2 id="计算机体系原理">计算机体系原理</h2>
<h4 id="进程和线程的区别">进程和线程的区别</h4>
<ul>
<li>独享一块内存空间的基本的单元，进程和进程是独立的，不能够互相访问。一个进程奔溃后不会干扰到另一个进程</li>
<li>
<ul>
<li>进程 ：进程占用独享的隔离的内存，文件等资源。是系统进行资源分配和调度的基本单位，是操作系统结构的基础</li>
</ul>
</li>
<li>
<ul>
<li>线程： 同一个进程内的线程共享内存/文件等资源。是系统进行资源分配和调度的基本单位，是操作系统结构的基础。。是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</li>
</ul>
</li>
</ul>
<h4 id="进程和线程是如何调度的">进程和线程是如何调度的</h4>
<ul>
<li>通过时间片轮转，每个时间片cpu单独运行一个线程，下一个时间片就运行下一个线程</li>
</ul>
<h4 id="java中的线程和操作系统线程是什么关系">Java中的线程和操作系统线程是什么关系？</h4>
<p>Java中线程的本质，其实就是操作系统中的线程</p>
<ul>
<li>JVM的线程和OS的线程是一一对应的</li>
</ul>
<blockquote>
<ul>
<li>JVM :虚拟机中的线程状态，不反应任何操作系统线程状态
Java调用start()方法,在JVM中创建新的线程,再通过JVM调用 run() 方法
而调用 run() 方法, 实际上并没有创建线程,只是在当前线程中执行了一个叫 run()的方法而已,别无它意</li>
</ul>
</blockquote>
<ul>
<li>OS负责调度线程</li>
<li>因此Java的线程模型饱受诟病</li>
</ul>
<blockquote>
<ul>
<li>操作系统不知道线程的存在，因此当一个进程中的某一个线程进行系统调用时，比如缺页中断而导致线程阻塞，此时操作系统会阻塞整个进程，即使这个进程中其它线程还在工作。还有一个问题是假如进程中一个线程长时间不释放CPU，因为用户空间并没有时钟中断机制，会导致此进程中的其它线程得不到CPU而持续等待。</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>JVM 就是一个进程</li>
</ul>
</li>
<li>在Linxu 里面 线程被叫做轻量级进程，和进程一样拥有一个ID，同样占用CPU的资源，cpu决定执行的顺讯
缺点 ：</li>
</ul>
<ol>
<li>慢、占用资源。因为cpu 是时间片执行的，时间一到就需要切换到下一个线程执行，所以出现上下文切换的情况出现，占据资源。</li>
</ol>
<ul>
<li>协程：轻量用户态线程，创造出大量的轻量小东西？用完就能够丢弃，从而避免上下文切换，占用资源小，速度快，且能够决定线程执行的顺序而不是CPU决定</li>
</ul>
<blockquote>
<ul>
<li>协程只是解决运行速度，但是并发问题的死锁、竞争、临界条件还是不能解决</li>
</ul>
</blockquote>
<h2 id="计算机网络">计算机网络</h2>
<ul>
<li>TCP Transmssion Control Protocal</li>
<li>UDP User Data gram Portoed</li>
</ul>
<h4 id="基石-tcpip-协议">基石 TCP/IP 协议</h4>
<ul>
<li>由路由器决定TCP传递报文给哪个基站直目标服务器</li>
<li>TCP 稳定可靠，因为有错误控制的纠错并修改错误，但是比较慢</li>
<li>计算校验和，等待对方确认，校验和失败或者没有收到对方的回应，就会重新发送。对质量要求很高</li>
<li>保证交互</li>
<li>UDP: 非常快，质量低（视频聊天）</li>
<li>
<ul>
<li>数据可能会被丢掉</li>
</ul>
</li>
<li>尽最大可能交互</li>
</ul>
<h4 id="三次握手四次挥手">三次握手四次挥手</h4>
<ul>
<li>避免在数据传送的未完成的时候，有一方提出断开连接导致数据未成功传送完
客户端 &ndash;请求同步SYN报文&ndash;&gt; 对方 &ndash;SYN+ACK&ndash;&gt; 客户端 &ndash;ACK&ndash;&gt; 服务器</li>
<li>断开的时候任何一方都可以发送，</li>
<li>只要发送出去，传送失败就会返回给上一层，直到返回给发出源的一方在进行重新发送</li>
</ul>
<h4 id="从浏览器发出请求到接受请求过程">从浏览器发出请求到接受请求过程</h4>
<ul>
<li>输入网址发送<code>https://taobao.com</code>的时候，浏览器或者发出请求的软件就会到<code>/ect/hosts</code>这个文件里查找主机名（host）对应的IP地址</li>
<li>如果没找到就去DNS （Domain Name Service）查找该主机的IP地址</li>
<li>成功后就建立TCP链接（源IP地址、源端口、目标IP地址、目标端口）</li>
</ul>
<h4 id="域名解析-dns-靠服务器托管完成">域名解析 DNS 靠服务器托管完成</h4>
<h2 id="基本数据结构和算法">基本数据结构和算法</h2>
<h4 id="集合类中常见的数据结构">集合类中常见的数据结构</h4>
<ul>
<li>ArrayList：自动扩容的数组，随机查找是常数时间</li>
<li>LinkedList： 双链表，可当作队列和栈</li>
<li>HashSet、HashMap： 哈希表</li>
<li>TreeSet、TreeMap： 红黑树</li>
<li>ConcurrentHashMap： 分段+哈希表</li>
<li>LinkedHashMap：链表+哈希表</li>
</ul>
<h4 id="链表和二叉树的时间复杂度去表">链表和二叉树的时间复杂度去表</h4>
<ul>
<li>ArrayList：寻址O(1)/更新O(n)/二分查找O(lgn)</li>
<li>LinkerList： 寻址O(n)/更新O(n)/查找O(n)</li>
<li>哈希表： 都是O(1)</li>
<li>红黑树：都是O(lgn)</li>
<li>二叉树查找： 都是O（lgn）</li>
</ul>
<h4 id="队列和栈分别是什么">队列和栈分别是什么</h4>
<h2 id="wbe">Wbe</h2>
<h4 id="常见的http状态码">常见的HTTP状态码</h4>
<ul>
<li>2XX 一切正常/3XX 跳转 / 4XX 客户端异常 / 5XX 服务端异常</li>
<li>
<ul>
<li>200</li>
</ul>
</li>
<li>
<ul>
<li>201</li>
</ul>
</li>
<li>
<ul>
<li>301</li>
</ul>
</li>
<li>
<ul>
<li>302</li>
</ul>
</li>
<li>
<ul>
<li>403</li>
</ul>
</li>
<li>
<ul>
<li>404</li>
</ul>
</li>
<li>
<ul>
<li>501</li>
</ul>
</li>
<li>
<ul>
<li>502</li>
</ul>
</li>
<li>
<ul>
<li>503</li>
</ul>
</li>
<li>
<ul>
<li>504</li>
</ul>
</li>
</ul>
<h4 id="getpost区别">GET/POST区别</h4>
<ul>
<li>
<ul>
<li>Get和post 都是HTTP的方法</li>
</ul>
</li>
<li>Get 获取资源的请求 ，参数放在path 里面，历史记录就能看到。不能用于密码的登录，容易被看到</li>
<li>Post 用于发送数据（登录） 参数放在body里面</li>
<li>Get查询、获取资源</li>
<li>Get 是幂等的（多次发送和一次发送的结果完全相同）</li>
</ul>
<h4 id="cooike-和session的区别">Cooike 和Session的区别</h4>
<ul>
<li>Cookie: 包含一小段信息，给服务器用于识别用户身份。随着HTTP请求一起发送的一小段标识用户身份的信息。</li>
<li>session 会话：服务器存储用户的信息，用于检查cookie对应信息的数据 。放在服务端的，用于通过Cookie和用户身份对应关系来鉴权的数据</li>
<li>同源策略：向特定的HTTP（同一个域名的同一个端口号 ）发送请求的时候浏览器才会携带这个Cookie，不同域名就不会带这个，保证用户信息安全。防止引入恶意的javascrip泄露数据</li>
<li>
<ul>
<li>任何需要程序去访问其他域名下的数据的场景都会被同源策略阻碍到。一个网站想提供一个 JavaScript 程序来检验、测试或者仅仅访问另一个网页，那么它没法访问那个网站上的数据，也就没法达到它的设计目的。</li>
</ul>
</li>
<li>
<ul>
<li>数据融合。当政府开始公开大量的开放公共数据时，有一些网站会开始涌现，这些网站从许多不同的开放数据站点加载数据并提供数据的「融合」—— 组合许多不同来源的数据，并提供可视化，从而让用户享受到单一数据源所不能提供的洞察力。但实际上，典型的纯前端的数据融合网站现在已经无法工作了。</li>
</ul>
</li>
</ul>
<h4 id="什么是跨越如何解决">什么是跨越，如何解决</h4>
<ul>
<li>在同一个域名能够访问不同的网站（不同的域之间相互请求资源）</li>
</ul>
<h4 id="解决">解决</h4>
<ul>
<li>JSONP 只支持GET请求</li>
<li>javascrip加载是不受同源策略的限制的，只是javascrip脚执行发送的HTTP请求受到同源策略的限制</li>
<li>
<ul>
<li>src 标签可以携带其他网站的地址，通过动态的jsonp加载，把接口伪装成动态的javascrip标签，使得浏览器在加载的时候就能够自动向标签里的地址发起请求</li>
</ul>
</li>
<li>CORS（跨域资源共享）支持所有HTTP类型请求 IE10+</li>
<li>
<ul>
<li>浏览器制造商实现了一些钩子以允许数据在不同的源上共享，并称之为跨域资源共享（CORS）。要求开放数据发布者在 HTTP 响应中为任何完全开放的数据添加特殊的 CORS 头：
<code>Access-control-allow-Origin: *</code></li>
</ul>
</li>
<li>
<ul>
<li>同时他们添加了一项功能，允许数据发布者指定有限的其他可信来源，这些来源将被允许访问数据发布者产生的数据。（其他服务器添加一份允许不同域访问的白名单）</li>
</ul>
</li>
<li>
<ul>
<li>简单请求</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>在head信息里面加入<code>Origin</code>字段。用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</li>
</ul>
</blockquote>
<pre><code>GET /cors HTTP/1.1
Origin: http://api.bob.com
</code></pre><p>[https://www.ruanyifeng.com/blog/2016/04/cors.html]</p>
<ul>
<li>Nginx  反向代理</li>
<li>
<ul>
<li>在部署的服务器上 设置Nginx，请求的时候根据需要自动访问其他的网页并获得数据</li>
</ul>
</li>
</ul>
<h3 id="域名地址的组成">域名地址的组成：</h3>
<p><code>http:// www . google : 8080 / script/jquery.js</code></p>
<ul>
<li>http:// （协议号）</li>
<li>www  （子域名）</li>
<li>google （主域名）</li>
<li>8080 （端口号）</li>
<li>script/jquery.js （请求的地址）</li>
<li>
<ul>
<li>当协议、子域名、主域名、端口号中任意一各不相同时，都算不同的“域”。</li>
</ul>
</li>
<li>
<ul>
<li>不同的域之间相互请求资源，就叫“跨域”。</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>比如：http://www.a.com/index.html 请求 <a href="http://www.b.com/index.html">http://www.b.com/index.html</a>的数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="为什么要跨越">为什么要跨越</h3>
<ul>
<li>域名和后端接口的域名不一样 是不可避免的</li>
</ul>
<h2 id="类型与反射">类型与反射</h2>
<h4 id="反射">反射</h4>
<ul>
<li>运行时行为，动态调用</li>
</ul>
<h4 id="动态代理的原理">动态代理的原理</h4>
<ul>
<li>动态生成字节码完成一些动能扩展</li>
<li>
<ul>
<li>JDK 动态代理：方便，受限制（只能代理接口）</li>
</ul>
</li>
</ul>
<h4 id="反射为什么性能差">反射为什么性能差</h4>
<ul>
<li>JDK无法预测被调用的方法，因此无法实施优化</li>
</ul>
<h4 id="序列化">序列化</h4>
<ul>
<li>序列化：Java对象 &ndash;&gt; 字节流 serizlize</li>
<li>反序列化： 字节流 &ndash;&gt; Java 对象 deserialize</li>
<li>可读： JSON、XML</li>
<li>不可读: Java 自带的系列化</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Web页面  前后端渲染</title>
            <link>https://procarihana.github.io/public/posts/web%E9%A1%B5%E9%9D%A2-%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93/</link>
            <pubDate>Mon, 07 Sep 2020 14:59:13 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/web%E9%A1%B5%E9%9D%A2-%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93/</guid>
            <description>前端渲染：前端发送静态的html数据 后端渲染：后端发送htlm数据  渲染模板  index.html -&amp;gt; 静态模板  &amp;lt;!DOCTYPE heml&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h2&amp;gt;商品排行榜&amp;lt;/h2&amp;gt; &amp;lt;table&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;排名&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;商品名&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;成交金额&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;西瓜&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;400&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;2&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;香蕉&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;200&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;3&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;...&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;...&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  动态模板引擎 -&amp;gt; spring-freemarker   模板引擎就是能够然数据替换   maven  &amp;lt;!-- spring-boot-starter-freemarker --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-freemarker&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;  文件结构 (View) resources/templaes/~.ftl -&amp;gt; 存放动态模板   其中list 为结果集 name-&amp;gt;items    &amp;lt;table&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;排名&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;商品名&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;成交金额&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;#list items as item&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;${item.</description>
            <content type="html"><![CDATA[<ul>
<li>前端渲染：前端发送静态的html数据</li>
<li>后端渲染：后端发送htlm数据</li>
</ul>
<h2 id="渲染模板">渲染模板</h2>
<ul>
<li>index.html -&gt; 静态模板</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#960050;background-color:#1e0010">&lt;!DOCTYPE</span> <span style="color:#960050;background-color:#1e0010">heml&gt;</span>
<span style="color:#960050;background-color:#1e0010">&lt;/head&gt;</span>
<span style="color:#960050;background-color:#1e0010">&lt;body&gt;</span>

<span style="color:#960050;background-color:#1e0010">&lt;h</span><span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">&gt;商品排行榜&lt;/h</span><span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">&gt;</span>

<span style="color:#960050;background-color:#1e0010">&lt;table&gt;</span>
  <span style="color:#960050;background-color:#1e0010">&lt;tr&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;th&gt;排名&lt;/th&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;th&gt;商品名&lt;/th&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;th&gt;成交金额&lt;/th&gt;</span>
  <span style="color:#960050;background-color:#1e0010">&lt;/tr&gt;</span>
  <span style="color:#960050;background-color:#1e0010">&lt;tr&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;td&gt;</span><span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">&lt;/td&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;td&gt;西瓜&lt;/td&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;td&gt;</span><span style="color:#ae81ff">400</span><span style="color:#960050;background-color:#1e0010">&lt;/td&gt;</span>
  <span style="color:#960050;background-color:#1e0010">&lt;/tr&gt;</span>
  <span style="color:#960050;background-color:#1e0010">&lt;tr&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;td&gt;</span><span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">&lt;/td&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;td&gt;香蕉&lt;/td&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;td&gt;</span><span style="color:#ae81ff">200</span><span style="color:#960050;background-color:#1e0010">&lt;/td&gt;</span>
  <span style="color:#960050;background-color:#1e0010">&lt;/tr&gt;</span>
  <span style="color:#960050;background-color:#1e0010">&lt;tr&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;td&gt;</span><span style="color:#ae81ff">3</span><span style="color:#960050;background-color:#1e0010">&lt;/td&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;td&gt;...&lt;/td&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;td&gt;...&lt;/td&gt;</span>
  <span style="color:#960050;background-color:#1e0010">&lt;/tr&gt;</span>
<span style="color:#960050;background-color:#1e0010">&lt;/table&gt;</span>

<span style="color:#960050;background-color:#1e0010">&lt;/body&gt;</span>
<span style="color:#960050;background-color:#1e0010">&lt;/html&gt;</span>
</code></pre></div><ul>
<li>动态模板引擎 -&gt; spring-freemarker</li>
<li>
<ul>
<li>模板引擎就是能够然数据替换</li>
</ul>
</li>
<li>maven</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;!--</span> spring<span style="color:#f92672">-</span>boot<span style="color:#f92672">-</span>starter<span style="color:#f92672">-</span>freemarker <span style="color:#f92672">--&gt;</span>
<span style="color:#f92672">&lt;</span>dependency<span style="color:#f92672">&gt;</span>
    <span style="color:#f92672">&lt;</span>groupId<span style="color:#f92672">&gt;</span>org<span style="color:#f92672">.</span><span style="color:#a6e22e">springframework</span><span style="color:#f92672">.</span><span style="color:#a6e22e">boot</span><span style="color:#f92672">&lt;/</span>groupId<span style="color:#f92672">&gt;</span>
    <span style="color:#f92672">&lt;</span>artifactId<span style="color:#f92672">&gt;</span>spring<span style="color:#f92672">-</span>boot<span style="color:#f92672">-</span>starter<span style="color:#f92672">-</span>freemarker<span style="color:#f92672">&lt;/</span>artifactId<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;/</span>dependency<span style="color:#f92672">&gt;</span>
</code></pre></div><ul>
<li>文件结构 (View)</li>
<li>resources/templaes/~.ftl -&gt; 存放动态模板</li>
<li>
<ul>
<li>其中list 为结果集 name-&gt;items</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#960050;background-color:#1e0010">&lt;table&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;tr&gt;</span>
        <span style="color:#960050;background-color:#1e0010">&lt;th&gt;排名&lt;/th&gt;</span>
        <span style="color:#960050;background-color:#1e0010">&lt;th&gt;商品名&lt;/th&gt;</span>
        <span style="color:#960050;background-color:#1e0010">&lt;th&gt;成交金额&lt;/th&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;/tr&gt;</span>
   <span style="color:#960050;background-color:#1e0010">&lt;#list</span> <span style="color:#960050;background-color:#1e0010">items</span> <span style="color:#960050;background-color:#1e0010">as</span> <span style="color:#960050;background-color:#1e0010">item&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;tr&gt;</span>
        <span style="color:#960050;background-color:#1e0010">&lt;td&gt;$</span>{<span style="color:#960050;background-color:#1e0010">item.qualifying</span>}<span style="color:#960050;background-color:#1e0010">&lt;/td&gt;</span>
        <span style="color:#960050;background-color:#1e0010">&lt;td&gt;$</span>{<span style="color:#960050;background-color:#1e0010">item.goodsName</span>}<span style="color:#960050;background-color:#1e0010">&lt;/td&gt;</span>
        <span style="color:#960050;background-color:#1e0010">&lt;td&gt;$</span>{<span style="color:#960050;background-color:#1e0010">item.totalPrice</span>}<span style="color:#960050;background-color:#1e0010">&lt;/td&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;/tr&gt;</span>
    <span style="color:#960050;background-color:#1e0010">&lt;/#list&gt;</span>
<span style="color:#960050;background-color:#1e0010">&lt;/table&gt;</span>
</code></pre></div><h4 id="如果你使用的是最新版的spring-boot-22默认的freemarker扩展名变成了ftlh如果仍然使用ftl会报错404请千万注意">如果你使用的是最新版的Spring Boot （2.2+），默认的Freemarker扩展名变成了ftlh！如果仍然使用ftl会报错404！请千万注意！</h4>
<h3 id="也可以通过在spring配置里面设置完成">也可以通过在Spring配置里面设置完成</h3>
<pre><code># freemarker配置
spring.freemarker.template-loader-path=classpath:/templates
spring.freemarker.suffix=.ftl
</code></pre><ul>
<li>Controller 返回模板进行渲染</li>
<li>HashMap 存放返回的数据</li>
<li>put（”模板引擎留下的对应的位置命名“,数据）</li>
<li>返回ModelAndView(viewname,hashmap )</li>
<li>
<ul>
<li>viewname 就是<code>~</code>(~.ftl)</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@GetMapping</span><span style="color:#f92672">(</span>path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/goodsRank&#34;</span><span style="color:#f92672">,</span> produces <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;application/json&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#66d9ef">public</span> ModelAndView <span style="color:#a6e22e">getGoodsRank</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        List<span style="color:#f92672">&lt;</span>RankItem<span style="color:#f92672">&gt;</span> items <span style="color:#f92672">=</span> goodsRankManager<span style="color:#f92672">.</span><span style="color:#a6e22e">getGoodsRank</span><span style="color:#f92672">();</span>
        HashMap<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> Object<span style="color:#f92672">&gt;</span> model <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;();</span>
        model<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;items&#34;</span><span style="color:#f92672">,</span> items<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ModelAndView<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Rank&#34;</span><span style="color:#f92672">,</span> model<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="使用js和json异步请求进行前端渲染">使用JS和JSON异步请求进行前端渲染</h2>
<ul>
<li>在resouces/static/放<code>.html</code></li>
<li>
<ul>
<li>freemaker 里面的<code>.ftl</code>文件改名然后放进static 就可</li>
</ul>
</li>
<li>在里面通过</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>AOP和装饰器模式以及Redis</title>
            <link>https://procarihana.github.io/public/posts/aop%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8Aredis/</link>
            <pubDate>Fri, 04 Sep 2020 16:40:35 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/aop%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8Aredis/</guid>
            <description>AOP  Aspect-Oriented Programming 面向切面编程 相当于OOP（面向对象编程） AOP是面向切面变成，关注一个统一的切面   切面并不是对象和方法，而是执行方法的和方法之间的一瞬间、一个面   AOP和Spring是不同的东西   没有Spring容器AOP也是能够工作的     Spring 通过AOP来完成一些请求    AOP 适用的场景  需要统一处理的场景   日志     缓存     鉴权    AOP的实现  JDK动态代理（Proxy）   优点：⽅便，不需要依赖任何第三⽅库     缺点：功能受限，只适⽤于接⼝     OOP完成这些需求的话，需要使用到装饰器模型   CGLIB/ByteBuddy字节码⽣成   优点：强⼤，不受接⼝的限制     缺点：需要引⽤额外的第三⽅类库     不能增强final类/final/private⽅法    AOP与Spring  在Spring中使⽤AOP实现Redis缓存 Spring是如何切换JDK动态代理和CGLIB的？   spring.</description>
            <content type="html"><![CDATA[<h2 id="aop">AOP</h2>
<ul>
<li>Aspect-Oriented Programming 面向切面编程</li>
<li>相当于OOP（面向对象编程）</li>
<li>AOP是面向切面变成，关注一个统一的切面</li>
<li>
<ul>
<li>切面并不是对象和方法，而是执行方法的和方法之间的一瞬间、一个面</li>
</ul>
</li>
<li>AOP和Spring是不同的东西</li>
<li>
<ul>
<li>没有Spring容器AOP也是能够工作的</li>
</ul>
</li>
<li>
<ul>
<li>Spring 通过AOP来完成一些请求</li>
</ul>
</li>
</ul>
<h4 id="aop-适用的场景">AOP 适用的场景</h4>
<ul>
<li>需要统一处理的场景</li>
<li>
<ul>
<li>日志</li>
</ul>
</li>
<li>
<ul>
<li>缓存</li>
</ul>
</li>
<li>
<ul>
<li>鉴权</li>
</ul>
</li>
</ul>
<h4 id="aop的实现">AOP的实现</h4>
<ul>
<li>JDK动态代理（Proxy）</li>
<li>
<ul>
<li>优点：⽅便，不需要依赖任何第三⽅库</li>
</ul>
</li>
<li>
<ul>
<li>缺点：功能受限，只适⽤于接⼝</li>
</ul>
</li>
<li>
<ul>
<li>OOP完成这些需求的话，需要使用到装饰器模型</li>
</ul>
</li>
<li>CGLIB/ByteBuddy字节码⽣成</li>
<li>
<ul>
<li>优点：强⼤，不受接⼝的限制</li>
</ul>
</li>
<li>
<ul>
<li>缺点：需要引⽤额外的第三⽅类库</li>
</ul>
</li>
<li>
<ul>
<li>不能增强final类/final/private⽅法</li>
</ul>
</li>
</ul>
<h4 id="aop与spring">AOP与Spring</h4>
<ul>
<li>在Spring中使⽤AOP实现Redis缓存</li>
<li>Spring是如何切换JDK动态代理和CGLIB的？</li>
<li>
<ul>
<li>spring.aop.proxy-target-class=true</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>proxy-target-class</code>属性值决定是基于接口的还是基于类的代理被创建。如果proxy-target-class 属性值被设置为true，那么基于类的代理将起作用（这时需要cglib库）。如果proxy-target-class属值被设置为false或者这个属性被省略，那么标准的JDK 基于接口的代理</li>
</ul>
</blockquote>
<ul>
<li>@Aspect声明切⾯</li>
<li>
<ul>
<li>@Before</li>
</ul>
</li>
<li>
<ul>
<li>@After</li>
</ul>
</li>
<li>
<ul>
<li>@Around(拦截目标) 包裹,拦截的条件可以通过自定义完成，不仅是通过注解标识</li>
</ul>
</li>
</ul>
<h2 id="redis">Redis</h2>
<ul>
<li>服务器分布式的情况下，通过Redis进行缓存，数据就能够被所有服务器共用</li>
<li>io（数据库）非常慢，数据在不改变的情况下进行缓存能够提高速度</li>
<li>⼴泛使⽤的内存缓存</li>
<li>常⻅的数据结构</li>
<li>String/List/Set/Hash/ZSet</li>
<li>储存的方式 Redis&lt;,&gt;，和map非常像</li>
<li>Redis为什么这么快</li>
<li>
<ul>
<li>完全基于内存</li>
</ul>
</li>
<li>
<ul>
<li>优秀的数据结构设计</li>
</ul>
</li>
<li>
<ul>
<li>单⼀线程，避免上下⽂切换开销</li>
</ul>
</li>
<li>
<ul>
<li>事件驱动，⾮阻塞</li>
</ul>
</li>
<li>redis 端口为6379</li>
</ul>
<h4 id="java-object---redis-序列化">java Object -&gt; redis (序列化)</h4>
<ul>
<li>java 自带的序列化：Serializability 接口，对象实现就能够自动进行序列化</li>
<li>json</li>
</ul>
<h2 id="装饰器模式">装饰器模式</h2>
<ul>
<li>Decorator pattern</li>
<li>动态地位一个对象增加功能，但不改变其结构</li>
<li>本质上是一个“包装”</li>
<li>
<ul>
<li>添加功能的时候不需要改变原本的对象，对对象进行包装，在执行方法的时候先执行包装的方法，再执行对象的方法</li>
</ul>
</li>
<li>装饰器模式实际的是通过业务的接口，在实现的过程中执行添加的功能，真正实现业务的是另一个实现接口的类。在执行的时候<code>new 装饰器(new 实现业务（）)</code></li>
</ul>
<h4 id="生成">生成</h4>
<ul>
<li>定义一个抽象接口，接口为对象的功能</li>
<li>实现接口功能的类（接口方法默认是多态）</li>
<li>
<ul>
<li>接口而不是通过继承父类的方式</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>接口实现没有什么成员变量，不需要实现真实的方法，而继承需要继承父类的成员变量，就会出现浪费的现象</li>
</ul>
</blockquote>
<h4 id="直接的实现log的方法">直接的实现log的方法</h4>
<ul>
<li>
<ul>
<li>先写接口</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">DataService</span> <span style="color:#f92672">{</span>
    String <span style="color:#a6e22e">a</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">);</span>
    String <span style="color:#a6e22e">b</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<ul>
<li>再写实现，实现的过程中要直接手写log，如果有多个的话，就每一个都要写</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DataServiceImpl</span> <span style="color:#66d9ef">implements</span> DataService<span style="color:#f92672">{</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">a</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a is called! parameter is :&#34;</span><span style="color:#f92672">+</span>i<span style="color:#f92672">);</span>
        String result <span style="color:#f92672">=</span> UUID<span style="color:#f92672">.</span><span style="color:#a6e22e">randomUUID</span><span style="color:#f92672">().</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">();</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a is finished:&#34;</span><span style="color:#f92672">+</span>result<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
      <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">b</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b is called! parameter is :&#34;</span><span style="color:#f92672">+</span>i<span style="color:#f92672">);</span>
        String result <span style="color:#f92672">=</span> UUID<span style="color:#f92672">.</span><span style="color:#a6e22e">randomUUID</span><span style="color:#f92672">().</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">();</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b is finished:&#34;</span><span style="color:#f92672">+</span>result<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<ul>
<li>运行</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DataServiceMain</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">static</span> DataService service <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DataServiceImpl<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        service<span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

</code></pre></div><h3 id="log装饰器">log装饰器</h3>
<ul>
<li>
<ul>
<li>同样是先写接口</li>
</ul>
</li>
<li>
<ul>
<li>再写接口的实现</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DataServiceImpl</span> <span style="color:#66d9ef">implements</span> DataService <span style="color:#f92672">{</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">a</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> UUID<span style="color:#f92672">.</span><span style="color:#a6e22e">randomUUID</span><span style="color:#f92672">().</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">b</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> UUID<span style="color:#f92672">.</span><span style="color:#a6e22e">randomUUID</span><span style="color:#f92672">().</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<ul>
<li>装饰器实现接口,在override方法的时候，先实现log的方法，再完成接口需要完成的业务</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LogDecorator</span> <span style="color:#66d9ef">implements</span> DataService <span style="color:#f92672">{</span>
    DataService delegate<span style="color:#f92672">;</span><span style="color:#75715e">//委托
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">LogDecorator</span><span style="color:#f92672">(</span>DataService delegate<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">delegate</span> <span style="color:#f92672">=</span> delegate<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">a</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a is called! parameter is :&#34;</span> <span style="color:#f92672">+</span> i<span style="color:#f92672">);</span>
        String value <span style="color:#f92672">=</span> delegate<span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a is finished:&#34;</span> <span style="color:#f92672">+</span> value<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> value<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">b</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b is called! parameter is :&#34;</span> <span style="color:#f92672">+</span> i<span style="color:#f92672">);</span>
        String value <span style="color:#f92672">=</span> delegate<span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b is finished:&#34;</span> <span style="color:#f92672">+</span> value<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> value<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<ul>
<li>运行</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>最后new出DataSerivce实例的时候，先new出Log的实例，还要记得new出实现真正实现业务接口的实例，不然log装饰器就不能够实现业务！</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DataServiceMain</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">static</span> DataService service <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LogDecorator<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> DataServiceImpl<span style="color:#f92672">());</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        service<span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="cache-装饰器">Cache 装饰器</h3>
<ul>
<li>把调用过的方法缓存，之后就能够直接从缓存里面拿结果</li>
<li>
<ul>
<li>用Map储存的时候，在多线程的情景下会出现线程安全的问题</li>
</ul>
</li>
<li>在logDecorate外添加一个缓存的装饰器，把方法运行的结果缓存起来</li>
<li>
<ul>
<li>首先要继承接口，把结果缓存到map里</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CacheDecorator</span> <span style="color:#66d9ef">implements</span> DataService <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> Map<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span>String<span style="color:#f92672">&gt;</span> cache <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;();</span>
    <span style="color:#66d9ef">private</span> DataService delegate<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> String cacheLog <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;cache result&#34;</span><span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">CacheDecorator</span><span style="color:#f92672">(</span>DataService delegate<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">delegate</span> <span style="color:#f92672">=</span> delegate<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">a</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        String cacheValue <span style="color:#f92672">=</span> cache<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cacheValue <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
            String realValue <span style="color:#f92672">=</span> delegate<span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
            cache<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">,</span>realValue<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span> realValue<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span> cacheValue <span style="color:#f92672">+</span> cacheLog<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<ul>
<li>实现</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>第二次调用方法的到的结果是从缓冲里拿出来，而且缓存只是缓存业务的结果没有缓存log，所以不会有log</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DataServiceMain</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">static</span> DataService service <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CacheDecorator<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> LogDecorator<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> DataServiceImpl<span style="color:#f92672">()));</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>service<span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">(</span>1<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>service<span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">(</span>1<span style="color:#f92672">));</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="实现aop">实现AOP</h2>
<h3 id="jdk动态代理">JDK动态代理</h3>
<ul>
<li>需要代理去实现</li>
<li>
<ul>
<li>Returns a proxy instance for the specified interfacesthat dispatches method invocations to the specified invocation handler.</li>
</ul>
</li>
<li>
<ul>
<li>代理的实例为Object，所以要通过强制转换来完成业实例对象的生成</li>
</ul>
</li>
<li>
<ul>
<li>拦截的是一个实例</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">   <span style="color:#a6e22e">@CallerSensitive</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Object <span style="color:#a6e22e">newProxyInstance</span><span style="color:#f92672">(</span>ClassLoader loader<span style="color:#f92672">,</span>Class<span style="color:#f92672">&lt;?&gt;[]</span> interfaces<span style="color:#f92672">,</span>InvocationHandler h<span style="color:#f92672">){</span>
        Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">requireNonNull</span><span style="color:#f92672">(</span>h<span style="color:#f92672">);</span><span style="color:#66d9ef">final</span> Class<span style="color:#f92672">&lt;?&gt;</span> caller <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">getSecurityManager</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">?</span> <span style="color:#66d9ef">null</span>
<span style="color:#f92672">:</span> Reflection<span style="color:#f92672">.</span><span style="color:#a6e22e">getCallerClass</span><span style="color:#f92672">();</span>

        <span style="color:#75715e">/*
</span><span style="color:#75715e">         * Look up or generate the designated proxy class and its constructor.
</span><span style="color:#75715e">         */</span>
        Constructor<span style="color:#f92672">&lt;?&gt;</span> cons <span style="color:#f92672">=</span> getProxyConstructor<span style="color:#f92672">(</span>caller<span style="color:#f92672">,</span> loader<span style="color:#f92672">,</span> interfaces<span style="color:#f92672">);</span>

        <span style="color:#66d9ef">return</span> newProxyInstance<span style="color:#f92672">(</span>caller<span style="color:#f92672">,</span> cons<span style="color:#f92672">,</span> h<span style="color:#f92672">);</span>
</code></pre></div><h2 id="例子log">例子：log</h2>
<ul>
<li>实现代理的接口，从而达到动态代理的功能</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LogProxy</span> <span style="color:#66d9ef">implements</span> InvocationHandler <span style="color:#f92672">{</span>
    DataService delegate<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">LogProxy</span><span style="color:#f92672">(</span>DataService delegate<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">delegate</span> <span style="color:#f92672">=</span> delegate<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">invoke</span><span style="color:#f92672">(</span>Object proxy<span style="color:#f92672">,</span> Method method<span style="color:#f92672">,</span> Object<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Throwable <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>method<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; is invoker:&#34;</span> <span style="color:#f92672">+</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>args<span style="color:#f92672">));</span>
        Object retValue <span style="color:#f92672">=</span> method<span style="color:#f92672">.</span><span style="color:#a6e22e">invoke</span><span style="color:#f92672">(</span>delegate<span style="color:#f92672">,</span> args<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>method<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;  is finished:&#34;</span> <span style="color:#f92672">+</span> retValue<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> retValue<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>实现</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DataServiceMain</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">static</span> DataService service <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DataServiceImpl<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        DataService dataService <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>DataService<span style="color:#f92672">)</span> Proxy
            <span style="color:#f92672">.</span><span style="color:#a6e22e">newProxyInstance</span><span style="color:#f92672">(</span>service<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getClassLoader</span><span style="color:#f92672">(),</span>
                <span style="color:#66d9ef">new</span> Class<span style="color:#f92672">[]</span> <span style="color:#f92672">{</span>DataService<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">},</span> <span style="color:#66d9ef">new</span> LogProxy<span style="color:#f92672">(</span>service<span style="color:#f92672">));</span>

        dataService<span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="gclib-动态代理">GCLib 动态代理</h3>
<ul>
<li>拦截的是一个实例方法</li>
<li>引入GCLib maven
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->cglib<!-- raw HTML omitted -->
<!-- raw HTML omitted -->cglib<!-- raw HTML omitted -->
<!-- raw HTML omitted -->3.3.0<!-- raw HTML omitted -->
<!-- raw HTML omitted --></li>
<li>
<ul>
<li>使用enhancer（增强）来实现拦截并调用拦截方法和要执行的业务方法</li>
</ul>
</li>
</ul>
<ul>
<li>Generates dynamic subclasses to enable method interception. This</li>
<li>class started as a substitute for the standard Dynamic Proxy support</li>
<li>included with JDK 1.3, but one that allowed the proxies to extend a</li>
<li>concrete base class, in addition to implementing interfaces. The dynamically</li>
<li>generated subclasses override the non-final methods of the superclass and</li>
<li>have hooks which callback to user-defined interceptor</li>
<li>implementations.</li>
</ul>
<ul>
<li>动态生成↓的类，继承被拦截下来的类，从而能够通过强行转换的方式来生成业务和新增加功能的实例
<img src="/%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E5%AD%90%E7%B1%BB.png" alt=""></li>
</ul>
<h2 id="例子">例子</h2>
<ul>
<li>生成一个拦截类，拦截一个具体的实例方法</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LogInterceptor</span> <span style="color:#66d9ef">implements</span> MethodInterceptor <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span>  DataService delegate<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">LogInterceptor</span><span style="color:#f92672">(</span>DataService delegate<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">delegate</span> <span style="color:#f92672">=</span> delegate<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">intercept</span><span style="color:#f92672">(</span>Object o<span style="color:#f92672">,</span> Method method<span style="color:#f92672">,</span> Object<span style="color:#f92672">[]</span> objects<span style="color:#f92672">,</span> MethodProxy methodProxy<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Throwable <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>method<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; is invoked: &#34;</span> <span style="color:#f92672">+</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>objects<span style="color:#f92672">));</span>
        Object retValue <span style="color:#f92672">=</span> method<span style="color:#f92672">.</span><span style="color:#a6e22e">invoke</span><span style="color:#f92672">(</span>delegate<span style="color:#f92672">,</span>objects<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>method<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()+</span><span style="color:#e6db74">&#34; is finished: &#34;</span><span style="color:#f92672">+</span>retValue<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> retValue<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>实现，通过enhancer 完成</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> DataService service <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DataServiceImpl<span style="color:#f92672">();</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Enhancer enhancer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Enhancer<span style="color:#f92672">();</span>
        enhancer<span style="color:#f92672">.</span><span style="color:#a6e22e">setSuperclass</span><span style="color:#f92672">(</span>DataServiceImpl<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">);</span> <span style="color:#75715e">//动态代理
</span><span style="color:#75715e"></span>        enhancer<span style="color:#f92672">.</span><span style="color:#a6e22e">setCallback</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> LogInterceptor<span style="color:#f92672">(</span>service<span style="color:#f92672">));</span> <span style="color:#75715e">//动态代理被调用后，需要执行的方法
</span><span style="color:#75715e"></span>
        DataService enhancedService <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>DataService<span style="color:#f92672">)</span>enhancer<span style="color:#f92672">.</span><span style="color:#a6e22e">create</span><span style="color:#f92672">();</span>
        enhancedService<span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

</code></pre></div><h2 id="spring-and-aop-通过gclib-和-redis-实现缓存">Spring and AOP 通过GCLib 和 redis 实现缓存</h2>
<h4 id="maven">maven</h4>
<pre><code>&lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
    &lt;/dependency&gt;
</code></pre><h4 id="srpring-配置声明spring动态配置由gclib完成而不是jdk动态配置完成用于拦截类的方法">Srpring 配置,声明Spring动态配置由GCLib完成，而不是JDK动态配置完成,用于拦截类的方法</h4>
<p><code>spring.aop.proxy-target-class=true</code></p>
<h4 id="实现缓存---声明注解">实现缓存 -&gt; 声明注解</h4>
<ul>
<li>
<ul>
<li>使得每一个声明这个注解的方法都进去缓存切面，进行方法拦截</li>
</ul>
</li>
<li>
<ul>
<li><code>@Retention(RetentionPolicy.RUNTIME)</code>运行时才实现</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Retention</span><span style="color:#f92672">(</span>RetentionPolicy<span style="color:#f92672">.</span><span style="color:#a6e22e">RUNTIME</span><span style="color:#f92672">)</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">@interface</span> Cache <span style="color:#f92672">{</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="在需要运行redis-的地方加入cache来标记">在需要运行redis 的地方加入<code>@Cache</code>来标记</h4>
<ul>
<li>通常会放在Services或者Manager这层</li>
<li>因为使用的是GCLib，所以要在实现业务的类处放置，而不能够在接口处放置</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Component</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GoodsRankManagerImpl</span> <span style="color:#f92672">{</span>

    <span style="color:#a6e22e">@Cache</span>
    <span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>RankItem<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">getGoodsRank</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> goodsRankDao<span style="color:#f92672">.</span><span style="color:#a6e22e">getGoodsRank</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="建立缓存切面-cacheaspect">建立缓存切面 CacheAspect</h4>
<ul>
<li>
<ul>
<li>使得所有拦截方法都进入这个切面的处理环境</li>
</ul>
</li>
<li>
<ul>
<li>@Aspect 声明切面</li>
</ul>
</li>
<li>
<ul>
<li>@Around(拦截目标) 包裹,拦截的条件可以通过自定义完成，不仅是通过注解标识</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>@Around(”@annotation(注解的packagename.注解name)“)</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>@Configuration Spring提供，声明这个类适合Spirng相关的配置</li>
</ul>
</li>
<li>
<ul>
<li>使用Map进行缓存的储存，map只会被储存在运行的服务器里面，在分布式的情况下各个机器就不能够共享数据，而通过Redis储存数据则可以达到数据共享</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Aspect</span>
<span style="color:#a6e22e">@Configuration</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CacheAspect</span> <span style="color:#f92672">{</span>
    Map<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> Object<span style="color:#f92672">&gt;</span> cache <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;();</span>

    <span style="color:#a6e22e">@Around</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;@annotation(com.github.hcsp.anno.Cache)&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">cache</span><span style="color:#f92672">(</span>ProceedingJoinPoint joinPoint<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Throwable <span style="color:#f92672">{</span>
        MethodSignature signature <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>MethodSignature<span style="color:#f92672">)</span> joinPoint<span style="color:#f92672">.</span><span style="color:#a6e22e">getSignature</span><span style="color:#f92672">();</span> <span style="color:#75715e">//获得方法名
</span><span style="color:#75715e"></span>        String methodName <span style="color:#f92672">=</span> signature<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">();</span>
        Object cacheValue <span style="color:#f92672">=</span> cache<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>methodName<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cacheValue <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Get value from cache&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span> cacheValue<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            Object realValue <span style="color:#f92672">=</span> joinPoint<span style="color:#f92672">.</span><span style="color:#a6e22e">proceed</span><span style="color:#f92672">();</span>  <span style="color:#75715e">//执行
</span><span style="color:#75715e"></span>            cache<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>methodName<span style="color:#f92672">,</span> realValue<span style="color:#f92672">);</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Get value from database.&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span> realValue<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="通过dcoker启动redis">通过Dcoker启动Redis</h4>
<ul>
<li>持久化储存要记得映射！</li>
<li>配置Spring</li>
<li>
<ul>
<li>host 根据需求配置</li>
</ul>
</li>
</ul>
<pre><code>spring.redis.host=localhost
spring.redis.port=6379
</code></pre><ul>
<li>maven</li>
</ul>
<pre><code>   &lt;!-- spring-boot-starter-data-redis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre><h4 id="配置redistemplate">配置RedisTemplate</h4>
<ul>
<li>
<ul>
<li>Helper class that simplifies Redis data access code. 简化redis 的数据操作</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Configuration</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AppConfig</span> <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Bean</span>
    RedisTemplate<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span>Object<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">redisTemplate</span><span style="color:#f92672">(</span>RedisConnectionFactory factory<span style="color:#f92672">){</span>
        RedisTemplate<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span>Object<span style="color:#f92672">&gt;</span> redisTemplate <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> RedisTemplate<span style="color:#f92672">&lt;&gt;();</span>
        redisTemplate<span style="color:#f92672">.</span><span style="color:#a6e22e">setConnectionFactory</span><span style="color:#f92672">(</span>factory<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> redisTemplate<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="redistemplate-数据的存储">RedisTemplate 数据的存储</h4>
<ul>
<li>
<ul>
<li>opsForValue()有 set() 和get()两个方法来进行数据的存储，和map的get()、put()相似来尽心缓存数据的储存</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Aspect</span>
<span style="color:#a6e22e">@Configuration</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CacheAspect</span> <span style="color:#f92672">{</span>
  <span style="color:#75715e">//  Map&lt;String, Object&gt; cache = new HashMap&lt;&gt;();
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">@Autowired</span>
    RedisTemplate<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span>Object<span style="color:#f92672">&gt;</span> redisTemplate<span style="color:#f92672">;</span>
    <span style="color:#a6e22e">@Around</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;@annotation(com.github.hcsp.anno.Cache)&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">cache</span><span style="color:#f92672">(</span>ProceedingJoinPoint joinPoint<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Throwable <span style="color:#f92672">{</span>
        MethodSignature signature <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>MethodSignature<span style="color:#f92672">)</span> joinPoint<span style="color:#f92672">.</span><span style="color:#a6e22e">getSignature</span><span style="color:#f92672">();</span> <span style="color:#75715e">//获得方法名
</span><span style="color:#75715e"></span>        String methodName <span style="color:#f92672">=</span> signature<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">();</span>
        Object cacheValue <span style="color:#f92672">=</span> redisTemplate<span style="color:#f92672">.</span><span style="color:#a6e22e">opsForValue</span><span style="color:#f92672">().</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>methodName<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cacheValue <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Get value from cache&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span> cacheValue<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            Object realValue <span style="color:#f92672">=</span> joinPoint<span style="color:#f92672">.</span><span style="color:#a6e22e">proceed</span><span style="color:#f92672">();</span>  <span style="color:#75715e">//执行
</span><span style="color:#75715e"></span>            redisTemplate<span style="color:#f92672">.</span><span style="color:#a6e22e">opsForValue</span><span style="color:#f92672">().</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>methodName<span style="color:#f92672">,</span> realValue<span style="color:#f92672">);</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Get value from database.&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span> realValue<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

</code></pre></div><h4 id="缓存时间限制密钥超时时间限制">缓存时间限制（密钥超时时间限制）</h4>
<ul>
<li><code>Long timeout</code>为设置缓存的有效长</li>
<li><code>TimeUnit</code>设置有效时间的单位</li>
<li>
<ul>
<li>但是在测试的过程中呈现出时间控制不稳定的情况</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">
<span style="color:#75715e">/**
</span><span style="color:#75715e">	 * Set the {@code value} and expiration {@code timeout} for {@code key}.
</span><span style="color:#75715e">	 *
</span><span style="color:#75715e">	 * @param key must not be {@literal null}.
</span><span style="color:#75715e">	 * @param value must not be {@literal null}.
</span><span style="color:#75715e">	 * @param timeout the key expiration timeout.
</span><span style="color:#75715e">	 * @param unit must not be {@literal null}.
</span><span style="color:#75715e">	 * @see &lt;a href=&#34;https://redis.io/commands/setex&#34;&gt;Redis Documentation: SETEX&lt;/a&gt;
</span><span style="color:#75715e">	 */</span>
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> <span style="color:#66d9ef">long</span> timeout<span style="color:#f92672">,</span> TimeUnit unit<span style="color:#f92672">);</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Object realValue <span style="color:#f92672">=</span> joinPoint<span style="color:#f92672">.</span><span style="color:#a6e22e">proceed</span><span style="color:#f92672">();</span>
            redisTemplate<span style="color:#f92672">.</span><span style="color:#a6e22e">opsForValue</span><span style="color:#f92672">().</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>methodName<span style="color:#f92672">,</span> realValue<span style="color:#f92672">,</span> timeout<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span><span style="color:#f92672">);</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Get value from database.&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span> realValue<span style="color:#f92672">;</span>
</code></pre></div><ul>
<li>在<code>@Cache</code>里添加时间控制的方法</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Retention</span><span style="color:#f92672">(</span>RetentionPolicy<span style="color:#f92672">.</span><span style="color:#a6e22e">RUNTIME</span><span style="color:#f92672">)</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">@interface</span> Cache <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cacheSeconds</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">default</span> 60<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

</code></pre></div><ul>
<li>
<ul>
<li>拦截方法出添加需要控制的时间长度</li>
</ul>
</li>
</ul>
<pre><code class="language-jav" data-lang="jav"> @Cache(cacheSeconds = 1)
    @Override
    public List&lt;RankItem&gt; getGoodsRank() {
        return goodsRankDao.getGoodsRank();
    }
</code></pre><ul>
<li>
<ul>
<li>实现方法拦截处添加getAnnotation（Cache.class）.cacheSeconds()来提取控制的时间</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">  <span style="color:#a6e22e">@Around</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;@annotation(com.github.hcsp.anno.Cache)&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">cache</span><span style="color:#f92672">(</span>ProceedingJoinPoint joinPoint<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Throwable <span style="color:#f92672">{</span>
        MethodSignature signature <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>MethodSignature<span style="color:#f92672">)</span> joinPoint<span style="color:#f92672">.</span><span style="color:#a6e22e">getSignature</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">int</span> expireTime <span style="color:#f92672">=</span> signature<span style="color:#f92672">.</span><span style="color:#a6e22e">getMethod</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getAnnotation</span><span style="color:#f92672">(</span>Cache<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">).</span><span style="color:#a6e22e">cacheSeconds</span><span style="color:#f92672">();</span>
        redisTemplate<span style="color:#f92672">.</span><span style="color:#a6e22e">opsForValue</span><span style="color:#f92672">().</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>methodName<span style="color:#f92672">,</span> realValue<span style="color:#f92672">,</span> expireTime<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span><span style="color:#f92672">);</span>
</code></pre></div><h4 id="实现controller">实现controller</h4>
<ul>
<li>通过ModleAndView 实现返回结果的渲染</li>
<li>用HashMap存储 返回结果的name 和 内容，返回模板文件name 和 modelHashmap</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@RestController</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Controller</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> goodsRankManager goodsRankManager<span style="color:#f92672">;</span>

    <span style="color:#a6e22e">@Autowired</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Controller</span><span style="color:#f92672">(</span>goodsRankManager goodsRankManager<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">goodsRankManager</span> <span style="color:#f92672">=</span> goodsRankManager<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@GetMapping</span><span style="color:#f92672">(</span>path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/rank.htm&#34;</span><span style="color:#f92672">,</span> produces <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;application/json&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#66d9ef">public</span> ModelAndView <span style="color:#a6e22e">getGoodsRank</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        List<span style="color:#f92672">&lt;</span>RankItem<span style="color:#f92672">&gt;</span> items <span style="color:#f92672">=</span> goodsRankManager<span style="color:#f92672">.</span><span style="color:#a6e22e">getGoodsRank</span><span style="color:#f92672">();</span>
        HashMap<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> Object<span style="color:#f92672">&gt;</span> model <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;();</span>
        model<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;items&#34;</span><span style="color:#f92672">,</span> items<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ModelAndView<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Rank&#34;</span><span style="color:#f92672">,</span> model<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="缓存的对象要实现可以序列化">缓存的对象要实现可以序列化</h4>
<ul>
<li>通过继承Serializable 可实现</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Component</span>
<span style="color:#a6e22e">@Data</span>
<span style="color:#a6e22e">@AllArgsConstructor</span>
<span style="color:#a6e22e">@NoArgsConstructor</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RankItem</span> <span style="color:#66d9ef">implements</span> Serializable <span style="color:#f92672">{</span> <span style="color:#75715e">//可序列化
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> String goodsName<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> BigDecimal totalPrice<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="问题">问题</h2>
<ol>
<li>使用到redis 的时候出现↓，且进入了死循环</li>
</ol>
<pre><code>reconnecting, last destination was localhost/127.0.0.1:6379
</code></pre><ul>
<li>可以先看一下正在运行的容器里面的redis有没有出现port 输入错误的问题……</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>正则表达式</title>
            <link>https://procarihana.github.io/public/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
            <pubDate>Wed, 02 Sep 2020 23:44:15 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
            <description>正则表达式  ⽤于描述⽂本/字符串的⼀组规则   你可以使⽤⼀些强⼤的规则来：   处理⽂本 提取信息  常⽤的元字符          ^ 开始位置   $ 结束位置   . 单个任意字符（不⼀定包含换⾏符）   \w 单个“word”字符 字⺟/数字/下划线/汉字   \s 单个空⽩字符（\n\r\t）   \d 单个数字字符   \b 单词的开始或结束    重复          |0次或多次   |1次或多次 ? |0次或1次 {n} |n次 {n,} |&amp;gt;=n次 {n,m} |n到m次  选择          [aeiou] 单个的a/e/i/o/u字符之⼀   [0-9] 单个数字字符   [A-Z] 单个⼤写字⺟   [A-Z0-9_] ⼤写字⺟或者数字或者下划线   Hi hi 等价于    反义          [^aeiou] 单个的除a/e/i/o/u之外的字符   [^A] 单个⾮x字符   \W 单个⾮\w（字⺟/数字/下划线/汉字）   \S 单个⾮\s（空⽩）   \D 单个⾮\d（数字）字符   \B ⾮开头/结束位置    Java中的正则表达式  String split() 划分的标准   line 为”\n“   replaceAll/replaceFirst matches    尽量少⽤或者少编译，因为效率低 Java中的正则表达式是⽐较昂贵的 正则表达式需要解析，代码⾮常昂贵 匹配过程⾮常昂贵   分组与捕获  想要将所有符合正则表达式的⽂本抓出来处理 使⽤括号来指定⼀个被捕获的分组 分组的编号从1开始 分组的编号计算只看左括号 (?</description>
            <content type="html"><![CDATA[<h2 id="正则表达式">正则表达式</h2>
<ul>
<li>⽤于描述⽂本/字符串的⼀组规则</li>
<li>
<ul>
<li>你可以使⽤⼀些强⼤的规则来：</li>
</ul>
</li>
<li>处理⽂本</li>
<li>提取信息</li>
</ul>
<h2 id="常的元字符">常⽤的元字符</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>开始位置</td>
</tr>
<tr>
<td>$</td>
<td>结束位置</td>
</tr>
<tr>
<td>.</td>
<td>单个任意字符（不⼀定包含换⾏符）</td>
</tr>
<tr>
<td>\w</td>
<td>单个“word”字符 字⺟/数字/下划线/汉字</td>
</tr>
<tr>
<td>\s</td>
<td>单个空⽩字符（\n\r\t）</td>
</tr>
<tr>
<td>\d</td>
<td>单个数字字符</td>
</tr>
<tr>
<td>\b</td>
<td>单词的开始或结束</td>
</tr>
</tbody>
</table>
<h2 id="重复">重复</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
</table>
<ul>
<li>|0次或多次</li>
</ul>
<ul>
<li>|1次或多次
? |0次或1次
{n} |n次
{n,} |&gt;=n次
{n,m} |n到m次</li>
</ul>
<h2 id="选择">选择</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>[aeiou]</td>
<td>单个的a/e/i/o/u字符之⼀</td>
</tr>
<tr>
<td>[0-9]</td>
<td>单个数字字符</td>
</tr>
<tr>
<td>[A-Z]</td>
<td>单个⼤写字⺟</td>
</tr>
<tr>
<td>[A-Z0-9_]</td>
<td>⼤写字⺟或者数字或者下划线</td>
</tr>
<tr>
<td>Hi</td>
<td>hi 等价于</td>
</tr>
</tbody>
</table>
<h2 id="反义">反义</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>[^aeiou]</td>
<td>单个的除a/e/i/o/u之外的字符</td>
</tr>
<tr>
<td>[^A]</td>
<td>单个⾮x字符</td>
</tr>
<tr>
<td>\W</td>
<td>单个⾮\w（字⺟/数字/下划线/汉字）</td>
</tr>
<tr>
<td>\S</td>
<td>单个⾮\s（空⽩）</td>
</tr>
<tr>
<td>\D</td>
<td>单个⾮\d（数字）字符</td>
</tr>
<tr>
<td>\B</td>
<td>⾮开头/结束位置</td>
</tr>
</tbody>
</table>
<h2 id="java中的正则表达式">Java中的正则表达式</h2>
<ul>
<li>String</li>
<li>split() 划分的标准</li>
<li>
<ul>
<li>line 为<code>”\n“</code></li>
</ul>
</li>
<li>replaceAll/replaceFirst</li>
<li>matches</li>
</ul>
<blockquote>
<ul>
<li>尽量少⽤或者少编译，因为效率低</li>
<li>Java中的正则表达式是⽐较昂贵的</li>
<li>正则表达式需要解析，代码⾮常昂贵</li>
<li>匹配过程⾮常昂贵</li>
</ul>
</blockquote>
<h2 id="分组与捕获">分组与捕获</h2>
<ul>
<li>想要将所有符合正则表达式的⽂本抓出来处理</li>
<li>使⽤括号来指定⼀个被捕获的分组</li>
<li>分组的编号从1开始</li>
<li>分组的编号计算只看左括号</li>
<li>(?:)不捕获和分配编号，括号只⽤于分组或标记优先级</li>
</ul>
<h2 id="分组和捕获">分组和捕获</h2>
<ul>
<li>Pattern</li>
<li>
<ul>
<li>matcher()</li>
</ul>
</li>
<li>Matcher</li>
<li>
<ul>
<li>find()</li>
</ul>
</li>
<li>
<ul>
<li>group(n)</li>
</ul>
</li>
<li>先用<code>Pattern.compile()</code>来填好正则表达</li>
<li><code>Matcher matcher = pattern.matcher(String)</code>匹配字符串</li>
</ul>
<blockquote>
<ul>
<li>Creates a matcher that will match the given input against this pattern.</li>
<li>线程安全</li>
</ul>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> Matcher <span style="color:#a6e22e">matcher</span><span style="color:#f92672">(</span>CharSequence input<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>compiled<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">synchronized</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>compiled<span style="color:#f92672">)</span>
                    compile<span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        Matcher m <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Matcher<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> input<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> m<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

</code></pre></div><ul>
<li>
<ul>
<li><code>matcher.find()</code>bollean</li>
</ul>
</li>
<li>
<ul>
<li><code>matcher.ground(Int)</code>匹配组中的对应部分</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>分组只算左括号</li>
</ul>
</blockquote>
<ul>
<li>用Builder模式会更加清楚，使用<code>@lombok</code>要记得引入maven，在对象前要添加<code>@Data</code>、<code>@Builder</code></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> List<span style="color:#f92672">&lt;</span>GCActivity<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">parse</span><span style="color:#f92672">(</span>File gcLog<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        List<span style="color:#f92672">&lt;</span>GCActivity<span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
        List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> lines <span style="color:#f92672">;</span>
        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
            FileInputStream fileInputStream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span>gcLog<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">int</span> readInt <span style="color:#f92672">=</span> fileInputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">();</span>
            StringBuilder readString <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StringBuilder<span style="color:#f92672">();</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>readInt <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                readString<span style="color:#f92672">.</span><span style="color:#a6e22e">append</span><span style="color:#f92672">((</span><span style="color:#66d9ef">char</span><span style="color:#f92672">)</span> readInt<span style="color:#f92672">);</span>
                readInt <span style="color:#f92672">=</span> fileInputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>
            fileInputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
            lines <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>readString<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">().</span><span style="color:#a6e22e">split</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;\n&#34;</span><span style="color:#f92672">));</span>
            Pattern pattern <span style="color:#f92672">=</span> Pattern<span style="color:#f92672">.</span><span style="color:#a6e22e">compile</span><span style="color:#f92672">(</span>
                <span style="color:#e6db74">&#34;(\\d+)K-&gt;(\\d+)K.(\\d+)K.+\\s(\\d+)K-&gt;(\\d+)K\\((\\d+)K\\).+user=(\\d.\\d+).+sys=(\\d.\\d+).+real=(\\d.\\d+)&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>String line <span style="color:#f92672">:</span> lines<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                Matcher matcher <span style="color:#f92672">=</span> pattern<span style="color:#f92672">.</span><span style="color:#a6e22e">matcher</span><span style="color:#f92672">(</span>line<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>matcher<span style="color:#f92672">.</span><span style="color:#a6e22e">find</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
                     result<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> GCActivity<span style="color:#f92672">.</span><span style="color:#a6e22e">GCActivityBuilder</span><span style="color:#f92672">()</span>
                        <span style="color:#f92672">.</span><span style="color:#a6e22e">youngGenBefore</span><span style="color:#f92672">(</span>Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">parseInt</span><span style="color:#f92672">(</span>matcher<span style="color:#f92672">.</span><span style="color:#a6e22e">group</span><span style="color:#f92672">(</span>1<span style="color:#f92672">)))</span>
                        <span style="color:#f92672">.</span><span style="color:#a6e22e">youngGenAfter</span><span style="color:#f92672">(</span>Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">parseInt</span><span style="color:#f92672">(</span>matcher<span style="color:#f92672">.</span><span style="color:#a6e22e">group</span><span style="color:#f92672">(</span>2<span style="color:#f92672">)))</span>
                        <span style="color:#f92672">.</span><span style="color:#a6e22e">youngGenTotal</span><span style="color:#f92672">(</span>Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">parseInt</span><span style="color:#f92672">(</span>matcher<span style="color:#f92672">.</span><span style="color:#a6e22e">group</span><span style="color:#f92672">(</span>3<span style="color:#f92672">)))</span>
                        <span style="color:#f92672">.</span><span style="color:#a6e22e">heapBefore</span><span style="color:#f92672">(</span>Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">parseInt</span><span style="color:#f92672">(</span>matcher<span style="color:#f92672">.</span><span style="color:#a6e22e">group</span><span style="color:#f92672">(</span>4<span style="color:#f92672">)))</span>
                        <span style="color:#f92672">.</span><span style="color:#a6e22e">heapAfter</span><span style="color:#f92672">(</span>Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">parseInt</span><span style="color:#f92672">(</span>matcher<span style="color:#f92672">.</span><span style="color:#a6e22e">group</span><span style="color:#f92672">(</span>5<span style="color:#f92672">)))</span>
                        <span style="color:#f92672">.</span><span style="color:#a6e22e">heapTotal</span><span style="color:#f92672">(</span>Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">parseInt</span><span style="color:#f92672">(</span>matcher<span style="color:#f92672">.</span><span style="color:#a6e22e">group</span><span style="color:#f92672">(</span>6<span style="color:#f92672">)))</span>
                        <span style="color:#f92672">.</span><span style="color:#a6e22e">real</span><span style="color:#f92672">(</span>Double<span style="color:#f92672">.</span><span style="color:#a6e22e">parseDouble</span><span style="color:#f92672">(</span>matcher<span style="color:#f92672">.</span><span style="color:#a6e22e">group</span><span style="color:#f92672">(</span>7<span style="color:#f92672">)))</span>
                        <span style="color:#f92672">.</span><span style="color:#a6e22e">sys</span><span style="color:#f92672">(</span>Double<span style="color:#f92672">.</span><span style="color:#a6e22e">parseDouble</span><span style="color:#f92672">(</span>matcher<span style="color:#f92672">.</span><span style="color:#a6e22e">group</span><span style="color:#f92672">(</span>8<span style="color:#f92672">)))</span>
                        <span style="color:#f92672">.</span><span style="color:#a6e22e">user</span><span style="color:#f92672">(</span>Double<span style="color:#f92672">.</span><span style="color:#a6e22e">parseDouble</span><span style="color:#f92672">(</span>matcher<span style="color:#f92672">.</span><span style="color:#a6e22e">group</span><span style="color:#f92672">(</span>9<span style="color:#f92672">)))</span>
                        <span style="color:#f92672">.</span><span style="color:#a6e22e">build</span><span style="color:#f92672">());</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>

        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h2 id="替换">替换</h2>
<ul>
<li>
<ul>
<li>先用<code>Pattern.compile()</code>来填好正则表达</li>
</ul>
</li>
<li>
<ul>
<li><code>pattern.matcher(String)</code>来匹配好需要替换的字符串，匹配出需要替换的部分</li>
</ul>
</li>
<li>
<ul>
<li><code>.replaceAll</code>/<code>.replaceFirst</code>(只需要一次配对，避免匹配到后面格式相同但不需要的)</li>
</ul>
</li>
<li>替换时间戳</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> String <span style="color:#a6e22e">process</span><span style="color:#f92672">(</span>String log<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Pattern pattern <span style="color:#f92672">=</span> Pattern<span style="color:#f92672">.</span><span style="color:#a6e22e">compile</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;\\[\\d{4}-\\d{2}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2}\\]&#34;</span><span style="color:#f92672">);</span>
        List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>lines <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>log<span style="color:#f92672">.</span><span style="color:#a6e22e">split</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;\n&#34;</span><span style="color:#f92672">));</span>
        String result <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>String line<span style="color:#f92672">:</span>lines<span style="color:#f92672">){</span>
            String temp<span style="color:#f92672">=</span> pattern<span style="color:#f92672">.</span><span style="color:#a6e22e">matcher</span><span style="color:#f92672">(</span>line<span style="color:#f92672">).</span><span style="color:#a6e22e">replaceFirst</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>
            result <span style="color:#f92672">+=</span>temp<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;\n&#34;</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        String str <span style="color:#f92672">=</span>
                <span style="color:#e6db74">&#34;[2019-08-01 21:24:41] bt3102 (11m:21s)\n&#34;</span>
                        <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;[2019-08-01 21:24:42] TeamCity server version is 2019.1.1 (build 66192)\n&#34;</span>
                        <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;[2019-08-01 21:24:43] Collecting changes in 2 VCS roots (22s)\n&#34;</span><span style="color:#f92672">;</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>process<span style="color:#f92672">(</span>str<span style="color:#f92672">));</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Docker的原理和应用</title>
            <link>https://procarihana.github.io/public/posts/docker%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/</link>
            <pubDate>Tue, 01 Sep 2020 18:41:11 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/docker%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/</guid>
            <description>虚拟机有一套完整独立的操作系统，非常占内存和资源,虚拟机内即使有空闲的资源也不能够集中利用，只能够浪费 docker 启动的容器用于运行程序，剩余的内存能够继续用于新的容器，从而节省内存 阿里云的镜像加速所向无敌  Docker  保证开发、测试、交付、部署的环境完全一致 保证资源的隔离   通过fastjson 任意代码执行漏洞，通过java进程获得来操控别的进程从而过得Linux的控制权限。而Docker 资源隔离只能够获得Docker内的权限，对宿主机没有任何影响   启动临时的、用完即弃的环境，例如测试 迅速（秒级）超大规模部署和扩容   可以迅速扩容大量的容器，且环境是一模一样的    Docker 的基本概念  镜像 image   一个预定好的模板文件，Docker 引擎可以按照这个模板文件启动无数个一模一样，互不干扰的容器     像是一份清单一样，每次启动这个镜像就按照这份清单来启动   容器 container   一台虚拟的计算机，拥有独立的：      网络 文件系统 进程      默认和宿主机不发生任何交互      意味着数据是没有持久化的   Docker 指令 docker run : 启动一个全新的控制资源隔离的docker容器  一台独立的计算机 每个容器都有一个ID，支持缩写 docker run -it &amp;lt;镜像名&amp;gt;&amp;lt;镜像中要运行的命令和参数&amp;gt;   交互式命令行模式，当前shell中运行。Ctrl-c退出（启动一个容器，并立刻进入内部进行操作）   docker run -d   daemon模式，在后台运行   &amp;ndash; name 为容器指定一个名字 &amp;ndash; restart=always 遇到错误马上重启 -&amp;gt; 用于NGINX等    docker run &amp;ndash;name springboot-nginx &amp;ndash;restart=always -v pwd/nginx/nginx.</description>
            <content type="html"><![CDATA[<ul>
<li>虚拟机有一套完整独立的操作系统，非常占内存和资源,虚拟机内即使有空闲的资源也不能够集中利用，只能够浪费</li>
<li>docker 启动的容器用于运行程序，剩余的内存能够继续用于新的容器，从而节省内存</li>
<li>阿里云的镜像加速所向无敌</li>
</ul>
<h2 id="docker">Docker</h2>
<ul>
<li>保证开发、测试、交付、部署的环境完全一致</li>
<li>保证资源的隔离</li>
<li>
<ul>
<li>通过fastjson 任意代码执行漏洞，通过java进程获得来操控别的进程从而过得Linux的控制权限。而Docker 资源隔离只能够获得Docker内的权限，对宿主机没有任何影响</li>
</ul>
</li>
<li>启动临时的、用完即弃的环境，例如测试</li>
<li>迅速（秒级）超大规模部署和扩容</li>
<li>
<ul>
<li>可以迅速扩容大量的容器，且环境是一模一样的</li>
</ul>
</li>
</ul>
<h2 id="docker-的基本概念">Docker 的基本概念</h2>
<ul>
<li>镜像 image</li>
<li>
<ul>
<li>一个预定好的模板文件，Docker 引擎可以按照这个模板文件启动无数个一模一样，互不干扰的容器</li>
</ul>
</li>
<li>
<ul>
<li>像是一份清单一样，每次启动这个镜像就按照这份清单来启动</li>
</ul>
</li>
<li>容器 container</li>
<li>
<ul>
<li>一台虚拟的计算机，拥有独立的：</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>网络</li>
<li>文件系统</li>
<li>进程</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>默认和宿主机不发生任何交互</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>意味着数据是没有持久化的</li>
</ul>
</blockquote>
<h2 id="docker-指令">Docker 指令</h2>
<h4 id="docker-run--启动一个全新的控制资源隔离的docker容器">docker run : 启动一个全新的控制资源隔离的docker容器</h4>
<ul>
<li>一台独立的计算机</li>
<li>每个容器都有一个ID，支持缩写</li>
<li>docker run -it &lt;镜像名&gt;&lt;镜像中要运行的命令和参数&gt;</li>
<li>
<ul>
<li>交互式命令行模式，当前shell中运行。Ctrl-c退出（启动一个容器，并立刻进入内部进行操作）</li>
</ul>
</li>
<li>docker run -d</li>
<li>
<ul>
<li>daemon模式，在后台运行</li>
</ul>
</li>
<li>&ndash; name 为容器指定一个名字</li>
<li>&ndash; restart=always 遇到错误马上重启 -&gt; 用于NGINX等</li>
</ul>
<blockquote>
<ul>
<li>docker run &ndash;name springboot-nginx &ndash;restart=always -v <code>pwd</code>/nginx/nginx.conf:/etc/nginx/nginx.conf:ro -d -p 8085:80 nginx</li>
</ul>
</blockquote>
<ul>
<li>-v &lt;本地文件&gt;:&lt;容器文件&gt;:文件权限（ro、rw……）</li>
<li>
<ul>
<li>宿主机上的文件映射到docker容器里面，使得docker容器里也可以打开这个文件，如果文件在容器里发生改变，同样的宿主机读取时也会发生改变。权限是不强制定义。而dockerfile里也可以控制权限。</li>
</ul>
</li>
<li>
<ul>
<li><code>pwd</code>当前路径 == 全路径</li>
</ul>
</li>
<li>-p &lt;本地端口&gt;:&lt;容器端口&gt;</li>
<li>
<ul>
<li>把宿主机和容器通过指定的端口链接起来</li>
</ul>
</li>
<li>
<ul>
<li>能够实现控制多个数据库，达到分布式部署的目的</li>
</ul>
</li>
<li>-e NAME=VALUE</li>
<li>
<ul>
<li>传递初始化的参数，指定参数后，在容器里面输入Name，就会获得相应的VALUE，或者通过相应的VALUE启动程序</li>
</ul>
</li>
<li>
<ul>
<li>例如Mysql 中利用 MYSQL_ROOT_PASSWORD=password 来传递密码、名字和database名字等等</li>
</ul>
</li>
</ul>
<h4 id="docker-execute">Docker exec（ute）</h4>
<ul>
<li>指定目标容器，进入容器执行命令</li>
</ul>
<blockquote>
<ul>
<li>docker run -it&lt;目标容器ID/name&gt; &lt;目标命令（通常为bash）&gt; （进入容器内部）
<code>docker exec -it my-sql bash</code></li>
<li>可以想为ssh(进入其他容器的内部进行操作)</li>
</ul>
</blockquote>
<ul>
<li>调试、解决问题必备命令</li>
</ul>
<h4 id="docker-logs">docker logs</h4>
<ul>
<li>docker logs imageId或imageID</li>
<li>
<ul>
<li>查看目标容器的输出</li>
</ul>
</li>
<li>docker logs -f imageId或imageID</li>
</ul>
<h4 id="docker-inspect-imagesid">docker inspect imagesId</h4>
<ul>
<li>查看容器内的详细情况</li>
<li>
<ul>
<li>镜像生成的时间、id、内容等等</li>
</ul>
</li>
</ul>
<h4 id="docker-pull">Docker pull</h4>
<ul>
<li>不指定镜像版本就默认为最新的版本（latest）</li>
<li>url（镜像仓库地址）/镜像名：tag</li>
<li>
<ul>
<li>如果不加url，就是去中央仓库里面寻找镜像，如果添加，就去这个指定的地址下载镜像</li>
</ul>
</li>
</ul>
<h4 id="docker-push">docker push</h4>
<ul>
<li><code>docker push 地址/images:tag</code></li>
<li>把镜像push到指定的地址，之后就可以在这个地址pull到自己的镜像</li>
<li>之后pull镜像的时候就是通过地址名字的tag来进行</li>
</ul>
<h4 id="docker-images--查看本地已有的镜像">docker images ： 查看本地已有的镜像</h4>
<ul>
<li>下载一个指定的镜像，方便随时启动</li>
</ul>
<h4 id="docker-tag">docker tag</h4>
<ul>
<li>docker tag imagesID imagesName:tag 可以为镜像取一个名字和版本</li>
<li>名字前如果有地址，则会使得镜像在push 后，到达 指定的地址，要获得这个镜像就要从这个地址pull下来</li>
</ul>
<h2 id="dockerfile-创建镜像">Dockerfile 创建镜像</h2>
<ul>
<li>
<p>每个镜像都会有一个唯一的ID</p>
</li>
<li>
<p>指定镜像如何生成</p>
</li>
<li>
<p>Dockerfile （在一个文件加里面生成一个text）</p>
</li>
</ul>
<pre><code>FROM ubuntu :16.04 (容器运行系统)

RUN apt-get update &amp;&amp; apt-get install -y nginx (容器生成后运行内容，执行脚本)

RUN echo&quot;Hahaha&quot; &gt; /user/share/nginx/html/index.html 

EXPOSE 80 （访问端口）
</code></pre><ul>
<li><code>docker build .</code></li>
<li>
<ul>
<li>bulid 需要在存放dockerfile 文件里执行</li>
</ul>
</li>
<li>完成后就可以在 docker images 里面找到刚才自己新建的镜像（没有名字和tag，但是有id），然后就可以run （ID）</li>
<li>docker tag imagesID imagesName:tag 可以为镜像取一个名字和版本</li>
</ul>
<h2 id="创建私服">创建私服</h2>
<ul>
<li>可以在服务器里面布置私服</li>
<li>docker run registry</li>
<li>私服的端口是5000</li>
<li>服务器Id：5000/v2/ 查看私服是否部署成功</li>
<li>docker tag 私服要运行的imagesID 服务器ID:5000/imagesName:tag</li>
<li>
<ul>
<li>更改images 的名字，从而表明images的地址</li>
</ul>
</li>
<li>docker push imageName:tag</li>
</ul>
<h2 id="镜像">镜像</h2>
<ul>
<li>
<p>可以任意对镜像进行tag</p>
</li>
<li>
<ul>
<li>决定了这个镜像会被push到哪⾥</li>
</ul>
</li>
<li>
<ul>
<li>决定了从哪⾥下载镜像</li>
</ul>
</li>
<li>
<p>可以方便地创建镜像仓库的私服d</p>
</li>
<li>
<ul>
<li>reigstry-mirror 加速国外访问的镜像</li>
</ul>
</li>
<li>
<ul>
<li>insecure-registry docker默认使用<code>https</code>访问如果是使用docker镜像服或者私服的话就需要添加，使用不安全的方式</li>
</ul>
</li>
<li>
<p>Tag 不指定就是latest</p>
</li>
<li>
<p>Tag 如果前面是url/域名，push、pull、run，就会把镜像自动解析到相应的仓库里面
<code>my.company.com/jenkins</code></p>
</li>
<li>
<ul>
<li>Docker运行的镜像没有指定地址就从指定的中央仓库里面pull</li>
</ul>
</li>
</ul>
<h4 id="分层">分层</h4>
<ul>
<li>Docker镜像默认是分层的，根据清单，在原有默认清单的基础上在添加需要的内容</li>
<li>两个镜像基本内容一致，只有某些部分不一样，就可以通过分层的镜像，从而使镜像能够共用一致的部分，再一层一层地分别执行剩下的。</li>
</ul>
<h2 id="kuberneted-k8s">Kuberneted K8s</h2>
<ul>
<li>k8s是一个需要跑在linxu宿主机上的软件，有一个master主节点，下面有多个物理服务器节点，节点里面有docker k8s控制节点的软件用于管理，提供网络的工具，Pob（容器）</li>
<li>能够让容器同一分级地自动化服务</li>
<li>
<ul>
<li>Pob里面有一个或多个docker，出问题就会杀掉容器再重启</li>
</ul>
</li>
<li>
<ul>
<li>升级的时候K8s能够自动杀掉部分容器升级，直到所有容器</li>
</ul>
</li>
<li>k8s容器出现问题是就杀掉重启，可以迅速部署大量的容器</li>
<li>而docker的容器出现问题是就要修复</li>
</ul>
<h2 id="tip">Tip</h2>
<ul>
<li><code>$ docker run -it +启动不成功的镜像 </code> 能够看到启动不成功的原因</li>
</ul>
<h3 id="eg4">Eg4</h3>
<p>使用交互式命令行模式(-it)启动Docker容器。
向启动的Docker容器内挂载一个文件（卷），使得容器内能够读取到/app/config.txt文件，其内容为字符串&quot;ABC&rdquo;。
向启动的Docker容器内传递一个环境变量HCSP_ENV=DEF。
为启动的Docker容器设置要执行的命令：java Main。
docker run -it -e HCSP_ENV=DEF -v <code>pwd</code>/app/config.txt:/app/config.txt blindpirate/hcsp-quiz java Main</p>
<p>echo app/config.</p>
<h4 id="命令行">命令行</h4>
<ul>
<li>ECHO 内容&raquo;文本文件 新建本文写包含某些内容</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>算法和数据结构</title>
            <link>https://procarihana.github.io/public/posts/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
            <pubDate>Mon, 31 Aug 2020 20:15:50 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
            <description>空接口:只是说明有这个功能，使用这个框架，但是不提供实现
例如：RandomAccess…… 随机访问  时间复杂度与常数时间的哈希表  时间复杂度   最好时间复杂度     最坏时间复杂度     平均时间复杂度     O(1) - 哈希桶/数组随机寻址（常数时间复杂度）     哈希表的时间复杂度指的是品均时间复杂度      无论问题的规模多大，都可以在常数时间范围内求得解 解决的题的时间和问题的规模没有关系 O(1) = O(2) =O(3) = …… 因为只要是常数都是等价的   内存寻址：内存寻址的时间和内存的大小、内存存放的位置无关，和硬件电路有关     数组：array、arrayList（继承object）   哈希桶、哈希表   把对象映射成整数，然后这个整数放进哈希表里（数组）       数组的容量是有限的，但是对象的变化是无限的，造成在有限中存放无限，就会产生碰撞，而碰撞就通过链表来解决。（但是在java8发生了改变）       Hashmap 如何扩容……  indexFor 当hashmap 被恶意放进大量相同的value，就会出现hashmap退化成列表，查询时间就会变成O(n),所以为了防止这种情况，就在Java7 的时候把算法改成列表加红黑树  时间复杂度算法  O(1)=O(2)=O(3)/常数 - 哈希桶/数组随机寻址（常数）   O(n) - 遍历（线性）     O(lg(n)) - 二分查找，二叉树（对数）     O(n*lg(n))- 基于比较的排序算法下限     O(n^2) - 冒泡排序（平方）     O(n^3) 普通的没有优化过的二维矩阵的乘法   时间复杂度的计算是忽略常数的   O(n)=O(2n)   时间复杂度的计算中，高阶复杂度会吞并低阶复杂度   O(n^2)+O(n)=O(n^2)    时间复杂度的合并与乘方  基于比较的排序时间复杂度的上限是O(Nlg(n))[所有基于比较算法最好的时间复杂度都是nlg(n)]  线性时间复杂度与链表  求问题解的时间和问题的规模成正比 示例   求数组、链表的最大值     寻找数组中的重复元素     判断链表是否存在环（快慢指针）      快指针每次移动2步，慢指针每次移动1步 快慢指针相遇的时候就能够测出有闭环      求阶乘     合并两个链表     翻转链表 解决：   先把数据遍历一遍 排序（O(n*log(n))）比遍历慢  对数时间复杂度  二叉树、N叉数（B树、B+树）   在二叉树中查找某个值      二叉树： node left， node right      二叉树遍历（深度优先遍历）Depth first Search      深度优先会在最底层的节点返回 前序遍历 123 根-&amp;gt;子 中（根）序 213 子-&amp;gt;根-&amp;gt;子 后序 231 子-&amp;gt;子-&amp;gt;根      广度优先遍历 （ 队列 -&amp;gt; 先进先出）Broadth first Search      123456 1—&amp;gt;queue queue-&amp;gt;1;2,3-&amp;gt;queue queue-&amp;gt;2;4,5-&amp;gt;queue /queue:3、4、5 queue-&amp;gt;3;6-&amp;gt;queue /queue:4、5、6 直到队列为空，循环结束 queue.</description>
            <content type="html"><![CDATA[<ul>
<li>空接口:只是说明有这个功能，使用这个框架，但是不提供实现<br>
例如：RandomAccess……
随机访问</li>
</ul>
<h2 id="时间复杂度与常数时间的哈希表">时间复杂度与常数时间的哈希表</h2>
<ul>
<li>时间复杂度</li>
<li>
<ul>
<li>最好时间复杂度</li>
</ul>
</li>
<li>
<ul>
<li>最坏时间复杂度</li>
</ul>
</li>
<li>
<ul>
<li>平均时间复杂度</li>
</ul>
</li>
<li>
<ul>
<li>O(1) - 哈希桶/数组随机寻址（常数时间复杂度）</li>
</ul>
</li>
<li>
<ul>
<li>哈希表的时间复杂度指的是品均时间复杂度</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>无论问题的规模多大，都可以在常数时间范围内求得解</li>
<li>解决的题的时间和问题的规模没有关系</li>
<li>O(1) = O(2) =O(3) = …… 因为只要是常数都是等价的</li>
<li>
<ul>
<li>内存寻址：内存寻址的时间和内存的大小、内存存放的位置无关，和硬件电路有关</li>
</ul>
</li>
<li>
<ul>
<li>数组：array、arrayList（继承object）</li>
</ul>
</li>
<li>哈希桶、哈希表</li>
<li>
<ul>
<li>把对象映射成整数，然后这个整数放进哈希表里（数组）</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>数组的容量是有限的，但是对象的变化是无限的，造成在有限中存放无限，就会产生碰撞，而碰撞就通过链表来解决。（但是在java8发生了改变）</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="hashmap-如何扩容">Hashmap 如何扩容……</h4>
<ul>
<li>indexFor</li>
<li>当hashmap 被恶意放进大量相同的value，就会出现hashmap退化成列表，查询时间就会变成O(n),所以为了防止这种情况，就在Java7 的时候把算法改成列表加红黑树</li>
</ul>
<h2 id="时间复杂度算法">时间复杂度算法</h2>
<ul>
<li>O(1)=O(2)=O(3)/常数 - 哈希桶/数组随机寻址（常数）</li>
<li>
<ul>
<li>O(n) - 遍历（线性）</li>
</ul>
</li>
<li>
<ul>
<li>O(lg(n)) - 二分查找，二叉树（对数）</li>
</ul>
</li>
<li>
<ul>
<li>O(n*lg(n))- 基于比较的排序算法下限</li>
</ul>
</li>
<li>
<ul>
<li>O(n^2) - 冒泡排序（平方）</li>
</ul>
</li>
<li>
<ul>
<li>O(n^3) 普通的没有优化过的二维矩阵的乘法</li>
</ul>
</li>
<li>时间复杂度的计算是忽略常数的</li>
<li>
<ul>
<li>O(n)=O(2n)</li>
</ul>
</li>
<li>时间复杂度的计算中，高阶复杂度会吞并低阶复杂度</li>
<li>
<ul>
<li>O(n^2)+O(n)=O(n^2)</li>
</ul>
</li>
</ul>
<h2 id="时间复杂度的合并与乘方">时间复杂度的合并与乘方</h2>
<ul>
<li>基于比较的排序时间复杂度的上限是O(N<em>lg(n))[所有基于比较算法最好的时间复杂度都是n</em>lg(n)]</li>
</ul>
<h2 id="线性时间复杂度与链表">线性时间复杂度与链表</h2>
<ul>
<li>求问题解的时间和问题的规模成正比</li>
<li>示例</li>
<li>
<ul>
<li>求数组、链表的最大值</li>
</ul>
</li>
<li>
<ul>
<li>寻找数组中的重复元素</li>
</ul>
</li>
<li>
<ul>
<li>判断链表是否存在环（快慢指针）</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>快指针每次移动2步，慢指针每次移动1步</li>
<li>快慢指针相遇的时候就能够测出有闭环</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>求阶乘</li>
</ul>
</li>
<li>
<ul>
<li>合并两个链表</li>
</ul>
</li>
<li>
<ul>
<li>翻转链表
解决：</li>
</ul>
</li>
<li>先把数据遍历一遍</li>
<li>排序（O(n*log(n))）比遍历慢</li>
</ul>
<h2 id="对数时间复杂度">对数时间复杂度</h2>
<ul>
<li>二叉树、N叉数（B树、B+树）</li>
<li>
<ul>
<li>在二叉树中查找某个值</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>二叉树： node left， node right</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>二叉树遍历（深度优先遍历）Depth first Search</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>深度优先会在最底层的节点返回</li>
<li>前序遍历 123 根-&gt;子</li>
<li>中（根）序 213 子-&gt;根-&gt;子</li>
<li>后序 231 子-&gt;子-&gt;根</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>广度优先遍历 （ 队列 -&gt; 先进先出）Broadth first Search</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>123456</li>
<li>1—&gt;queue</li>
<li>queue-&gt;1;2,3-&gt;queue</li>
<li>queue-&gt;2;4,5-&gt;queue /queue:3、4、5</li>
<li>queue-&gt;3;6-&gt;queue /queue:4、5、6</li>
<li>直到队列为空，循环结束</li>
<li>queue.poll</li>
</ul>
</blockquote>
<h2 id="空间复杂度">空间复杂度</h2>
<ul>
<li>解决问题所需要的辅助空间的大小</li>
<li>
<ul>
<li>常数空间复杂度O(1):只需要固定大小的辅助空间</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>寻找最大值</li>
<li>求数组所有元素的和</li>
<li>非递归计算阶乘</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>线性 空间复杂度O(n):需要的辅助空间和问题规模成正比</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>递归计算阶乘</li>
<li>带缓存（备忘录）的斐波那契数列求值 &ndash;&gt; 0 1 1 2 3 5 8 13 21 34 每一项都是前面两项的和</li>
</ul>
</blockquote>
<h4 id="算法的优化">算法的优化</h4>
<ul>
<li>查表法（空间换时间） 通过缓存来优化算法</li>
<li>
<ul>
<li>缓存</li>
</ul>
</li>
<li>
<ul>
<li>搜索引擎</li>
</ul>
</li>
</ul>
<h2 id="二叉树中序遍历">二叉树中序遍历</h2>
<ul>
<li>二叉树解决需要结合递归完成</li>
<li>需要先判断左右点是否为空</li>
</ul>
<h3 id="判断存在环线性">判断存在环（线性）</h3>
<ul>
<li>声明p ,q 指针</li>
<li>
<ul>
<li>死循环： p -&gt; 1： 若无法前进 return false 已经到达链表的末尾。<br>
q -&gt; 2:无无法前进 return false</li>
</ul>
</li>
<li>
<ul>
<li>若 p == q返回 true ，这个时候是有环的链表</li>
</ul>
</li>
</ul>
<h2 id="递归">递归</h2>
<ol>
<li>把一个大问题分解成小问题</li>
<li>假设小问题已经解决</li>
<li>对分解的小问题进行求解</li>
</ol>
<ul>
<li>要完成递归就需要完成递归本身</li>
<li>把传进来的参数经过规定的计算方法完成计算，不需要了解如何如何进行。需要执行的方法就会存放在方法栈（先进后出）里面，运行后就会被销毁，知道所有栈运行完成。</li>
<li>一定要有返回条件（退出条件），否则就会发生栈溢出
解决：</li>
<li>先找出特殊情况</li>
<li>再找出结束的条件</li>
<li>完成1从2到三</li>
</ul>
<hr>
<h2 id="基本数据结构---数组线性表">基本数据结构 - 数组/线性表</h2>
<ul>
<li>随机寻址Randmaccess &ndash;&gt; 常数时间</li>
<li>插入/删除 &ndash;&gt; 线性时间</li>
<li>查找</li>
<li>
<ul>
<li>无序：线性时间</li>
</ul>
</li>
<li>
<ul>
<li>有序： 对数时间（二分查找）</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>二分查找</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>非递归方法</li>
<li>
<ul>
<li>三个数 right mid left &ndash;&gt; right = 0 ，left = nums.length-1 这种情况下就是[left,right]</li>
</ul>
</li>
<li>
<ul>
<li>循环（left&lt;=right）</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>mid =（left - right）/2+ left（这里一定要记得加left!）|| mid = （right+left）/2</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>target == nums[mid] &ndash;&gt; 返回mid（这种情况里包含target ==left|| target == right）</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>target&lt; &ndash;&gt; 左半区里，right要移动的 mid-1 的位置（因为mid已经检测过）</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>target&gt; &ndash;&gt; 右半区，left右移到mid+1</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>循环跳出就是证明没有这个数，返回-1</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>递归 （效率低，站的空间比较大）</li>
<li>
<ul>
<li>left = 0 ,right = nums.length -a</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="链表双向链表">链表/双向链表</h2>
<ul>
<li>寻址</li>
<li>
<ul>
<li>线性时间</li>
</ul>
</li>
<li>
<ul>
<li>无论链表是否有序，寻址的时间都是O(n)</li>
</ul>
</li>
<li>插入/删除</li>
<li>
<ul>
<li>常数时间</li>
</ul>
</li>
<li>查找</li>
<li>
<ul>
<li>线性时间</li>
</ul>
</li>
<li>要求：</li>
<li>
<ul>
<li>手写翻转链表</li>
</ul>
</li>
<li>
<ul>
<li>判断链表是否成环：双指针</li>
</ul>
</li>
</ul>
<h2 id="基本数据结构---栈">基本数据结构 - 栈</h2>
<ul>
<li>FILO</li>
<li>方法栈</li>
</ul>
<blockquote>
<ul>
<li>Stack</li>
</ul>
</blockquote>
<ul>
<li>手写栈实现</li>
<li>pudh（Object objcet）将一个元素推入栈中</li>
<li>Object pop（） 将一个元素从栈顶弹出</li>
<li>peek（） 查看栈的顶元素，不做任何操作</li>
<li>Stack 继承Vector（）
但是Stack 并不推荐，更优秀的是双端队列Deque</li>
</ul>
<h2 id="数据基本结构--队列-queue">数据基本结构- 队列 Queue</h2>
<ul>
<li>FIFO</li>
<li>线程池</li>
<li>
<ul>
<li>BlockingQueue（Runnable）workQueue</li>
</ul>
</li>
<li>手写队列</li>
</ul>
<blockquote>
<ul>
<li>add() 队列有容量限制，可能会把元素丢掉，或者抛出异常，根据具体实现</li>
<li>remove() 队列头出队列</li>
<li>offer() 队列满后添加也不会抛出异常</li>
</ul>
</blockquote>
<ul>
<li>二叉树的广度优先遍历</li>
</ul>
<h2 id="基本数据结构---哈希表">基本数据结构 - 哈希表</h2>
<ul>
<li>查找、插入、删除操作都是O(1)</li>
<li>哈希算法与碰撞</li>
<li>
<ul>
<li>哈希表+ 链表（Java8之前）</li>
</ul>
</li>
<li>
<ul>
<li>红黑树</li>
</ul>
</li>
</ul>
<h2 id="arraylist">ArrayList</h2>
<ul>
<li>扩容实现（add）</li>
<li>remove</li>
</ul>
<h2 id="linkerlist">LinkerList</h2>
<ul>
<li>双端链表</li>
<li>初始容量为0</li>
<li>构造器</li>
<li>
<ul>
<li>空的构造器</li>
</ul>
</li>
<li>
<ul>
<li>包含collection 的构造器，通过addAll（）</li>
</ul>
</li>
</ul>
<h2 id="基本数据结构---二叉树">基本数据结构 &ndash;二叉树</h2>
<h3 id="搜索二叉树">搜索二叉树</h3>
<ul>
<li>左子树比根节点小，右节点比根节点大</li>
<li>搜索的时间 O(Lgn)</li>
<li>可以进行范围的搜索</li>
<li>有可能退化成链表</li>
</ul>
<h3 id="红黑树">红黑树</h3>
<ul>
<li>能够保持左右节点保持平衡</li>
<li>通过旋转完成</li>
</ul>
<h4 id="平衡二叉树会出现线程问题因为每次添加都要保持平衡treeset">平衡二叉树会出现线程问题，因为每次添加都要保持平衡（TreeSet）</h4>
<ul>
<li>NavigbleSet<!-- raw HTML omitted --> 可导航</li>
<li>
<ul>
<li>可以返回比给定袁旭小于、等于、大于的元素（实现范围查找）</li>
</ul>
</li>
<li>TreeMap，有一个分界点，一个比较器（自定义对象进行比较）</li>
</ul>
<h4 id="add">add</h4>
<ul>
<li>
<ul>
<li>先进行一次 put 保证根节点不是null</li>
</ul>
</li>
<li>
<ul>
<li>通过比较器或者原本数值进行比较的方法进行 根节点和当前目标进行比较</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>大于就右节点，小于就左节点 再次进行比较null就set
之后会进行复杂的旋转操作</li>
</ul>
</blockquote>
<h4 id="remove">remove</h4>
<hr>
<h2 id="排序算法">排序算法</h2>
<ul>
<li>稳定和不稳定排序：能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。</li>
<li>基于比较的排序算法的复杂度下界是O(nlog(n))</li>
<li>Java 默认</li>
<li>
<ul>
<li>Arrays.sort()</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>双基准的快速排序</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>Collections.sort()</li>
</ul>
</li>
<li>
<ul>
<li>stream().sorted(Compoarted)</li>
</ul>
</li>
</ul>
<h2 id="阶乘">阶乘</h2>
<ul>
<li>当 i=1 的时候，就会返回1（满足退出条件），这是就会开始执行方法栈里面的方法栈帧，每执行一个方法栈帧，就会销毁一个直到完全执行完返回结果。</li>
</ul>
<pre><code> 1！= 1
 2! = 2*1
 3! = 3*2*1
……
N！ = N*……*3*2*1

public static int f(int i){
  if (i == 1) {
    return 1;
  } else {
    return i * f(i-1)；
  }
}
</code></pre><h4 id="数组求和">数组求和</h4>
<ul>
<li><code>List.subList(int,lisr.size())</code> :从第int个元素开始后面的元素和（不包括int）</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> <span style="color:#f92672">*</span> <span style="color:#a6e22e">@param</span> fromIndex low <span style="color:#a6e22e">endpoint</span> <span style="color:#f92672">(</span>inclusive<span style="color:#f92672">)</span> of the subList
     <span style="color:#f92672">*</span> <span style="color:#a6e22e">@param</span> toIndex high <span style="color:#a6e22e">endpoint</span> <span style="color:#f92672">(</span>exclusive<span style="color:#f92672">)</span> of the subList
     <span style="color:#f92672">*</span> <span style="color:#a6e22e">@return</span> a view of the specified range within <span style="color:#66d9ef">this</span> list
     <span style="color:#f92672">*</span> <span style="color:#a6e22e">@throws</span> IndexOutOfBoundsException <span style="color:#66d9ef">for</span> an illegal endpoint index value
     <span style="color:#f92672">*</span>         <span style="color:#f92672">(&lt;</span>tt<span style="color:#f92672">&gt;</span>fromIndex <span style="color:#f92672">&amp;</span>lt<span style="color:#f92672">;</span> 0 <span style="color:#f92672">||</span> toIndex <span style="color:#f92672">&amp;</span>gt<span style="color:#f92672">;</span> size <span style="color:#f92672">||</span>
     <span style="color:#f92672">*</span>         fromIndex <span style="color:#f92672">&amp;</span>gt<span style="color:#f92672">;</span> toIndex<span style="color:#f92672">&lt;/</span>tt<span style="color:#f92672">&gt;)</span>
     <span style="color:#f92672">*/</span>
    List<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">subList</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> fromIndex<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> toIndex<span style="color:#f92672">);</span>
    <span style="color:#960050;background-color:#1e0010">```</span>
<span style="color:#960050;background-color:#1e0010">```</span>java
   <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sum</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>0<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> sum<span style="color:#f92672">(</span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">subList</span><span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()));</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>sum<span style="color:#f92672">(</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> 3<span style="color:#f92672">,</span> 4<span style="color:#f92672">,</span> 5<span style="color:#f92672">,</span> 6<span style="color:#f92672">,</span> 7<span style="color:#f92672">,</span> 8<span style="color:#f92672">,</span> 9<span style="color:#f92672">)));</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h2 id="二叉树的中序排序">二叉树的中序排序</h2>
<h4 id="栈">栈</h4>
<ul>
<li>List<!-- raw HTML omitted --> 储存 result TreeNode.val;list 有序</li>
<li>Stack <!-- raw HTML omitted --> 存放中序遍历得到的叶子，因为栈先进后出的关系，能够使得从根节点到树最左边的叶子先进后出，使得能list 能够先获得叶节点的结果，再获得叶节点上一个根节点，再到根节点的右叶节点 2-&gt;1-&gt;3</li>
</ul>
<pre><code>      1
    /   \
  2       
</code></pre><ul>
<li>把root 装入一个 中间节点里</li>
<li>第一个循环直到所有节点都遍历完毕（中间节点为Null）且栈是空的才跳出，并且返回结果</li>
<li>
<ul>
<li>第二个循环是中间节点是否为空，不是的话就把中间节点放入栈里，在继续探寻中间节点的左节点，直到为空，就跳出</li>
</ul>
</li>
<li>
<ul>
<li>list 添加 栈返回的顶点.value（表示一个小范围的左结束）</li>
</ul>
</li>
<li>
<ul>
<li>（此时获得的中间节点为null，所以需要把最后的节点装入节点，探寻是否有右节点）</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>右节点作为中间节点继续第二个循环，如果为空，就把栈顶点跳出传入到list里（完成小范围的中且右空的遍历）</li>
<li>如果不为空，就继续遍历右节点的左节点，直到最深也叶节点，进行同样的操作</li>
</ul>
</blockquote>
<h2 id="相同的树">相同的树</h2>
<ul>
<li>迭代（深度）</li>
<li>
<ul>
<li>特殊条件</li>
</ul>
</li>
<li>
<ul>
<li>不同的两棵树</li>
</ul>
</li>
<li>
<ul>
<li>跳出条件：如果同一位置有一个点为空，另一个点不为空就结束（如果没有这个做限定就会出现int = null 的空指针异常现象）</li>
</ul>
</li>
<li>
<ul>
<li>否则就会进行两个点的value 比较，返回isSameTree（right）&amp;&amp; isSameTree(left)</li>
</ul>
</li>
<li>
<ul>
<li>如果不满足两个点都不为null，且不相同，就直接返回false 结束。</li>
</ul>
</li>
</ul>
<h2 id="对称二叉树">对称二叉树</h2>
<h3 id="迭代深度">迭代（深度）</h3>
<ul>
<li>
<ul>
<li>特殊条件</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>根节点为null时为true</li>
<li>根节点的左右节点都为null时为true</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>左右节点有一个为null时为 false</li>
</ul>
</li>
<li>
<ul>
<li>左右节点值相等时，就return 上面相同数的迭代</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>注意堆成数是 left.left == right.right;left.right == right.left &ndash;&gt; isSameTree(left.left,right.right)</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>否则就返回false</li>
</ul>
</li>
</ul>
<h3 id="递归-1">递归</h3>
<ul>
<li>
<ul>
<li>特殊条件 1223443</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>root == null</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>return check(root.left,root.right)</li>
</ul>
</li>
<li>
<ul>
<li>check (TreeNode p, TreeNode q)</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>Queue&lt;&gt; = LinkerList; 存放从root 带左右子节点出来的TreeNode （优先）</li>
<li>把 p 和 q offer 进queue 里面</li>
<li>队列非空作为循环的判断条件，如果队列为空时就是二叉树为空</li>
<li>
<ul>
<li>把队列的头两个数拿出来(poll)作对比，如果相等则继续进行循环</li>
</ul>
</li>
<li>
<ul>
<li>如果其中一个为空或者TreeNode的value 不相等则 返回 false。结束循环</li>
</ul>
</li>
<li>
<ul>
<li>把root的左右节点的左右节点放入，注意！<br>
先放left.left 和 right.right 再放 left.right,right.left 使得之后进行循环时，拿出来的数是处于对称的位置！</li>
</ul>
</li>
<li>
<ul>
<li>循环能够结束表明对称返回true</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h2 id="斐波那契数列">斐波那契数列</h2>
<h3 id="1-迭代">1. 迭代</h3>
<ul>
<li>完成的方法会出现重复运算的过程，使得时间非常慢次数是（2^n）</li>
</ul>
<blockquote>
<ul>
<li>N=5</li>
<li>f(5)=f(4)+f(3)</li>
<li>f(5) = [f(3)+f(2)+f(1)+f(0)]+[f(2)+f(1)+f(0)]</li>
</ul>
</blockquote>
<h3 id="2-缓存来优化算法时间换空间">2. 缓存来优化算法（时间换空间）</h3>
<p><strong>查询缓存，如果缓存中有，直接返回</strong></p>
<ul>
<li>特殊情况 N&lt;= 1 return N；&lt;&ndash; 如果是从0开始的话, int [0] = 0 ,int[1] = 1, int[2] = 1 ，第三个数是1；如果是从1开始的话 int[0] = 1， int[1] = 1 , int[2] = 2.</li>
<li>return memoize(N); &lt;&ndash; 进入缓存</li>
<li>
<ul>
<li>memoize</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>int[] cache = new int[N+1] &ndash;&gt; N+0 所以缓存数组的个数是N+1</li>
<li>cache[1]=1; &ndash;&gt; 新建的数组里面都是0,所以要定义int[1],否则里面怎么的搞都是0 呀！！！</li>
<li>循环 i从2开始，因为找的是int[N]，所以i&lt;= 5。循环里完成f(n)= f(n-1)+f(n-2), 在完成递归的同时，把f（4、3、2）都放入缓存里面。</li>
</ul>
</blockquote>
<ul>
<li>返回 cache[N];</li>
</ul>
<h2 id="环形链表">环形链表</h2>
<h4 id="双指针">双指针</h4>
<ul>
<li>判断头结点和第二个节点是否为空，为空就返回false</li>
<li>给p和q两个指针指定为快慢指针 头结点和第二个节点</li>
<li>循环条件为快慢节点不为同一个节点（如果为同一个节点就会出现环形链表）</li>
<li>
<ul>
<li>判断快指针和下一个指针是否为空（慢指针已经是快指针走过的了）</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>如果是就返回false、</li>
<li>不是慢指针就走一步，快指针就走两步</li>
</ul>
</blockquote>
<h2 id="汉诺塔">汉诺塔</h2>
<h4 id="迭代">迭代</h4>
<ul>
<li>move(int,list1,list2,list3)方法</li>
<li>
<ul>
<li>int -&gt; 每次移动的块位置 A</li>
</ul>
</li>
<li>
<ul>
<li>list 1 -&gt; 移出的柱子 remove -&gt;有return移出的value</li>
</ul>
</li>
<li>
<ul>
<li>list 2 -&gt; 无情工具柱，在一次move过程中暂时只是看一下</li>
</ul>
</li>
<li>
<ul>
<li>list 3 -&gt; 目标柱，add</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>当第一根柱子只剩下一个的时候，从 A(1) &ndash;&gt; C ,结束迭代</li>
<li>（一定要用eles,不然就 A(n-1)-&gt;B之后 A(1)-&gt;C 然后A(0),在没有else 的加持下就会继续执行move（n-1,A,B,C）结果就是n一直为0进入死循环！！！！！ ）</li>
<li>否则 A(n-1) -&gt; B</li>
<li>A(1) -&gt; C</li>
<li>B(n-1) -&gt; C</li>
</ul>
</blockquote>
<ul>
<li>hanata()</li>
</ul>
<blockquote>
<ul>
<li>move(A.size,A,B,C)</li>
</ul>
</blockquote>
<h4 id="通项公式达到常数时间">通项公式达到常数时间</h4>
<h2 id="删除排序链表中到的重复元素">删除排序链表中到的重复元素</h2>
<h2 id="重新排列字符串">重新排列字符串</h2>
<p>时间 O(n)，空间 O(1)</p>
<ul>
<li>char[] 存放结果 大小是indices.length</li>
<li>循环 范围是 小于length</li>
</ul>
<blockquote>
<ul>
<li>结果集存放数据的顺序是根据indiced[] 数据顺序决定的 ind[i]的值就是result集合存放第一个字母的位置，value 来自于String 按顺序输出char &ndash;&gt; char[indiced[i]] = String.charAt(i);</li>
</ul>
</blockquote>
<ul>
<li>最后返回要注意结果集是char[],不能够直接使用toString，会导致class.getName@Integer.hexcode,要使用new String(result)</li>
</ul>
<h2 id="有效括号">有效括号</h2>
<h4 id="栈--switch">栈 + switch</h4>
<ul>
<li>使用Deque<!-- raw HTML omitted --> 生成一个栈</li>
<li>使用Map 完成右符号到左符号的映射，并放入符号</li>
<li>foreach string，以字符char的形式输出</li>
</ul>
<blockquote>
<ul>
<li>switch(char)</li>
<li>
<ul>
<li>case&rsquo;左符号&rsquo;: stack.push();</li>
</ul>
</li>
<li>
<ul>
<li>case&rsquo;右符号&rsquo;:判断现在栈是否为空，栈的顶元素是否能够映射匹配上，true则pop（），否则false</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>最后return 栈是否为空,如果不为空则肯定是符号数为单数，不能匹配。</li>
</ul>
<h2 id="二叉树的层次遍历-">二叉树的层次遍历 ②</h2>
<h4 id="广度优先">广度优先</h4>
<ul>
<li>List&lt;List<!-- raw HTML omitted -->&gt; 结果集使用 LinkedList 实现</li>
<li>
<ul>
<li>因为 LinkerLis 增加元素的速度比ArrayList快，且要在头部增加元素</li>
</ul>
</li>
<li>判断TreeNode root 是否为null ,是的话就返回空的结果集</li>
<li>新建一个Queue<!-- raw HTML omitted --> queue 来存放TreeNode.val,用LinkedList实现</li>
<li>
<ul>
<li>因为这个队列是用于遍历TreeNode后存储TreeNode的，只用于增减，不需要遍历，用LinkerList 更有利</li>
</ul>
</li>
<li>把root添加到queue</li>
<li>开始循环 条件为 queue 不为空，为空则TreeNode 遍历完成，跳出返回结果集</li>
</ul>
<blockquote>
<ul>
<li>新建List<!-- raw HTML omitted --> level ，用于存放每一层TreeNode.val,使用ArrayList 实现</li>
<li>
<ul>
<li>因为这个List为结果集里面的Object，添加到结果集时需要遍历，所以用ArrayLis更有利于时间的缩短</li>
</ul>
</li>
<li>增加一个成员变量int size， 为queue.size()！！！！！！！</li>
<li>
<ul>
<li>queue是一层层地添加的，所以要及时记录每一层总共有多少个元素，否则之后随着queue element 的增减会发生变化</li>
</ul>
</li>
<li>for 循环，范围为size</li>
<li>
<ul>
<li>新建一个TreeNode 为 queue 顶元素</li>
</ul>
</li>
<li>
<ul>
<li>level add 记录弹出来的node.val</li>
</ul>
</li>
<li>
<ul>
<li>新建两个记录 这个node节点的左右节点</li>
</ul>
</li>
<li>
<ul>
<li>左右节点不为空的话就加入到queue里面</li>
</ul>
</li>
<li>结束一层节点的遍历后，就可以把这层节点记录下来的value（level）添加到结果集的头部</li>
<li>
<ul>
<li>此时queue 不为空的话， 里面存放的是下一层所包含的TreeNode，继续在记录queue.size() 后进入循环，否则为空就是TreeNode 已经遍历完毕，返回结果集</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="各集合的进出顺序">各集合的进出顺序</h5>
<ul>
<li>List&lt;List<!-- raw HTML omitted -->&gt; result  = new LinkedList&lt;&gt;(); <code>FILO</code></li>
<li>
<ul>
<li>使用 add（0，element），都放在头部（就变成队列那样）</li>
</ul>
</li>
<li>Queue<!-- raw HTML omitted --> queue  = new LinkedList&lt;&gt;(); <code>FIFO</code></li>
<li>
<ul>
<li>使用 offer 添加元素在尾部</li>
</ul>
</li>
<li>
<ul>
<li>使用 poll 删除顶部元素</li>
</ul>
</li>
<li>
<ul>
<li>所以先添加left，再到right</li>
</ul>
</li>
<li>Lis<!-- raw HTML omitted --> level = new ArrayList&lt;&gt;(); <code>FIFO</code></li>
<li>
<ul>
<li>add 把元素添加在后面</li>
</ul>
</li>
</ul>
<h2 id="只出现一次的数字">只出现一次的数字</h2>
<h4 id="异或">异或</h4>
<ul>
<li>int result = 0； &ndash;&gt; a^a==0 a^a^b==b</li>
<li>foreach</li>
</ul>
<blockquote>
<ul>
<li>resutl ^= num</li>
</ul>
</blockquote>
<h2 id="整数翻转">整数翻转</h2>
<ul>
<li>规定在[2^-31,2^31-11]范围内 （32位有符号整数）</li>
<li>一个中间的int  curr为0</li>
<li>循环x ，当 x不为〇时进入循环</li>
</ul>
<blockquote>
<ul>
<li>int pop 为 x 的最后一位数 ，通过   取余完成</li>
<li>x 取余后 就是少一位数， 通过 /10 完成（除10后怎么也会在Integer 的限制范围内，不会越界，就可以和 同样除10后的范围界限作对比）</li>
<li>
<ul>
<li>判断curr是否大于max/10||curr相等的话pop不能够大于max的个位数 （%10） 是就返回0</li>
</ul>
</li>
<li>
<ul>
<li>同样的判断curr 是否会小于 min/10 || 相等就判断pop是否会小于 min%10，是的话就返回0</li>
</ul>
</li>
<li>不满足上面的界限就能够 让 curr = curr*10 +pop 开始反转的 个位数逐步向前挪的活动，当x == 0 时 就是完成反转 返回 curr</li>
</ul>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>Java 部署</title>
            <link>https://procarihana.github.io/public/posts/java-%E9%83%A8%E7%BD%B2/</link>
            <pubDate>Sun, 30 Aug 2020 17:47:43 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/java-%E9%83%A8%E7%BD%B2/</guid>
            <description>应用开发流程  产品调研 产品设计 系统设计 -&amp;gt; 全后端文档等 开发 测试 部署  Web应用是怎么工作的  默认443端口 每个HTTP请求背后都是一台主机  分布式  解决用户量大的问题   垂直扩展 ：购入更好的机器     水平扩展 ： 购入更多的机器（分布式）      负载均衡器 Load Balance   负载均衡 容灾（单点故障）：一个服务器故障也不会影响到业务    如何保持数据一致性   让负载均衡器保证同一个用户的请求都发到同一台机器上，但是HTTP是无状态的，同一个用户的不同请求是没有先后顺序的，没有用户标识，都是HTTP请求，即使有Cookie也不行     单一数据源：数据都存在同一个数据库，即使服务器杀死重启复原数据都不会改变，但是不能够避免单点故障的问题，数据库会出问题      大多数情况下，数据库都是稳定的。 数据库会有备份   部署  将开发好的程序放在服务器上   监听端口     相应HTTP请求     进行预定义的业务逻辑处理   产品不停迭代   灰度发布：部分停止服务器进行更新。剩余的服务器有可能承受不了业务请求的数量而垮掉，即使停止的重新工作也不一定能够解决。 半夜更新     部署的版本需要不停进行更新     分布式更新   环境问题   开发环境（测试环境）     预发布环境（预生产环境，可能是生产环境的副本）     生产魂晶（正式环境）   环境的兼容性问题   硬件、软件      开发的软件、运行的软件、服务器系统      数据库等      数据库版本、内容、结构   发布和部署程序  如何在生产环境下运行 解决   编写的代码     依赖的第三方库     依赖的特殊环境配置（数据库、缓存）     稳定性     升级和回滚    使用Maven exec plugin  自动将所有的传递性依赖加入   优点：简单     缺点： 不适用与自动化的场景      运行的时候需要把代码都下载下来，才能够运行。不能够把代码编译成字节码，所以需要绑定到编译后的阶段才能够运行    自动运行的部分记得不要加生命周期！！！不然就会卡在那里的！ configuration 要放在 execution 外面，否则会识别不到executable exec:exec -&amp;gt; 在一个独立的进程中执行一个程序 exec:java -&amp;gt; 在同一个JVM里执行java  &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
            <content type="html"><![CDATA[<h2 id="应用开发流程">应用开发流程</h2>
<ul>
<li>产品调研</li>
<li>产品设计</li>
<li>系统设计 -&gt; 全后端文档等</li>
<li>开发</li>
<li>测试</li>
<li>部署</li>
</ul>
<h2 id="web应用是怎么工作的">Web应用是怎么工作的</h2>
<ul>
<li>默认443端口</li>
<li>每个HTTP请求背后都是一台主机</li>
</ul>
<h2 id="分布式">分布式</h2>
<ul>
<li>解决用户量大的问题</li>
<li>
<ul>
<li>垂直扩展 ：购入更好的机器</li>
</ul>
</li>
<li>
<ul>
<li>水平扩展 ： 购入更多的机器（分布式）</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>负载均衡器 Load Balance</li>
</ul>
<ol>
<li>负载均衡</li>
<li>容灾（单点故障）：一个服务器故障也不会影响到业务</li>
</ol>
</blockquote>
<ul>
<li>如何保持数据一致性</li>
<li>
<ul>
<li>让负载均衡器保证同一个用户的请求都发到同一台机器上，但是HTTP是无状态的，同一个用户的不同请求是没有先后顺序的，没有用户标识，都是HTTP请求，即使有Cookie也不行</li>
</ul>
</li>
<li>
<ul>
<li>单一数据源：数据都存在同一个数据库，即使服务器杀死重启复原数据都不会改变，但是不能够避免单点故障的问题，数据库会出问题</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>大多数情况下，数据库都是稳定的。</li>
<li>数据库会有备份</li>
</ol>
</blockquote>
<h2 id="部署">部署</h2>
<ul>
<li>将开发好的程序放在服务器上</li>
<li>
<ul>
<li>监听端口</li>
</ul>
</li>
<li>
<ul>
<li>相应HTTP请求</li>
</ul>
</li>
<li>
<ul>
<li>进行预定义的业务逻辑处理</li>
</ul>
</li>
<li>产品不停迭代</li>
</ul>
<ol>
<li>灰度发布：部分停止服务器进行更新。剩余的服务器有可能承受不了业务请求的数量而垮掉，即使停止的重新工作也不一定能够解决。</li>
<li>半夜更新</li>
</ol>
<ul>
<li>
<ul>
<li>部署的版本需要不停进行更新</li>
</ul>
</li>
<li>
<ul>
<li>分布式更新</li>
</ul>
</li>
<li>环境问题</li>
<li>
<ul>
<li>开发环境（测试环境）</li>
</ul>
</li>
<li>
<ul>
<li>预发布环境（预生产环境，可能是生产环境的副本）</li>
</ul>
</li>
<li>
<ul>
<li>生产魂晶（正式环境）</li>
</ul>
</li>
<li>环境的兼容性问题</li>
<li>
<ul>
<li>硬件、软件</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>开发的软件、运行的软件、服务器系统</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>数据库等</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>数据库版本、内容、结构</li>
</ul>
</blockquote>
<h2 id="发布和部署程序">发布和部署程序</h2>
<ul>
<li>如何在生产环境下运行</li>
<li>解决</li>
<li>
<ul>
<li>编写的代码</li>
</ul>
</li>
<li>
<ul>
<li>依赖的第三方库</li>
</ul>
</li>
<li>
<ul>
<li>依赖的特殊环境配置（数据库、缓存）</li>
</ul>
</li>
<li>
<ul>
<li>稳定性</li>
</ul>
</li>
<li>
<ul>
<li>升级和回滚</li>
</ul>
</li>
</ul>
<h2 id="使用maven-exec-plugin">使用Maven exec plugin</h2>
<ul>
<li>自动将所有的传递性依赖加入</li>
<li>
<ul>
<li>优点：简单</li>
</ul>
</li>
<li>
<ul>
<li>缺点： 不适用与自动化的场景</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>运行的时候需要把代码都下载下来，才能够运行。不能够把代码编译成字节码，所以需要绑定到编译后的阶段才能够运行</li>
</ul>
</blockquote>
<ul>
<li>自动运行的部分记得不要加生命周期！！！不然就会卡在那里的！</li>
<li>configuration 要放在 execution 外面，否则会识别不到executable</li>
<li>exec:exec -&gt; 在一个独立的进程中执行一个程序</li>
<li>exec:java -&gt; 在同一个JVM里执行java</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">&lt;</span>plugin<span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">&lt;</span>groupId<span style="color:#f92672">&gt;</span>org<span style="color:#f92672">.</span><span style="color:#a6e22e">codehaus</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mojo</span><span style="color:#f92672">&lt;/</span>groupId<span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">&lt;</span>artifactId<span style="color:#f92672">&gt;</span>exec<span style="color:#f92672">-</span>maven<span style="color:#f92672">-</span>plugin<span style="color:#f92672">&lt;/</span>artifactId<span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">&lt;</span>version<span style="color:#f92672">&gt;</span>3<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">&lt;/</span>version<span style="color:#f92672">&gt;</span>
      <span style="color:#f92672">&lt;</span>configuration<span style="color:#f92672">&gt;</span>
      <span style="color:#f92672">&lt;--</span> executable <span style="color:#f92672">:</span>要运行什么程序 <span style="color:#f92672">--&gt;</span>
          <span style="color:#f92672">&lt;</span>executable<span style="color:#f92672">&gt;</span>java<span style="color:#f92672">&lt;/</span>executable<span style="color:#f92672">&gt;</span>
          <span style="color:#f92672">&lt;</span>arguments<span style="color:#f92672">&gt;</span>
           <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;-</span>classpath<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
            <span style="color:#f92672">&lt;!--</span> automatically creates the classpath using all project dependencies<span style="color:#f92672">,</span>
                 also adding the project build directory
                 自动给jvm运行的class生成classpath<span style="color:#960050;background-color:#1e0010">（</span>全地址<span style="color:#960050;background-color:#1e0010">），</span>避免填写的麻烦<span style="color:#f92672">--&gt;</span>
            <span style="color:#f92672">&lt;</span>classpath<span style="color:#f92672">/&gt;</span>
           <span style="color:#f92672">&lt;--</span> argument运行程序是用的参数<span style="color:#960050;background-color:#1e0010">（</span>jvm要启动的类名<span style="color:#960050;background-color:#1e0010">）</span> <span style="color:#f92672">--&gt;</span>
            <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;</span>com<span style="color:#f92672">.</span><span style="color:#a6e22e">example</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Main</span><span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
          <span style="color:#f92672">&lt;/</span>arguments<span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">&lt;/</span>configuration<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;/</span>plugin<span style="color:#f92672">&gt;</span>
</code></pre></div><ul>
<li>命令行：可执行程序+参数</li>
<li>
<ul>
<li>mvn exec:exec 执行java</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>mvn compile exec:exec</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>mvn exec:exex -x 打印出执行的信息</li>
</ul>
</li>
</ul>
<h2 id="附">附</h2>
<ul>
<li>启动jar包</li>
<li>自动启动docker，启动数据库Mysql,测试完毕后自动销毁</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> <span style="color:#f92672">&lt;</span>plugin<span style="color:#f92672">&gt;</span>
                <span style="color:#f92672">&lt;</span>groupId<span style="color:#f92672">&gt;</span>org<span style="color:#f92672">.</span><span style="color:#a6e22e">codehaus</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mojo</span><span style="color:#f92672">&lt;/</span>groupId<span style="color:#f92672">&gt;</span>
                <span style="color:#f92672">&lt;</span>artifactId<span style="color:#f92672">&gt;</span>exec<span style="color:#f92672">-</span>maven<span style="color:#f92672">-</span>plugin<span style="color:#f92672">&lt;/</span>artifactId<span style="color:#f92672">&gt;</span>
                <span style="color:#f92672">&lt;</span>version<span style="color:#f92672">&gt;</span>3<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">&lt;/</span>version<span style="color:#f92672">&gt;</span>
                <span style="color:#f92672">&lt;</span>executions<span style="color:#f92672">&gt;</span>
                    <span style="color:#f92672">&lt;</span>execution<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;</span>id<span style="color:#f92672">&gt;</span>start java<span style="color:#f92672">&lt;/</span>id<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;!--</span>executable <span style="color:#f92672">:</span>要运行什么程序 <span style="color:#f92672">--&gt;</span>
                        <span style="color:#f92672">&lt;</span>goals<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;</span>goal<span style="color:#f92672">&gt;</span>exec<span style="color:#f92672">&lt;/</span>goal<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;/</span>goals<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;</span>configuration<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;</span>executable<span style="color:#f92672">&gt;</span>java<span style="color:#f92672">&lt;/</span>executable<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;</span>arguments<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;-</span>classpath<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;!--</span> automatically creates the classpath using all project dependencies<span style="color:#f92672">,</span>
                                     also adding the project build directory
                                     自动给jvm运行的class生成classpath<span style="color:#960050;background-color:#1e0010">（</span>全地址<span style="color:#960050;background-color:#1e0010">），</span>避免填写的麻烦<span style="color:#f92672">--&gt;</span>
                                <span style="color:#f92672">&lt;</span>classpath<span style="color:#f92672">/&gt;</span>
                                <span style="color:#f92672">&lt;!--</span> argument运行程序是用的参数<span style="color:#960050;background-color:#1e0010">（</span>jvm要启动的类名<span style="color:#960050;background-color:#1e0010">）</span> <span style="color:#f92672">--&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;</span>com<span style="color:#f92672">.</span><span style="color:#a6e22e">Application</span><span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;/</span>arguments<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;/</span>configuration<span style="color:#f92672">&gt;</span>
                    <span style="color:#f92672">&lt;/</span>execution<span style="color:#f92672">&gt;</span>
                    <span style="color:#f92672">&lt;</span>execution<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;!--</span> id用于区分<span style="color:#f92672">--&gt;</span>
                        <span style="color:#f92672">&lt;</span>id<span style="color:#f92672">&gt;</span>start<span style="color:#f92672">-</span>test<span style="color:#f92672">-</span>database<span style="color:#f92672">&lt;/</span>id<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;!--</span> 把这个maven 绑定 在某个 生命周期里运行<span style="color:#f92672">--&gt;</span>
                        <span style="color:#f92672">&lt;</span>phase<span style="color:#f92672">&gt;</span>pre<span style="color:#f92672">-</span>integration<span style="color:#f92672">-</span>test<span style="color:#f92672">&lt;/</span>phase<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;</span>goals<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;!--</span> goal为java表示在java里运行<span style="color:#960050;background-color:#1e0010">，</span>而为exec则是在外部运行<span style="color:#f92672">--&gt;</span>
                            <span style="color:#f92672">&lt;</span>goal<span style="color:#f92672">&gt;</span>exec<span style="color:#f92672">&lt;/</span>goal<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;/</span>goals<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;</span>configuration<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;</span>longModulepath<span style="color:#f92672">&gt;</span><span style="color:#66d9ef">false</span><span style="color:#f92672">&lt;/</span>longModulepath<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;!--</span>executable 用于运行的程序<span style="color:#f92672">--&gt;</span>
                            <span style="color:#f92672">&lt;</span>executable<span style="color:#f92672">&gt;</span>docker<span style="color:#f92672">&lt;/</span>executable<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;!--</span> argument用于docker运行测试数据库 <span style="color:#f92672">--&gt;</span>
                            <span style="color:#f92672">&lt;</span>arguments<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;</span>run<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;--</span>name<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;</span>test<span style="color:#f92672">-</span>mysql<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;-</span>e<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;</span>MYSQL_ROOT_PASSWORD<span style="color:#f92672">=</span>hana<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;-</span>e<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;</span>MYSQL_DATABASE<span style="color:#f92672">=</span>test_user<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;-</span>p<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;</span>3307<span style="color:#f92672">:</span>3306<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;-</span>d<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;</span>mysql<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;/</span>arguments<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;/</span>configuration<span style="color:#f92672">&gt;</span>
                    <span style="color:#f92672">&lt;/</span>execution<span style="color:#f92672">&gt;</span>
                    <span style="color:#f92672">&lt;</span>execution<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;!--</span>因为docker运行后<span style="color:#960050;background-color:#1e0010">，</span>数据库的启动还是需要一点时间的<span style="color:#960050;background-color:#1e0010">，</span>并不能够马上运行起来<span style="color:#960050;background-color:#1e0010">，</span>
                         所以需要等待<span style="color:#960050;background-color:#1e0010">。</span>而且execution的执行顺序是按照声明的顺序执行的<span style="color:#f92672">--&gt;</span>
                        <span style="color:#f92672">&lt;</span>id<span style="color:#f92672">&gt;</span>wait<span style="color:#f92672">-</span>test<span style="color:#f92672">-</span>database<span style="color:#f92672">&lt;/</span>id<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;</span>phase<span style="color:#f92672">&gt;</span>pre<span style="color:#f92672">-</span>integration<span style="color:#f92672">-</span>test<span style="color:#f92672">&lt;/</span>phase<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;</span>goals<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;</span>goal<span style="color:#f92672">&gt;</span>exec<span style="color:#f92672">&lt;/</span>goal<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;/</span>goals<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;</span>configuration<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;</span>longModulepath<span style="color:#f92672">&gt;</span><span style="color:#66d9ef">false</span><span style="color:#f92672">&lt;/</span>longModulepath<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;</span>executable<span style="color:#f92672">&gt;</span>sleep<span style="color:#f92672">&lt;/</span>executable<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;</span>arguments<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;</span>30<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;/</span>arguments<span style="color:#f92672">&gt;</span>

                        <span style="color:#f92672">&lt;/</span>configuration<span style="color:#f92672">&gt;</span>
                    <span style="color:#f92672">&lt;/</span>execution<span style="color:#f92672">&gt;</span>
                    <span style="color:#f92672">&lt;</span>execution<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;!--</span> 用于销毁测试数据库<span style="color:#f92672">--&gt;</span>
                        <span style="color:#f92672">&lt;</span>id<span style="color:#f92672">&gt;</span>teardown<span style="color:#f92672">-</span>test<span style="color:#f92672">-</span>database<span style="color:#f92672">&lt;/</span>id<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;</span>phase<span style="color:#f92672">&gt;</span>post<span style="color:#f92672">-</span>integration<span style="color:#f92672">-</span>test<span style="color:#f92672">&lt;/</span>phase<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;</span>goals<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;</span>goal<span style="color:#f92672">&gt;</span>exec<span style="color:#f92672">&lt;/</span>goal<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;/</span>goals<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;</span>configuration<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;</span>longModulepath<span style="color:#f92672">&gt;</span><span style="color:#66d9ef">false</span><span style="color:#f92672">&lt;/</span>longModulepath<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;</span>executable<span style="color:#f92672">&gt;</span>docker<span style="color:#f92672">&lt;/</span>executable<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;</span>arguments<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;</span>rm<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;-</span>f<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">&lt;</span>argument<span style="color:#f92672">&gt;</span>test<span style="color:#f92672">-</span>mysql<span style="color:#f92672">&lt;/</span>argument<span style="color:#f92672">&gt;</span>
                            <span style="color:#f92672">&lt;/</span>arguments<span style="color:#f92672">&gt;</span>
                        <span style="color:#f92672">&lt;/</span>configuration<span style="color:#f92672">&gt;</span>
                    <span style="color:#f92672">&lt;/</span>execution<span style="color:#f92672">&gt;</span>
                <span style="color:#f92672">&lt;/</span>executions<span style="color:#f92672">&gt;</span>
            <span style="color:#f92672">&lt;/</span>plugin<span style="color:#f92672">&gt;</span>

</code></pre></div><h2 id="jar包">jar包</h2>
<ul>
<li>编译后的代码打包</li>
<li>
<ul>
<li>java 启动方式(两种方式都是一样的，因为jar包里面有清单文件（manifest），文件里面包含mainClass)</li>
</ul>
</li>
</ul>
<ol>
<li>java -classpath mainClass</li>
<li>java -jar jarName.zip/jarName.jar</li>
</ol>
<ul>
<li>jar包和war包区别</li>
<li>
<ul>
<li>jar包本质是一个压缩包，把所以代码打包压缩，运行信息、依赖、内嵌Tomcat等等</li>
</ul>
</li>
<li>
<ul>
<li>war包也是压缩包，但是只包含依赖（资源），没有内嵌Tomcat，不能够运行。如果要运行就要放在servlet容器里面运行</li>
</ul>
</li>
<li>
<ul>
<li>Eg：SpringBoot.jar = war + Tomcat(Servlet容器提供底层HTTP互交)</li>
</ul>
</li>
<li>SpringBoot repackage: 创建一个自动可执行的jar或war文件。它可以替换常规的artifact(手动运行)，或者用一个单独的classifier附属在maven构建的生命周期中，使得程序可以自动执行。</li>
<li>优点：简单可靠</li>
<li>缺点：依赖于JVM环境，虽然碰到问题的概率低</li>
</ul>
<h2 id="部署-1">部署</h2>
<ul>
<li>域名指向服务器IP地址</li>
<li>
<ul>
<li>把Spring xml配置里面的<code>datasource.url</code>更改成IP地址（网域名）
<code>spring.datasource.url = jdbc:mysql://localhost:3306/user</code></li>
</ul>
</li>
</ul>
<h4 id="nginx-监听80端口负载均衡器">NGINX 监听80端口，负载均衡器</h4>
<ul>
<li>
<ul>
<li>流量均分到三个服务器上</li>
</ul>
</li>
<li>
<ul>
<li>NGINX如果出现问题能够在两秒内迅速启动</li>
</ul>
</li>
<li>
<ul>
<li>docker 启动NGINX</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>docker run &ndash;name springboot-nginx restart=always -v <code>pwd</code>/nginx/nginx.conf:/etc/nginx/nginx.conf:ro -d -p 8085:80 nginx</li>
<li>&ndash;restart=always 碰到问题时自动重启</li>
</ul>
</blockquote>
<h4 id="redis-进行缓存">redis 进行缓存</h4>
<ul>
<li>
<ul>
<li>通过docker 启动redis</li>
</ul>
</li>
</ul>
<h4 id="jenkins">jenkins</h4>
<ul>
<li>
<ul>
<li>通过docker 启动 jenkins
<code>docker run -p 8080:8080 -v </code>pwd<code>/jenkins:/var/jenkins_home jenkins/jenkins</code>
``</li>
</ul>
</li>
</ul>
<h4 id="maven-直接运行源代码">maven 直接运行源代码</h4>
<ul>
<li>mvn compile exec:exec</li>
</ul>
<h4 id="jar方式">jar方式</h4>
<ul>
<li>[×] java -jar jarname -Dserver.port=8081</li>
<li>java -Dserver.port=8081 -jar jarName</li>
</ul>
<blockquote>
<ul>
<li>java -Dserver.port=8081 -jar target/spring-boot-0.0.1-SNAPSHOT.jar</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>java -jar 后面程序运行的内容会被传递到jar 包运行的main里面，所以传递port是数据应用成语的参数，-jar 属于java 程序的参数</li>
</ul>
</li>
</ul>
<h4 id="docker-方式">Docker 方式</h4>
<ul>
<li>建立dockerfile</li>
</ul>
<pre><code>FROM openjdk:8u265-slim-buster

RUN mkdir /dockerworkdir

WORKDIR /dockerworkdir

COPY  target/spring-boot-0.0.1-SNAPSHOT.jar /dockerworkdir

EXPOSE 8080

CMD [&quot;java&quot;,&quot;-jar&quot;,&quot;spring-boot-0.0.1-SNAPSHOT.jar&quot;]
</code></pre><ul>
<li><code>docker build .</code></li>
<li>
<ul>
<li>如何修改已经bulid 的镜像</li>
</ul>
</li>
<li>
<ul>
<li>可以把需要更改的配置文件映射给docker 容器</li>
</ul>
</li>
<li>docker run</li>
</ul>
<h2 id="nginx-分布式部署">NGINX 分布式部署</h2>
<ul>
<li>本地nginx.conf 配置分布式</li>
<li>流量的配置取决于nginx，默认的是轮流分配</li>
<li>nginx 能够自动检测没有启动到的服务器，并停止给这个没有启动的服务器分配流量</li>
<li>
<ul>
<li>nginx 监听 80 端口， 所有流量都转发<code>proxy_pass</code></li>
</ul>
</li>
<li>
<ul>
<li>但是docker 和 宿主机是完全隔离的，所以流量直接在docker 里面转是无效的。所以nginx 需要通过局域网来访问（服务器IP地址）</li>
</ul>
</li>
<li>
<ul>
<li>ifconfig 可以获得本机局域网IP地址 -&gt; 本机：192.168.1.7</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>server  192.168.1.7:port;</li>
</ul>
</blockquote>
<ul>
<li>更改过nginx 后需要重启生效</li>
</ul>
<pre><code>events{}
http {
    upstream backend {
        server backend1.example.com;
        server backend2.example.com;
        server 192.0.0.1 backup;
    }
    
    server {
      listen 80;
        location / {
            proxy_pass http://backend;
        }
    }
}
</code></pre><p><a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/">https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/</a></p>
<ul>
<li>docker 启动 nginx</li>
<li>
<ul>
<li>增加<code>--restart=always</code>防止 NGINX 挂掉（重启速度很快，所以不用担心）</li>
</ul>
</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>JAVA IO</title>
            <link>https://procarihana.github.io/public/posts/io/</link>
            <pubDate>Sun, 30 Aug 2020 15:29:44 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/io/</guid>
            <description>cpu 负责所有运算
  3GHz 每秒运行30亿条指令，做一件事情只需要0.38纳秒
   SSD（固态硬盘）：寻址时间太慢了，和CPU形成矛盾     内存：存数据，断电丢失     硬盘（硬盘驱动器） 存数据容量大，断电不丢失    一个文件本质上是一段字节流，由一个执行程序决定怎么执行一段字节流（16进制）
  字节范围 0～255
一切文件的本质  一段字节流：   文本文件（txt/代码/HTML等）     二进制文件   每个程序负责解释文件中的字节流  输入输出是站在程序的角度
InputStream/PutputStream  抽象的输入/输出操作   从文件读取字节流 【实战】    value ==-1 的时候，循环结束
 -从网络读取字节流【实战】 -从其他
最好使用绝对路径
抽象类不能直接实例化，因为抽象类里面包含还没有实现的方法 InputStream…… 这种只是抽象方法，不能够直接实现 用ProcessBuilder建立新的进程  Java中的File   file 代表的是文件路径</description>
            <content type="html"><![CDATA[<ul>
<li>
<p>cpu 负责所有运算</p>
</li>
<li>
<p>3GHz 每秒运行30亿条指令，做一件事情只需要0.38纳秒</p>
</li>
<li>
<ul>
<li>SSD（固态硬盘）：寻址时间太慢了，和CPU形成矛盾</li>
</ul>
</li>
<li>
<ul>
<li>内存：存数据，断电丢失</li>
</ul>
</li>
<li>
<ul>
<li>硬盘（硬盘驱动器） 存数据容量大，断电不丢失</li>
</ul>
</li>
<li>
<p>一个文件本质上是一段字节流，由一个执行程序决定怎么执行一段字节流（16进制）</p>
</li>
</ul>
<p>字节范围 0～255</p>
<h2 id="一切文件的本质">一切文件的本质</h2>
<ul>
<li>一段字节流：</li>
<li>
<ul>
<li>文本文件（txt/代码/HTML等）</li>
</ul>
</li>
<li>
<ul>
<li>二进制文件</li>
</ul>
</li>
<li>每个程序负责解释文件中的字节流</li>
</ul>
<p>输入输出是站在程序的角度</p>
<h2 id="inputstreamputputstream">InputStream/PutputStream</h2>
<ul>
<li>抽象的输入/输出操作</li>
<li>
<ul>
<li>从文件读取字节流 【实战】</li>
</ul>
</li>
</ul>
<p>value ==-1 的时候，循环结束</p>
<ul>
<li>-从网络读取字节流【实战】</li>
<li>-从其他<br>
<strong>最好使用绝对路径</strong><br>
抽象类不能直接实例化，因为抽象类里面包含还没有实现的方法</li>
<li>InputStream…… 这种只是抽象方法，不能够直接实现</li>
<li>用ProcessBuilder建立新的进程</li>
</ul>
<h2 id="java中的file">Java中的File</h2>
<ul>
<li>
<p>file 代表的是文件路径</p>
</li>
<li>
<p>抽象的“文件”：文件或者文件夹</p>
</li>
<li>
<p>File 的常见方法</p>
</li>
<li>
<ul>
<li>
<p>file.exists 判断文件是否存在</p>
<pre><code> .listfile 当前文件下有什么文件
 .isAbsolute 是否是绝对路径
 .getname
 .isDirectory 是否是文件夹
 .getAbsolutePath
 .listFile
</code></pre>
</li>
</ul>
</li>
<li>
<ul>
<li>file.isfile 判断是不是文件</li>
</ul>
</li>
<li>
<ul>
<li>file.isDirectory 判断路径是不是分拣家</li>
</ul>
</li>
<li>
<ul>
<li>getAbsolutePath 获得绝对路径</li>
</ul>
</li>
<li>
<ul>
<li>listfiles 查看当前文件夹下面有什么文件</li>
</ul>
</li>
<li>
<ul>
<li>new File（目录名字，子目录的名字）快速构建一个新的子目录</li>
</ul>
</li>
<li>
<ul>
<li>file.walkFileTree 遍历</li>
</ul>
</li>
<li>
<ul>
<li>readAllLine（不用依赖第三方库）</li>
</ul>
</li>
<li>
<p>绝对路径与相对路径</p>
</li>
<li>
<ul>
<li>相对路径只有在相对一个路径时候才有效</li>
</ul>
</li>
<li>
<ul>
<li>相对的就是JVM进程的当前工作目录</li>
</ul>
</li>
<li>
<ul>
<li>绝对路径只会对应一个文件</li>
</ul>
</li>
<li>
<p>读/写文件</p>
</li>
<li>
<ul>
<li>解决IO速度慢</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>BufferReader/Writer</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>换行符</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>BufferReader - 一次性读好多东西到缓冲区里面</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>BufferWriter - 一次性写好多东西</li>
</ul>
</li>
</ul>
</li>
<li>
<p>NIO的Path（Java 7+）
LInxu 硬连接和软连接</p>
</li>
<li>
<p>New IO 新的IO</p>
</li>
<li>
<p>Non -blocking IO 非阻塞IO</p>
</li>
<li>
<p>NIO的Path - 就是旧版本的File</p>
</li>
<li>
<ul>
<li>经典的IO模型基于流</li>
</ul>
</li>
<li>
<ul>
<li>优点：容易理解，方便抽象</li>
</ul>
</li>
<li>
<ul>
<li>缺点：慢（流：一个字节一个字节按顺序）</li>
</ul>
</li>
</ul>
<h2 id="解决io太慢">解决IO太慢</h2>
<ul>
<li>BufferedReader/Writer</li>
<li>
<ul>
<li>BufferedReader - ⼀次性读取好多东⻄到缓冲区⾥</li>
</ul>
</li>
<li>
<ul>
<li>BufferedWriter - ⼀次性写好多东⻄到缓冲区⾥</li>
</ul>
</li>
<li>在内存中创建好，⼀次写⼊</li>
</ul>
<p>path.tofile &ndash;
file.topath
两个东西相互转换</p>
<p>Buffer是一个缓冲区，是内存的一块</p>
<p>块和块之间是没有顺序的，所以可以同时写</p>
<p>写入：</p>
<ol>
<li>一个一个字节地写</li>
<li>存一些后一次性写入（并发；多线程）//CPU在等待IO的时候做其他事情</li>
</ol>
<h2 id="homework">HomeWork</h2>
<h4 id="多种方法写入读出">多种方法写入读出</h4>
<ul>
<li>Apache Commons IO</li>
<li>
<ul>
<li>通过·FilesUtils.readFileToString<code>读取</code>writeStringToFile`写入</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">readFile2</span><span style="color:#f92672">(</span>File file<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>FileUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">readFileToString</span><span style="color:#f92672">(</span>file<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;utf8&#34;</span><span style="color:#f92672">).</span><span style="color:#a6e22e">split</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;\n&#34;</span><span style="color:#f92672">));</span>
    <span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">writeLinesToFile2</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> lines<span style="color:#f92672">,</span> File file<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        String result <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>String s <span style="color:#f92672">:</span> lines<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            result <span style="color:#f92672">+=</span> s<span style="color:#f92672">;</span>
            result <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;\n&#34;</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        FileUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">writeStringToFile</span><span style="color:#f92672">(</span>file<span style="color:#f92672">,</span> result<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;utf8&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>FileInputStream 和FileOutPutStream</li>
<li>
<ul>
<li>注意getByte 得到的是字节流</li>
</ul>
</li>
<li>
<ul>
<li>读取迭代的过程中，要记得readInt 需要不断地从fileInputStream里面读入，否则就会一直只读第一个字节，变成死循环</li>
</ul>
</li>
<li>
<ul>
<li>InputStream 结束的标志就是<code>-1</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">readFile1</span><span style="color:#f92672">(</span>File file<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        FileInputStream fileInputStream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span>file<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> readInt <span style="color:#f92672">=</span> fileInputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">();</span>
        String s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>readInt <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            s <span style="color:#f92672">+=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">char</span><span style="color:#f92672">)</span> readInt<span style="color:#f92672">;</span>
            readInt <span style="color:#f92672">=</span> fileInputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
        fileInputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">return</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">split</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;\n&#34;</span><span style="color:#f92672">));</span>
    <span style="color:#f92672">}</span>

  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">writeLinesToFile1</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> lines<span style="color:#f92672">,</span> File file<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        FileOutputStream fileOutputStream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span>file<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>String s <span style="color:#f92672">:</span> lines<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> bytes <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">();</span>
            fileOutputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>bytes<span style="color:#f92672">);</span>
            fileOutputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;\n&#39;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        fileOutputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>BufferReader和BufferWriter</li>
<li>
<ul>
<li>BufferReader 继承 Reader ，而Reader 实现closeable 接口，所以BufferReader 需要关闭</li>
</ul>
</li>
<li>
<ul>
<li>BufferReader 是有锁的，所以是线程安全的方法</li>
</ul>
</li>
<li>
<ul>
<li>BufferReader.readLine()只是read一行，所以要记得用循环</li>
</ul>
</li>
<li>
<ul>
<li>BufferReader.readLine()到达末尾的时候会返回null，如果直接用是否为null判断是否结束的话，会造成死循环（readline不断地返回null），要用一个变量来接受方法的返回值来间接判断。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">readFile1</span><span style="color:#f92672">(</span>File file<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;();</span>
        String readLines<span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">();</span>
        String checkReadLine <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>BufferedReader bufferedReader <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedReader<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileReader<span style="color:#f92672">(</span>file<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>checkReadLine <span style="color:#f92672">=</span> bufferedReader<span style="color:#f92672">.</span><span style="color:#a6e22e">readLine</span><span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
               readLines <span style="color:#f92672">+=</span> checkReadLine<span style="color:#f92672">;</span>
               readLines <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;\n&#34;</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            result <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>readLines<span style="color:#f92672">.</span><span style="color:#a6e22e">split</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;\n&#34;</span><span style="color:#f92672">));</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">writeLinesToFile1</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> lines<span style="color:#f92672">,</span> File file<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        BufferedWriter bufferedWriter <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedWriter<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileWriter<span style="color:#f92672">(</span>file<span style="color:#f92672">));</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>String s <span style="color:#f92672">:</span> lines<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            bufferedWriter<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>       
</code></pre></div><ul>
<li>使用Java 7+的NIO引入的<code>Files.readAllBytes()</code>/<code>Files.readAllLines()</code>/<code>Files.write()</code>方法</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">readFile3</span><span style="color:#f92672">(</span>File file<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> Files<span style="color:#f92672">.</span><span style="color:#a6e22e">readAllLines</span><span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">toPath</span><span style="color:#f92672">());</span>
    <span style="color:#f92672">}</span> 
       <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">writeLinesToFile3</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> lines<span style="color:#f92672">,</span> File file<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        Files<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">toPath</span><span style="color:#f92672">(),</span> lines<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>实现</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">   <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
       File projectDir <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">getProperty</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;basedir&#34;</span><span style="color:#f92672">,</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">getProperty</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;user.dir&#34;</span><span style="color:#f92672">)));</span>
       File testFile <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span>projectDir<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;target/test.txt&#34;</span><span style="color:#f92672">);</span>
       List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> lines <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;AAA&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;BBB&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;CCC&#34;</span><span style="color:#f92672">);</span>
       writeLinesToFile1<span style="color:#f92672">(</span>lines<span style="color:#f92672">,</span> testFile<span style="color:#f92672">);</span>
       writeLinesToFile2<span style="color:#f92672">(</span>lines<span style="color:#f92672">,</span> testFile<span style="color:#f92672">);</span>
       writeLinesToFile3<span style="color:#f92672">(</span>lines<span style="color:#f92672">,</span> testFile<span style="color:#f92672">);</span>

       System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>readFile1<span style="color:#f92672">(</span>testFile<span style="color:#f92672">));</span>
       System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>readFile2<span style="color:#f92672">(</span>testFile<span style="color:#f92672">));</span>
       System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>readFile3<span style="color:#f92672">(</span>testFile<span style="color:#f92672">));</span>
       <span style="color:#f92672">}</span>
   <span style="color:#f92672">}</span>
</code></pre></div><h4 id="读取网络内容csvfile">读取网络内容———&gt;csvFile</h4>
<ul>
<li>csvFile：逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。 纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据。</li>
<li>爬取github 信息可以用 GitHub 库的 connectAnonumously匿名链接去爬取</li>
<li>用GHRespository 来获得github仓库的名字</li>
<li>通过GHPullRequest 来发出pull请求，获得仓库的内容,用GHPullRequest里面get的方法来过滤内容</li>
<li>
<ul>
<li>getUser（）获得的是GitHub User 的内容，需要getLogin（）才能够过滤出用户名字</li>
</ul>
</li>
<li>
<ul>
<li>在过滤的过程中要手动添加&rdquo;,&ldquo;来分隔内容，达到csvFile 的要求</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 给定一个仓库名，例如&#34;golang/go&#34;，或者&#34;gradle/gradle&#34;，读取前n个Pull request并保存至csvFile指定的文件中，格式如下：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// number,author,title
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 12345,blindpirate,这是一个标题
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 12345,FrankFang,这是第二个标题
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">savePullRequestsToCSV</span><span style="color:#f92672">(</span>String repo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> File csvFile<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        GitHub github <span style="color:#f92672">=</span> GitHub<span style="color:#f92672">.</span><span style="color:#a6e22e">connectAnonymously</span><span style="color:#f92672">();</span>
        GHRepository repository <span style="color:#f92672">=</span> github<span style="color:#f92672">.</span><span style="color:#a6e22e">getRepository</span><span style="color:#f92672">(</span>repo<span style="color:#f92672">);</span>
        List<span style="color:#f92672">&lt;</span>GHPullRequest<span style="color:#f92672">&gt;</span> pullRequests <span style="color:#f92672">=</span> repository<span style="color:#f92672">.</span><span style="color:#a6e22e">getPullRequests</span><span style="color:#f92672">(</span>GHIssueState<span style="color:#f92672">.</span><span style="color:#a6e22e">OPEN</span><span style="color:#f92672">);</span>

        String title <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;number,author,title&#34;</span><span style="color:#f92672">;</span>
        List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> lines <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
        List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> body <span style="color:#f92672">=</span> pullRequests<span style="color:#f92672">.</span><span style="color:#a6e22e">stream</span><span style="color:#f92672">().</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>Crawler<span style="color:#f92672">::</span>getLine<span style="color:#f92672">).</span><span style="color:#a6e22e">collect</span><span style="color:#f92672">(</span>Collectors<span style="color:#f92672">.</span><span style="color:#a6e22e">toList</span><span style="color:#f92672">());</span>
        lines<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>title<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            lines<span style="color:#f92672">.</span><span style="color:#a6e22e">addAll</span><span style="color:#f92672">(</span>Collections<span style="color:#f92672">.</span><span style="color:#a6e22e">singleton</span><span style="color:#f92672">(</span>body<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)));</span>
        <span style="color:#f92672">}</span>


        Files<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>csvFile<span style="color:#f92672">.</span><span style="color:#a6e22e">toPath</span><span style="color:#f92672">(),</span> lines<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">static</span> String <span style="color:#a6e22e">getLine</span><span style="color:#f92672">(</span>GHPullRequest pullRequest<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span> pullRequest<span style="color:#f92672">.</span><span style="color:#a6e22e">getNumber</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;,&#34;</span> <span style="color:#f92672">+</span> pullRequest<span style="color:#f92672">.</span><span style="color:#a6e22e">getUser</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getLogin</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;,&#34;</span> <span style="color:#f92672">+</span> pullRequest<span style="color:#f92672">.</span><span style="color:#a6e22e">getTitle</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> UncheckedIOException<span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>计算机网络TCP and Socket</title>
            <link>https://procarihana.github.io/public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Ctcp-and-socket/</link>
            <pubDate>Sun, 30 Aug 2020 11:39:13 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Ctcp-and-socket/</guid>
            <description>没有100%可靠的通信协议  红军/蓝军 计算机网络：虚电路分组，A服务器把报文给离目标IP最近的力所能及的设备（过程为HOP），这个设备再把报文发给下一个设备，如果中间某个最佳的设备被毁，就选择另一个设备绕过，直到到达目标IP（快递发货）   网络分层模型  TCP/IP模型（应用层、传输层【四层交换机、四层路由器】、网络层【路由器，三层交换机】） TCP Transmisson Control ProTocal 传输控制协议   TCP的握手与断开       三次握手建立连接        SYN SENT seq = x 发送请求建立连接的请求 -&amp;gt; 获得SYN seq=y,ACK x+1 （同意建立请求） ACK =y+1 表明收到同意建立连接 ==&amp;gt; 连接建立，        四次挥手断开连接        FIN seq = x+2 ACK = y+1发送断链接的请求 -&amp;gt; 获得ACK x+3 表示收到，又获得 FIN seq= y+1 表示断开链接 ACK = y+2 表示收到同意断开链接        如果中间有信息丢掉没有成功收到，会通过请求超时来知道链接断开成功     TCP 协议无法传递数据包，只能把所有数据包拆、黏包   TCP 没有规定包的界限，需要自己设计协议、分隔符、结束符来设计包的边界   TCP 中的数据包含TCP 包首部和数据两个部分，而IP中的数据包含前两个部分，在加上IP包首部 TCP 只有两个字节的端口（65536），端口数量有限制（同时使用），而每个端口访问的对象是不限制   TCP数据里面有确认号码，如果接受的没有收到，就需要重传。校验和可以检验数据是否有被串改，如果有则向发送的一方放再次发送请求 的   以太网则在IP数据的基础杀昂添加以太网包首部 TCP特点   面向连接     点对点 需要有目标端口     可靠交付 校验和、序列号码、确认号码 保证数据正确     面向字节流   UDP 协议（用于视频）   无连接的 无法保证数据是否到达     尽最大可能交付     面向报文的    Scoket  TCP包含客户端和服务器双方的ip和port。这四个元素是四元组（client的src源ip、port和dest目标ip。port），也就是socket/socket的链接。   ip &amp;ndash;&amp;gt; 唯一确定一台计算机，port &amp;ndash;&amp;gt; 端口可以唯一确定监听端口的一个程序   socket 只要制定目标ip和port 就可以发送信息，自身ip会自动提供，如果有指定的port就会使用，如果没有就会自动挑选一个空闲的端口   查询网站ip地址： $ nslookup + 地址    public class SocketTest { public static void main(String[] args) throws IOException { Socket socket = new Socket(&amp;#34;182.</description>
            <content type="html"><![CDATA[<h2 id="没有100可靠的通信协议">没有100%可靠的通信协议</h2>
<ul>
<li>红军/蓝军</li>
<li>计算机网络：虚电路分组，A服务器把报文给离目标IP最近的力所能及的设备（过程为HOP），这个设备再把报文发给下一个设备，如果中间某个最佳的设备被毁，就选择另一个设备绕过，直到到达目标IP（快递发货）</li>
<li></li>
</ul>
<h2 id="网络分层模型">网络分层模型</h2>
<ul>
<li>TCP/IP模型（应用层、传输层【四层交换机、四层路由器】、网络层【路由器，三层交换机】）</li>
<li>TCP Transmisson Control ProTocal 传输控制协议</li>
<li>
<ul>
<li>TCP的握手与断开</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>三次握手建立连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>SYN SENT seq = x</code> 发送请求建立连接的请求 -&gt; 获得<code>SYN seq=y,ACK x+1</code> （同意建立请求）</li>
<li><code>ACK =y+1</code> 表明收到同意建立连接 ==&gt; 连接建立，</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>
<ul>
<li>四次挥手断开连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>FIN seq = x+2 ACK = y+1</code>发送断链接的请求 -&gt; 获得<code>ACK x+3</code> 表示收到，又获得 <code>FIN seq= y+1</code> 表示断开链接</li>
<li><code>ACK = y+2</code> 表示收到同意断开链接</li>
</ul>
</blockquote>
<ul>
<li>
<ul>
<li>
<ul>
<li>如果中间有信息丢掉没有成功收到，会通过请求超时来知道链接断开成功</li>
</ul>
</li>
</ul>
</li>
<li>TCP 协议无法传递数据包，只能把所有数据包拆、黏包</li>
<li>
<ul>
<li>TCP 没有规定包的界限，需要自己设计协议、分隔符、结束符来设计包的边界</li>
</ul>
</li>
<li>TCP 中的数据包含TCP 包首部和数据两个部分，而IP中的数据包含前两个部分，在加上IP包首部</li>
<li>TCP 只有两个字节的端口（65536），端口数量有限制（同时使用），而每个端口访问的对象是不限制</li>
<li>
<ul>
<li>TCP数据里面有确认号码，如果接受的没有收到，就需要重传。校验和可以检验数据是否有被串改，如果有则向发送的一方放再次发送请求
的</li>
</ul>
</li>
<li>以太网则在IP数据的基础杀昂添加以太网包首部</li>
<li>TCP特点</li>
<li>
<ul>
<li>面向连接</li>
</ul>
</li>
<li>
<ul>
<li>点对点 需要有目标端口</li>
</ul>
</li>
<li>
<ul>
<li>可靠交付 校验和、序列号码、确认号码 保证数据正确</li>
</ul>
</li>
<li>
<ul>
<li>面向字节流</li>
</ul>
</li>
<li>UDP 协议（用于视频）</li>
<li>
<ul>
<li>无连接的 无法保证数据是否到达</li>
</ul>
</li>
<li>
<ul>
<li>尽最大可能交付</li>
</ul>
</li>
<li>
<ul>
<li>面向报文的</li>
</ul>
</li>
</ul>
<h2 id="scoket">Scoket</h2>
<ul>
<li>TCP包含客户端和服务器双方的ip和port。这四个元素是四元组（client的src源ip、port和dest目标ip。port），也就是socket/socket的链接。</li>
<li>
<ul>
<li>ip &ndash;&gt; 唯一确定一台计算机，port &ndash;&gt; 端口可以唯一确定监听端口的一个程序</li>
</ul>
</li>
<li>socket 只要制定目标ip和port 就可以发送信息，自身ip会自动提供，如果有指定的port就会使用，如果没有就会自动挑选一个空闲的端口</li>
<li>
<ul>
<li>查询网站ip地址： $ nslookup + 地址</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SocketTest</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        Socket socket <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Socket<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;182.61.200.7&#34;</span><span style="color:#f92672">,</span>443<span style="color:#f92672">);</span>
        socket<span style="color:#f92672">.</span><span style="color:#a6e22e">getOutputStream</span><span style="color:#f92672">().</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<p>Socket 里传输速Http 协议</p>
</li>
<li>
<ul>
<li>抵达服务器地第一个字节一定时是<code>G</code>之后是<code>E</code>、<code>T</code>、<code>0x20</code></li>
</ul>
</li>
<li>
<ul>
<li>按照HTTP协议格式的规定，给服务器返回字节流，就能够手写出HTTP服务器</li>
</ul>
</li>
<li>
<ul>
<li>请求行：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>请求方法</th>
<th><code>|</code>空格</th>
<th><code>|</code>URL方法</th>
<th><code>|</code>空格</th>
<th><code>|</code>协议版本</th>
<th><code>|</code>回车符（\r）</th>
<th><code>|</code>换行符（\n）</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
</table>
<ul>
<li>
<ul>
<li>请求头部：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>头部字段名</th>
<th><code>|</code>：</th>
<th><code>|</code>value</th>
<th><code>|</code>\r</th>
<th><code>|</code>\n</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>……</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>头部字段名</td>
<td><code>|</code>：</td>
<td><code>|</code>value</td>
<td><code>|</code>\r</td>
<td><code>|</code>\n</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>\r</td>
<td><code>|</code>\n</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>
<ul>
<li>请求数据</li>
</ul>
</li>
<li>手写HTTP协议</li>
<li>
<ul>
<li>本地环回网络接口：127.0.0.1。 能够通过这个接口访问自己的机器</li>
</ul>
</li>
<li>
<ul>
<li><code>socker.accept()</code>执行后要是没有设置返回或者没有下一步的操作，就会一直停在那里阻塞，返回的是一个socket。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SocketTest</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> port <span style="color:#f92672">=</span> 8080<span style="color:#f92672">;</span>
        ServerSocket serverSocket <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ServerSocket<span style="color:#f92672">();</span>
         serverSocket<span style="color:#f92672">.</span><span style="color:#a6e22e">bind</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> InetSocketAddress<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;127.0.0.1&#34;</span><span style="color:#f92672">,</span>port<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>serverSocket<span style="color:#f92672">.</span><span style="color:#a6e22e">accept</span><span style="color:#f92672">());</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
serverSocket<span style="color:#f92672">.</span><span style="color:#a6e22e">accept</span><span style="color:#f92672">()</span><span style="color:#960050;background-color:#1e0010">：</span>Socket<span style="color:#f92672">[</span>addr<span style="color:#f92672">=/</span>127<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">.</span><span style="color:#a6e22e">1</span><span style="color:#f92672">,</span>port<span style="color:#f92672">=</span>54777<span style="color:#f92672">,</span>localport<span style="color:#f92672">=</span>8080<span style="color:#f92672">]</span>

</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SocketTest</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> port <span style="color:#f92672">=</span> 8080<span style="color:#f92672">;</span>
        ServerSocket serverSocket <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ServerSocket<span style="color:#f92672">();</span>
        serverSocket<span style="color:#f92672">.</span><span style="color:#a6e22e">bind</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> InetSocketAddress<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;127.0.0.1&#34;</span><span style="color:#f92672">,</span> port<span style="color:#f92672">));</span>
        Socket socket <span style="color:#f92672">=</span> serverSocket<span style="color:#f92672">.</span><span style="color:#a6e22e">accept</span><span style="color:#f92672">();</span>
        BufferedReader bufferedReader <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedReader<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> InputStreamReader<span style="color:#f92672">(</span>socket<span style="color:#f92672">.</span><span style="color:#a6e22e">getInputStream</span><span style="color:#f92672">()));</span>
        String line <span style="color:#f92672">=</span> bufferedReader<span style="color:#f92672">.</span><span style="color:#a6e22e">readLine</span><span style="color:#f92672">();</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>line<span style="color:#f92672">);</span>
        <span style="color:#75715e">//HTTP response header
</span><span style="color:#75715e"></span>        socket<span style="color:#f92672">.</span><span style="color:#a6e22e">getOutputStream</span><span style="color:#f92672">().</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;HTTP/1.1 200OK\r\n&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">());</span>
        <span style="color:#75715e">//HTTP response header/body 分隔符
</span><span style="color:#75715e"></span>        socket<span style="color:#f92672">.</span><span style="color:#a6e22e">getOutputStream</span><span style="color:#f92672">().</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;\r\n&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">());</span>
        <span style="color:#75715e">//HTTP response body
</span><span style="color:#75715e"></span>        socket<span style="color:#f92672">.</span><span style="color:#a6e22e">getOutputStream</span><span style="color:#f92672">().</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hello!&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">());</span>

        <span style="color:#75715e">//清理缓冲区，避免堵在缓冲区没有执行
</span><span style="color:#75715e"></span>        socket<span style="color:#f92672">.</span><span style="color:#a6e22e">getOutputStream</span><span style="color:#f92672">().</span><span style="color:#a6e22e">flush</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Spring Web</title>
            <link>https://procarihana.github.io/public/posts/spring-web/</link>
            <pubDate>Mon, 06 Jul 2020 15:29:45 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/spring-web/</guid>
            <description>Web 和 HTTP  Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。  从零开始⼀个Spring应⽤ • pom.xml • src/main/java/hello/Application.java • src/main/java/hello/HelloController.java
Query String 最简单的HTTP请求（查询字符串），就是</description>
            <content type="html"><![CDATA[<h2 id="web-和-http">Web 和 HTTP</h2>
<ul>
<li>Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。</li>
</ul>
<p>从零开始⼀个Spring应⽤
• pom.xml
• src/main/java/hello/Application.java
• src/main/java/hello/HelloController.java</p>
<p>Query String 最简单的HTTP请求（查询字符串），就是</p>
]]></content>
        </item>
        
        <item>
            <title>HTML 标签</title>
            <link>https://procarihana.github.io/public/posts/html-%E6%A0%87%E7%AD%BE/</link>
            <pubDate>Sat, 04 Jul 2020 17:11:23 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/html-%E6%A0%87%E7%AD%BE/</guid>
            <description>A标签  作用   跳转外部页面     跳转内部锚点     跳转到邮箱或电话等    href  超级链接  &amp;lt;body&amp;gt; &amp;lt;a herf = &amp;#34;https://google.com&amp;#34; target=&amp;#34;_blank&amp;#34; download&amp;gt;超链&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; target  在哪个窗口打开超级链接   在空白页打开超级链接     在    download rel=noopener target  在哪个窗口打开超级链接   在空白页打开    &amp;lt;a href=&amp;#34;//goole.com&amp;#34; target=_blank&amp;gt;top&amp;lt;/a&amp;gt;    在顶层打开链接（正常打开链接）&amp;ndash; top     在本层打开（Google 不允许用iframe指向，所以打不开，如果可以打开，则可以再其他页面直接打开）    如何在编辑过程中正确打开html  http-server   安装    $ yarn global add http-server   启动并点击任一网址，要编写路径</description>
            <content type="html"><![CDATA[<h2 id="a标签">A标签</h2>
<ul>
<li>作用</li>
<li>
<ul>
<li>跳转外部页面</li>
</ul>
</li>
<li>
<ul>
<li>跳转内部锚点</li>
</ul>
</li>
<li>
<ul>
<li>跳转到邮箱或电话等</li>
</ul>
</li>
</ul>
<h5 id="href">href</h5>
<ul>
<li>超级链接</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">   &lt;<span style="color:#f92672">body</span>&gt;
   &lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">herf </span><span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://google.com&#34;</span> <span style="color:#a6e22e">target</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;_blank&#34;</span> <span style="color:#a6e22e">download</span>&gt;超链&lt;/<span style="color:#f92672">a</span>&gt;
   &lt;/<span style="color:#f92672">body</span>&gt;
</code></pre></div><p><img src="/href.jpg" alt=""></p>
<h5 id="target">target</h5>
<ul>
<li>在哪个窗口打开超级链接</li>
<li>
<ul>
<li>在空白页打开超级链接</li>
</ul>
</li>
<li>
<ul>
<li>在</li>
</ul>
</li>
</ul>
<h5 id="download">download</h5>
<h5 id="relnoopener">rel=noopener</h5>
<h2 id="target-1">target</h2>
<ul>
<li>在哪个窗口打开超级链接</li>
<li>
<ul>
<li>在空白页打开</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">href</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;//goole.com&#34;</span> <span style="color:#a6e22e">target</span><span style="color:#f92672">=</span><span style="color:#e6db74">_blank</span>&gt;top&lt;/<span style="color:#f92672">a</span>&gt;
</code></pre></div><ul>
<li>
<ul>
<li>在顶层打开链接（正常打开链接）&ndash;
<!-- raw HTML omitted -->top<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<ul>
<li>在本层打开（Google 不允许用iframe指向，所以打不开，如果可以打开，则可以再其他页面直接打开）</li>
</ul>
</li>
</ul>
<h2 id="如何在编辑过程中正确打开html">如何在编辑过程中正确打开html</h2>
<ul>
<li>http-server</li>
<li>
<ul>
<li>安装</li>
</ul>
</li>
</ul>
<pre><code>$ yarn global add http-server  
</code></pre><ul>
<li>
<p>启动并点击任一网址，要编写路径</p>
</li>
<li>
<ul>
<li>
<p>. (空格点空格【可省略】)-c（缓存 ）-1</p>
<p><img src="/http-server.png" alt=""></p>
</li>
</ul>
</li>
<li>
<ul>
<li>点击其中一个网址</li>
</ul>
</li>
<li>
<ul>
<li>
<p>打开并添加路径（所在文件名）</p>
<p><img src="/http-server2.png" alt=""></p>
</li>
</ul>
</li>
<li>
<p>parcel</p>
</li>
<li>
<ul>
<li>安装</li>
</ul>
</li>
</ul>
<pre><code>$ yarn global add parcel
</code></pre><ul>
<li>
<ul>
<li>启动
<img src="/parcel2.png" alt=""></li>
</ul>
</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Java面向对象————多态</title>
            <link>https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</link>
            <pubDate>Mon, 11 May 2020 17:20:16 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</guid>
            <description>面向对象的三大特征 封装 继承 多态 多态：不同类的不同的实现方法
 方法名字变量都一样，但是子类继承后的实现不一样  重载：两个类同一个方法的不同实现,根据最接近的类型进行匹配
 方法名相同，参数表不一样  多态 实例方法本身是多态的 实例：一个方法不是静态的就是实例方法
通过区分有无Statci
 在运行时根据this（当前对象的实际类型）来决定调用哪个方法 []方法接收者  obj.method(1)
消息接受者.消息（参数）//接受者会根据消息的不同自行决定如何响应消息
 静态方法没有多态 参数静态绑定，接受者动态绑定 覆盖：重写父类中的方法，方法名、参数不能改变，但是返回值可以改变   多态只对方法的接受者生效     多态只选择接受者的类型，不选择参数的类型    public class Base { public void print(ParamBase param) { System.out.println(&amp;#34;I am Base,the param is ParamBase&amp;#34;); } public void print(ParamSub param){ System.out.println(&amp;#34;I am Base,the param is ParamSub&amp;#34;); } } public class Sub extends Base { @Override public void print(ParamBase param){ System.</description>
            <content type="html"><![CDATA[<h2 id="面向对象的三大特征">面向对象的三大特征</h2>
<h5 id="封装">封装</h5>
<h5 id="继承">继承</h5>
<h5 id="多态">多态</h5>
<p>多态：不同类的不同的实现方法</p>
<pre><code>  方法名字变量都一样，但是子类继承后的实现不一样
</code></pre>
<p>重载：两个类同一个方法的不同实现,根据最接近的类型进行匹配</p>
<pre><code>  方法名相同，参数表不一样
</code></pre>
<h2 id="多态-1">多态</h2>
<h5 id="实例方法本身是多态的">实例方法本身是多态的</h5>
<p>实例：一个方法不是静态的就是实例方法<br>
通过区分有无Statci</p>
<ul>
<li>在运行时根据this（当前对象的实际类型）来决定调用哪个方法
[]方法接收者</li>
</ul>
<p>obj.method(1)</p>
<p>消息接受者.消息（参数）//接受者会根据消息的不同自行决定如何响应消息</p>
<ul>
<li>静态方法没有多态</li>
<li>参数静态绑定，接受者动态绑定
覆盖：重写父类中的方法，方法名、参数不能改变，但是返回值可以改变</li>
<li>
<ul>
<li>多态只对方法的接受者生效</li>
</ul>
</li>
<li>
<ul>
<li>多态只选择接受者的类型，不选择参数的类型</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>ParamBase param<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;I am Base,the param is ParamBase&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span>  <span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>ParamSub param<span style="color:#f92672">){</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;I am Base,the param is ParamSub&#34;</span><span style="color:#f92672">);</span>
         <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>


    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Sub</span> <span style="color:#66d9ef">extends</span> Base <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>ParamBase param<span style="color:#f92672">){</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;I am Sub,the param is ParamBase&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>ParamSub param<span style="color:#f92672">){</span>
    <span style="color:#75715e">//方法名一样，参数不一样（重载），但是两个又互为父子类，有继承关系
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;I am Sub,the param is ParamSub&#34;</span><span style="color:#f92672">);</span>
       <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
   
<span style="color:#960050;background-color:#1e0010">```</span>java 
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
       <span style="color:#75715e">//声明一个父类的对象，但是建立一个子类的对像，因为任何的子类都是父类的成员
</span><span style="color:#75715e"></span>        Base object <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Sub<span style="color:#f92672">();</span>
        
        <span style="color:#75715e">//声明一个父类的参数，但是创建一个子类的产数给他
</span><span style="color:#75715e"></span>        ParamBase param <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ParamSub<span style="color:#f92672">();</span>
      
        object<span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>param<span style="color:#f92672">);</span>
        <span style="color:#75715e">/*消息的接受者是多态类型的，有继承类，参数也同样有父子关系
</span><span style="color:#75715e">        消息的接受者通过动态绑定为子类object，
</span><span style="color:#75715e">        所以调用的是子类的方法。
</span><span style="color:#75715e">        而子类的方法是多态，又因为方法是在编译时期由参数的类型静态绑定的
</span><span style="color:#75715e">        在ParamBase param = new ParamSub();虽然用的是子类的变量，但是设定的是父类的变量类型，所以父类的最接近的类，根据重载选择最适合的原则选择执行父类，
</span><span style="color:#75715e">        所以调用的是子类中的public void print(ParamSub param)
</span><span style="color:#75715e">        */</span>
    <span style="color:#f92672">}</span>

<span style="color:#f92672">-</span> 例子
<span style="color:#f92672">-</span> <span style="color:#f92672">-</span> Shape的多态
<span style="color:#f92672">-</span> <span style="color:#f92672">-</span> HashSet<span style="color:#f92672">.</span><span style="color:#a6e22e">addAll</span><span style="color:#f92672">()</span>  


<span style="color:#960050;background-color:#1e0010">##</span> 设计模式实战<span style="color:#960050;background-color:#1e0010">：</span>策略模式
让代码更加简洁


    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PriceCalculator</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 使用策略模式重构这个方法，实现三个策略：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// NoDiscountStrategy 不打折
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Discount95Strategy 全场95折
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// OnlyVipDiscountStrategy 只有VIP打95折，其他人保持原价
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 重构后的方法签名：
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">calculatePrice</span><span style="color:#f92672">(</span>DiscountStrategy strategy<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> price<span style="color:#f92672">,</span> User user<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> strategy<span style="color:#f92672">.</span><span style="color:#a6e22e">discount</span><span style="color:#f92672">(</span>price<span style="color:#f92672">,</span>user<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">---</span> 
         <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">calculatePrice</span><span style="color:#f92672">(</span>String discountStrategy<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> price<span style="color:#f92672">,</span> User user<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">switch</span> <span style="color:#f92672">(</span>discountStrategy<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;NoDiscount&#34;</span><span style="color:#f92672">:</span>
                    <span style="color:#66d9ef">return</span> price<span style="color:#f92672">;</span>
                <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;Discount95&#34;</span><span style="color:#f92672">:</span>
                    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>price <span style="color:#f92672">*</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">95</span><span style="color:#f92672">);</span>
                <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;OnlyVip&#34;</span><span style="color:#f92672">:</span>
                    <span style="color:#f92672">{</span>
                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>user<span style="color:#f92672">.</span><span style="color:#a6e22e">isVip</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
                            <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>price <span style="color:#f92672">*</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">95</span><span style="color:#f92672">);</span>
                        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                            <span style="color:#66d9ef">return</span> price<span style="color:#f92672">;</span>
                        <span style="color:#f92672">}</span>
                   <span style="color:#f92672">}</span>
               <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
                   <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalStateException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Should not be here!&#34;</span><span style="color:#f92672">);</span>
                   

<span style="color:#f92672">-</span> 策略和业务分离



    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">User</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> String name<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> vip<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">User</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> vip<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">vip</span> <span style="color:#f92672">=</span> vip<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> User <span style="color:#a6e22e">vip</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> User<span style="color:#f92672">(</span>name<span style="color:#f92672">,</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> User <span style="color:#a6e22e">dios</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> User<span style="color:#f92672">(</span>name<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> name<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isVip</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> vip<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>线程池策略：（解耦合）</li>
</ul>
<ol>
<li>放弃</li>
<li>让线程者执行</li>
<li>把最久的策略丢弃</li>
<li>把新的策略丢弃</li>
</ol>
<h5 id="策略模式例子打折策略">策略模式例子：打折策略</h5>
<ul>
<li>涉及金钱的时候不能够用Double；</li>
<li>Price * 100 当成分，用int处理</li>
<li>BigDecim 大的十进制（十进制精确的表述，小数的计算）</li>
</ul>
<h5 id="jdk线程池中的策略threadpoolexecutor">JDK线程池中的策略THreadPoolExecutor</h5>
<h2 id="多态实战">多态实战</h2>
<ul>
<li>Files.walkFileTree</li>
</ul>
<p>不想把接口的所有方法都实现，都要查找他的默认实现</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FileFilter</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        Path projectDir <span style="color:#f92672">=</span> Paths<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">getProperty</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;user.dir&#34;</span><span style="color:#f92672">));</span>
        Path testRootDir <span style="color:#f92672">=</span> projectDir<span style="color:#f92672">.</span><span style="color:#a6e22e">resolve</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;test-root&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>testRootDir<span style="color:#f92672">.</span><span style="color:#a6e22e">toFile</span><span style="color:#f92672">().</span><span style="color:#a6e22e">isDirectory</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalStateException<span style="color:#f92672">(</span>testRootDir<span style="color:#f92672">.</span><span style="color:#a6e22e">toAbsolutePath</span><span style="color:#f92672">().</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;不存在！&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>

        List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> filteredFileNames <span style="color:#f92672">=</span> filter<span style="color:#f92672">(</span>testRootDir<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;.csv&#34;</span><span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>filteredFileNames<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * 实现一个按照扩展名过滤文件的功能
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @param rootDirectory 要过滤的文件夹
</span><span style="color:#75715e">     * @param extension     要过滤的文件扩展名，例如 .txt
</span><span style="color:#75715e">     * @return 所有该文件夹（及其后代子文件夹中）匹配指定扩展名的文件的名字
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">filter</span><span style="color:#f92672">(</span>Path rootDirectory<span style="color:#f92672">,</span> String extension<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> names <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
        Files<span style="color:#f92672">.</span><span style="color:#a6e22e">walkFileTree</span><span style="color:#f92672">(</span>rootDirectory<span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> SimpleFileVisitor<span style="color:#f92672">&lt;</span>Path<span style="color:#f92672">&gt;()</span> <span style="color:#f92672">{</span>
            <span style="color:#a6e22e">@Override</span>
            <span style="color:#66d9ef">public</span> FileVisitResult <span style="color:#a6e22e">visitFile</span><span style="color:#f92672">(</span>Path file<span style="color:#f92672">,</span> BasicFileAttributes attrs<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">getFileName</span><span style="color:#f92672">().</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">().</span><span style="color:#a6e22e">endsWith</span><span style="color:#f92672">(</span>extension<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                    names<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">getFileName</span><span style="color:#f92672">().</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">());</span>
                <span style="color:#f92672">}</span>
                <span style="color:#66d9ef">return</span> FileVisitResult<span style="color:#f92672">.</span><span style="color:#a6e22e">CONTINUE</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">});</span>
        <span style="color:#66d9ef">return</span> names<span style="color:#f92672">;</span>
               <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
    <span style="color:#75715e">//匿名内部类，把相近的两块逻辑组合到一起，直接把访问方法，使用结果。
</span><span style="color:#75715e"></span>   
            <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FileFilterVisitor</span> <span style="color:#66d9ef">extends</span> SimpleFileVisitor<span style="color:#f92672">&lt;</span>Path<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">private</span> String extension<span style="color:#f92672">;</span>
                <span style="color:#66d9ef">private</span> List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> filteredNames <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
    
                <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">FileFilterVisitor</span><span style="color:#f92672">(</span>String extension<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">extension</span> <span style="color:#f92672">=</span> extension<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
    
                <span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">getFilteredNames</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">return</span> filteredNames<span style="color:#f92672">;</span>
             <span style="color:#f92672">}</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Java面向对象——组合与继承</title>
            <link>https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/</link>
            <pubDate>Mon, 11 May 2020 17:19:33 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/</guid>
            <description>三大特征 封装 继承 public class Animal { protected String name;
public Animal(String name) { this.name = name; } public void sayMyName() { System.out.println(&amp;quot;我的名字是&amp;quot; + name); } public class Cat extends Animal{ public Cat(String name) { super(name); } public void meow() { System.out.println(&amp;quot;喵&amp;quot; + name); } } public class Main { public static void main(String[] args) { Cat cat = new Cat(&amp;quot;ABC&amp;quot;); cat.meow(); cat.sayMyName(); }  多态 继承 DRY（Donot Repeat Yourself）  事不过三，三则重构  继承的本质是提炼出公用代码，避免重复 继承一个类就会自动继承类的行为</description>
            <content type="html"><![CDATA[<h2 id="三大特征">三大特征</h2>
<h5 id="封装">封装</h5>
<h5 id="继承">继承</h5>
<p>public class Animal {
protected String name;</p>
<pre><code>public Animal(String name) {
    this.name = name;
}

public void sayMyName() {
    System.out.println(&quot;我的名字是&quot; + name);
}
public class Cat extends Animal{

public Cat(String name) {
    super(name);
}

public void meow() {
    System.out.println(&quot;喵&quot; + name);
}
}
public class Main {
public static void main(String[] args) {
    Cat cat = new Cat(&quot;ABC&quot;);
    cat.meow();
    cat.sayMyName();
    }
</code></pre>
<h5 id="多态">多态</h5>
<h2 id="继承-1">继承</h2>
<h3 id="drydonot-repeat-yourself">DRY（Donot Repeat Yourself）</h3>
<ul>
<li>事不过三，三则重构</li>
</ul>
<h3 id="继承的本质是提炼出公用代码避免重复">继承的本质是提炼出公用代码，避免重复</h3>
<p>继承一个类就会自动继承类的行为</p>
<h2 id="java的继承体系">Java的继承体系</h2>
<h3 id="单根继承单一继承声明一个class的时候不声明任何东西都会继承object">单根继承（单一继承）：声明一个Class的时候，不声明任何东西都会继承Object</h3>
<h4 id="优点">优点</h4>
<ul>
<li>
<p>保证所有对象都拥有同一种行为，方便处理</p>
</li>
<li>
<p>对比C++的多重继承</p>
</li>
</ul>
<h3 id="object类有那些需要了解的方法">Object类有那些需要了解的方法？</h3>
<ul>
<li>equals（）</li>
</ul>
<p>判断两个对象是不是同一个对象（地址、内存）</p>
<pre><code>Object a = new Object();
Object b = new Object();
a.equals(b);
//虽然不是两个相同的对象，但是包含的内容相同，所以认为是相等的
</code></pre>
<p>==equals()andhashcoad()==</p>
<pre><code>public class Order {
Integer id;
String name;
//id一样，即使地址不一样，就认为是同一个订单

@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Order order = (Order) o;
    return id.equals(order.id);
}

@Override
public int hashCode() {
    return Objects.hash(id);
}
</code></pre>
<p>当你覆盖Equals方法的时候，要同时覆盖Hashcode
“==”判断地址是否相同；/原生数据类型则是比较的是值否向同</p>
<ul>
<li>
<p>toString（）</p>
</li>
<li>
<p>对一个对象提供字符串表示</p>
</li>
<li>
<p>所有的对象都有toString方法（所有对象都继承Object类）</p>
<p>public static void main(String[] args) {
Cat a = new Cat();
System.out.println(a);
public class Cat {
String name = &ldquo;hey&rdquo;;</p>
<p>@Override
public String toString() {
return &ldquo;Cat{&rdquo; +
&ldquo;name=&rsquo;&rdquo; + name + &lsquo;'&rsquo; +
&lsquo;}';
}</p>
</li>
</ul>
<h2 id="类的结构与初始化顺序">类的结构与初始化顺序</h2>
<ul>
<li>子类拥有父类的一切数据和行为<br>
（即使继承的子类一行代码也没有，也可以调用父类的方法）</li>
<li>子类可以继承父类的父类</li>
<li>父类先于子类生成构造器，因为只有调用父类的方法后才能够完成子类的构造器的</li>
<li>必须拥有匹配的构造器</li>
<li>
<ul>
<li>super关键字</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>需要自行生成一个子类的构造器的时候，就必须要声明一个和父类构造器参数相同的构造器。构造器第一句一定是超类构造器super（父类参数）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>初始化顺序
构造器（不声明任何构造器的化，编译器会自动生成）
不在父类声明构造器时，父类和子类会有自动构造器生成
如果在父类声明构造器，则需要在子类声明super构造器</p>
<ol>
<li>父类初始化语句</li>
<li>父类初始化块</li>
<li>父类的constructor</li>
<li>子类的……
A继承B继承C<br>
C先被创造出来，接着到B，最后到A</li>
</ol>
<h2 id="实例方法的override">实例方法的Override</h2>
<ul>
<li>
<p>又称为覆盖/重写</p>
</li>
<li>
<p>永远使用@Override注解来防手残</p>
<pre><code>      public static main(String[]args){
          String 1 = &quot;ABC&quot;;
          String 2 = &quot;ABC&quot;;
          1.equals(2);
      }
      在执行的过程中可以看到判断相等的时候会看到当前的Integer.equals方法会覆盖object.equal方法(判断value是否相同)
</code></pre>
</li>
</ul>
<h2 id="模版方法">模版方法</h2>
<ul>
<li>
<p>提供一个“模版”，实现可以覆盖模版的全部或者部分
子类可以调用父类的方法，在调用的过程中通过覆盖达到完成需求的目的，其他不改动的沿用父类的模版执行</p>
</li>
<li>
<p>通过@Override可以模板中的一个流程，实现自定义的功能</p>
</li>
<li>
<p>在Override里面通过super.父类的方法，从而实现先执行父类的模板再实现自定义</p>
</li>
</ul>
<blockquote>
<ul>
<li>
<ol>
<li>什么是类加载器？</li>
</ol>
</li>
</ul>
</blockquote>
<ul>
<li>把类加载的过程放到Java虚拟机外部去实现，让应用程序决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</li>
</ul>
<ol start="2">
<li>有哪些类加载器，分别加载哪些类</li>
</ol>
<ul>
<li>类加载器按照层次，从顶层到底层，分为以下三种：
(1)启动类加载器 : 它用来加载 Java 的核心库，比如String、System这些类
(2)扩展类加载器 : 它用来加载 Java 的扩展库。
(3) 应用程序类加载器 : 负责加载用户类路径上所指定的类库，一般来说，Java 应用的类都是由它来完成加载的。</li>
</ul>
<ol start="3">
<li>双亲委派模型</li>
</ol>
<ul>
<li>我们应用程序都是由以上三种类加载器互相配合进行加载的，还可以加入自己定义的类加载器。称为 类加载器的双亲委派模型 ，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用 组合关系 来复用父加载器的。</li>
</ul>
<ol start="4">
<li>双亲委托模型的工作原理</li>
</ol>
<ul>
<li>是当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法加载这个加载请求的时候，子加载器才会尝试自己去加载。</li>
</ul>
<ol start="5">
<li>使用双亲委派模型好处？（原因）</li>
</ol>
<p>第一：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载。</p>
<p>第二：考虑到安全因素，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器。</p>
<h2 id="向上向下转型">向上/向下转型</h2>
<h4 id="一个子类类型的对象永远是一个父类类型的对象">一个子类类型的对象永远是一个父类类型的对象</h4>
<ul>
<li>正如一只猫同时也是一只动物，同时也是一个对象</li>
<li>instanceof 判断类型</li>
<li>null instanceof？ == false</li>
</ul>
<p>Eg：
object &lt;&ndash; Number &lt;&ndash; Integer</p>
<p>a instanceod Integer/Number/Object (a是不是Integer/Number/Object的一个实例)</p>
<h3 id="null不是任何东西的对象"><strong>Null不是任何东西的对象</strong></h3>
<p>null instanceof a(必须是一个类，所以不能是null) ==&gt;false</p>
<h5 id="因此需要一个父类型时总可以传递一个子类型">因此，需要一个父类型时，总可以传递一个子类型</h5>
<p>因为所有的子类都是父类的实例
null可以被赋值给任何引用类型的对象，因此null也可以传递给父类<br>
AnimalName（new Cat（name:&ldquo;喵&rdquo;））</p>
<h5 id="转型">转型</h5>
<p>子类转换为父类是安全的，但是父类转为子类是危险的（小的放进大的里面是安全的，大放小则有可能溢出）</p>
<pre><code> Animal a = new Animal();
 //类似于int a = 1；
 //long i = a；
 //int b = （int）i；
 sayAnimalName((Dog)a);//通过强制传换 
 
 public static void sayAnimalName(Dog animal){

 }




    public class Classifier {
    public static void main(String[] args) {
    List&lt;Object&gt; list = Arrays.asList(&quot;0&quot;, 1, 2L, &quot;3&quot;, new Object());
    List&lt;Number&gt; numbers = new ArrayList&lt;&gt;();
    List&lt;String&gt; strings = new ArrayList&lt;&gt;();
    List&lt;Object&gt; others = new ArrayList&lt;&gt;();

    classify(list, numbers, strings, others);

    System.out.println(&quot;numbers = &quot; + numbers);
    System.out.println(&quot;strings = &quot; + strings);
    System.out.println(&quot;others = &quot; + others);
}

/**
 * 给定一个包含任意对象的列表，将其按照以下方式分类： 如果对象是Number类型，将其放入numberList； 如果对象是String类型，将其放入stringList；
 * 否则，将其放入otherList。
 *
 * @param list 给定的包含任意对象的列表
 * @param numberList 用于接收所有Number对象的列表
 * @param stringList 用于接收所有String对象的列表
 * @param otherList 用于接收其余所有类型对象的列表
 */
public static void classify(
        List&lt;Object&gt; list,
        List&lt;Number&gt; numberList,
        List&lt;String&gt; stringList,
        List&lt;Object&gt; otherList) {
    for (Object element : list ){//先游历数据一遍
        if (element instanceof Number){
            numberList.add((Number) element);
        }else if (element instanceof String){
            stringList.add((String)element);
            }else otherList.add(element);
        }
    }

    }
</code></pre>
<h2 id="super关键字">Super关键字</h2>
<p>调用父类的方法（包括构造函数）</p>
<h2 id="final关键字">final关键字</h2>
<h5 id="final声明变量变量成为不可变的必须初始化保证线程安全">final声明变量，变量成为不可变的（必须初始化），保证线程安全</h5>
<ul>
<li>
<p><input disabled="" type="checkbox"> final int i;</p>
</li>
<li>
<p><input checked="" disabled="" type="checkbox"> -</p>
<pre><code>public Main(int i){
this.i = 1;
//this.i = 2;不行，因为final之后只能够赋值一次，之后就不能够被改写了
}
</code></pre>
<p>final int i;</p>
</li>
<li>
<p>局部变量/方法参数</p>
</li>
<li>
<p>成员变量</p>
</li>
</ul>
<h5 id="final-声明对象">final 声明对象</h5>
<pre><code>Date date = new Date();
f(date)

 private void f(final Date date){
     //对象只是一个地址，final对象指向的地址改变不可以
     //但是指向的内容可以改变
     date = new Date();//不行
     date.setTime();//数据可变
 }
</code></pre>
<ul>
<li>
<p>常量与单例<br>
通过final 声明常量，使用对象的时候不需要在此new一个新的对象，可以直接使用这个常量。引用常量的时候可以通过名字引用，能够快速知道常量的意义。</p>
<pre><code>      public static final int MAX_VALUE = 100;
      public void maxValue(){
      for(int i = 0 ; i &lt; MAX_VALUE ; i++){
    
      }  
</code></pre>
</li>
</ul>
<h6 id="单例">单例</h6>
<ul>
<li>不能被继承，因为是final</li>
<li>
<ul>
<li>方法命名：驼峰形式 maxValue</li>
</ul>
</li>
<li>
<ul>
<li>
<p>常量命名：全部大写 MAX_VALUE</p>
<pre><code>private static final World SINGLEON_INSTANCE = new World();//改变成public就可以被大家所引用
private World(){//构造器私有化，保证没有人能够通过public的方法调用
    
}
/*但是还是能调用创建新的对象
1. 通过反射调用private的构造器
2. 使用序列化和反序列化
*/
</code></pre>
</li>
</ul>
</li>
</ul>
<p>Boolean Integer ……</p>
<pre><code>    private static final World SINGLEON_INSTANCE = new World();
    public static void World getInstance(){
    return SINGLETON_INSTANCE;//通过工厂方法动态决定是否调用单例，也可作为与外界接触的接口
}
</code></pre>
<p>final优点：</p>
<ol>
<li>保证变量被使用的时候是最开始的值</li>
<li>线程是安全的，不用担心多线程带来的问题</li>
<li>类不会被继承，覆盖，重写，不会被改变，保证约定不会被打破，不用担心多态</li>
</ol>
<h5 id="final在方法上的声明禁止继承覆盖重写此方法">final在方法上的声明：禁止继承/覆盖/重写此方法</h5>
<h5 id="final在类声明上的使用禁止继承此类">final在类声明上的使用：禁止继承此类</h5>
<ul>
<li>继承提供了灵活性，也埋下了隐患</li>
<li>为什么String/Integer等类是final的？<br>
避免一些特殊的常量被恶意继承，例如Integer 的MAX_VALUE、MIX_VALUE 破坏约定</li>
</ul>
<h2 id="组合">组合</h2>
<h5 id="继承is---a">继承：is - a</h5>
<ul>
<li>使用继承是为了复用方法</li>
</ul>
<h5 id="组合has---a">组合：has - a</h5>
<ul>
<li>
<p>可以复用多份代码</p>
<pre><code>  class Cat {
      Bell bell;
  }
  private class Bell{
        
  }
  class Home{
      Cat cat;
  }
</code></pre>
</li>
<li>
<p>但是实际中，二者的界限有时候很难区分</p>
</li>
<li>
<p>CountingSet</p>
</li>
<li>
<p>完全不实用继承
git clone <a href="https://github.com/victoriadrake/hugo-theme-sam.git">https://github.com/victoriadrake/hugo-theme-sam.git</a> themes/sam</p>
</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Java 面向对象初步——封装与隐藏</title>
            <link>https://procarihana.github.io/public/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F/</link>
            <pubDate>Mon, 11 May 2020 17:18:58 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F/</guid>
            <description>面向对象的三大特征 封装 优点：实现细节可以发生变化，只要接口不变，就不会对使用产生影响 理念：对外暴露尽可能少的细节
继承 多态 封装 封装隐藏了内部实现细节，只暴露出接口 电灯对象 高、低耦合
  你只访问他的“开关”接口，不关心内部的“电路”细节
 public static void main(String[] args) { Light light = new Light(); light.turnOn();//低耦合 Light light2 = new Light(); light2.打开电路1(); light2.打开电路2(); light2.打开电路3(); //高耦合,比低耦合更难扩展 //Home类和Light类之间建立联系——&amp;gt;耦合（让改变变得困难） //一方进行改变时，另一方也需要进行改变 public class Light {  public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节
} public void 打开电路1(){
} public void 打开电路2(){
} public void 打开电路3(){
}
  废弃后使用自动停止，不影响其他代码的运行
public class Light { @Deprecated public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节 } public static void main(String[] args) { Light light = new Light();  light.</description>
            <content type="html"><![CDATA[<h2 id="面向对象的三大特征">面向对象的三大特征</h2>
<h3 id="封装">封装</h3>
<p>优点：实现细节可以发生变化，只要接口不变，就不会对使用产生影响
理念：对外暴露尽可能少的细节</p>
<h3 id="继承">继承</h3>
<h3 id="多态">多态</h3>
<h2 id="封装-1">封装</h2>
<h3 id="封装隐藏了内部实现细节只暴露出接口">封装隐藏了内部实现细节，只暴露出接口</h3>
<h4 id="电灯对象">电灯对象</h4>
<p>高、低耦合</p>
<ul>
<li>
<p>你只访问他的“开关”接口，不关心内部的“电路”细节</p>
<pre><code> public static void main(String[] args) {
  Light light = new Light();
  light.turnOn();//低耦合

  Light light2 = new Light();
  light2.打开电路1();
  light2.打开电路2();
  light2.打开电路3();
  //高耦合,比低耦合更难扩展

  //Home类和Light类之间建立联系——&gt;耦合（让改变变得困难）
  //一方进行改变时，另一方也需要进行改变
    
  public class Light {
</code></pre>
<p>public void turnOn(){//接口
打开电路1();
打开电路2();
打开电路3();//细节</p>
<p>}
public void 打开电路1(){</p>
<p>}
public void 打开电路2(){</p>
<p>}
public void 打开电路3(){</p>
<p>}</p>
</li>
</ul>
<p>废弃后使用自动停止，不影响其他代码的运行</p>
<pre><code>public class Light {
@Deprecated
public void turnOn(){//接口
    打开电路1();
    打开电路2();
    打开电路3();//细节
    
}
public static void main(String[] args) {
    Light light = new Light();
</code></pre>
<p>light.<del>turnOn()</del>;//低耦合</p>
<h4 id="汽车">汽车</h4>
<ul>
<li>你只访问他的“方向盘”接口，不关心内部的细节</li>
<li>可以通过@Deprecated告知方法废弃，但不会有任何错误</li>
</ul>
<hr>
<pre><code>return gender.equals(&quot;M&quot;);
return Object.equals.(gender,&quot;M&quot;);
return &quot;M&quot;.equals(grnder);//保证gender是空指针，也不会抛出空指针异常，因为M永远不会是空指针
</code></pre>
<h3 id="不封装">不封装</h3>
<ul>
<li>暴露细节的结果就是无法变化</li>
<li>软件的演进例子：为原先的属性增加限制</li>
<li>软件的演进例子： 修改某些属性</li>
</ul>
<h2 id="封装的实现">封装的实现</h2>
<ul>
<li>外界只通过一个接口和里面进行交互，里面的实现细节用private 进行 构造器用private，保证外界不能够用new 直接进行对象的创建</li>
</ul>
<h3 id="访问控制符">访问控制符</h3>
<h6 id="包如同一个文件夹每个类在包里面只能在包中被看到包外是无法被看到的有一个接口和外界交互外界不能访问包里面的内容">包：如同一个文件夹，每个类在包里面，只能在包中被看到，包外是无法被看到的。有一个接口和外界交互，外界不能访问包里面的内容</h6>
<p><strong>包是没有嵌套包含关系的</strong></p>
<ul>
<li>public 任何人都能访问</li>
<li>protected 只有子类和同一个包的类可以访问（子类访问通过extend继承）<br>
同一个包的类可以访问是因为封装的边界是把包内和接口外相分离</li>
<li>package private <em>包级私有</em> 只有同一个包的类可以访问</li>
<li>private 只有自己可以访问</li>
<li>包级私有<br>
不加任何的访问限定符</li>
</ul>
<p><strong>只有在同一个包中的类才能看到，包外的类看不到里面</strong></p>
<h3 id="javabean约定">JavaBean约定</h3>
<ul>
<li>
<p>getter</p>
</li>
<li>
<p>setter</p>
</li>
<li>
<p>首字母大写</p>
<p>//非boolean属性 firstName
public String getFristName
public void setFristName</p>
<p>//boolean属性male
public boolean isMale()
pubilc void setMale(boolean male)</p>
</li>
</ul>
<h4 id="json">JSON</h4>
<ul>
<li>
<p>互联网前后段交换的一种格式，是序列化和反序列化的实现</p>
</li>
<li>
<p>将对象用字符串表示出来的一种方法</p>
</li>
<li>
<p>序列化serialization<br>
把一个对象变成一段字符串、一个字节流（序列化的对象）
【序列化Picture】</p>
</li>
<li>
<p>反序列化deserialize<br>
把字符串或字节流转换成一个的对象</p>
</li>
<li>
<p>FastJson API</p>
<p>public static void main(String[] args) {
Cat cat = new Cat(&ldquo;miao&rdquo;,true);
System.out.println(JSON.toJSONString(cat));//序列化
String s = &ldquo;{&quot;cute&quot;:true,&quot;name&quot;:&quot;miao&quot;}&quot;;
cat = JSON.parseObject(s,Cat.class);//反序列化
}</p>
</li>
<li>
<p>Json的读写关键在javaBean的getter和setter、is，并非是内部的属性（成员变量）</p>
</li>
<li>
<p>如果属性是null的话，就会自动忽略掉</p>
</li>
</ul>
<h2 id="设计模式实战工厂方法">设计模式实战：工厂方法</h2>
<p>注释有可能过时，通过方法名、变量名等方式让编译器能够读懂，使得代码更容易被阅读。</p>
<p>静态工厂：statci 返回要生产的对象 方法名<br>
<strong>（可以任意取，通过阅读可以得知信息）</strong></p>
<ul>
<li>使用静态工厂方法代替构造器</li>
<li>将构造器私有化</li>
<li>实际上就是封装</li>
</ul>
<h5 id="优点">优点：</h5>
<ol>
<li>
<p>方法有名字，可以让人从中得知方法的信息，且可以被编译器处理。注释是不会被编译器编译的，还存在过时的情况</p>
</li>
<li>
<p>不同于构造器，静态工厂方法不一定要创造一个新的对象，可以返回null或者之前创造的对象，使得</p>
<pre><code> Cat cat = new Cat();//构造器，创造实例对象。


 public static Cat newCuteCat(String name) {
 if (name == null){
     return new Cat（name,cute:true）;
 }//不需要创造一个对象，可以返回之前创造的构造器
</code></pre>
</li>
<li>
<p>可以返回返回类型的子类型，提高静态方法的因果性；而构造器并不可以</p>
<p>public class WhileCat extends Cat {</p>
<p>public WhileCat(String name, boolean cute) {
super(name, cute);
}
}
public static Cat newCuteCat(String name) {
if (name.contains(&ldquo;while&rdquo;)) {
return new WhileCat(name, true);
}</p>
</li>
<li>
<p>返回的对象可以变化，根据输入的参数动态决定选择返回的预先定义好的对象，节省时间且避免每次都要重新创建新的对象的内存占用。</p>
</li>
</ol>
<ul>
<li>
<p>可以返回一些动态的类，通过动态加载一些未来的类</p>
</li>
<li>
<p>并没有用new创造任何对象，而是返回true和flase这两个预先定义好的对象。不需要每次都创造对象</p>
<p>public class Cat {
private static final Cat INVALID_CAT = new Cat(&ldquo;Invalid cat&rdquo;,false);
//对象创建用来应对非法对象
}
public static Cat newCuteCat(String name) {</p>
<pre><code>  if (name == null || name.isEmpty()){
  //传进的参数不合法的时候，就能够返回预先定义好的对象，避免重新创建新的对象应对
      return INVALID_CAT;
  }
  return new Class.forName(&quot;FutureCat&quot;).newInstance();
</code></pre>
<p>}</p>
</li>
<li>
<p>静态工厂方法EG：<br>
Boolean.valueof
Integer.parseInt</p>
</li>
</ul>
<ol start="5">
<li>
<p>静态工厂返回的对象可以不存在（Java动态加载）</p>
<p>return new Class.forName(&ldquo;futureCat&rdquo;).newInstance();</p>
</li>
</ol>
<h5 id="缺点">缺点：</h5>
<ol>
<li>没有办法被子类化，不能被覆盖**（非构造器）**；但是构造器可以被子类调用</li>
<li>很难让开发者找到（名字）</li>
</ol>
<ul>
<li>使用静态工厂方法代替构造器</li>
</ul>
<p>表现出对外接口的状态</p>
<ul>
<li>将构造器私有化</li>
</ul>
<h2 id="类的访问限定符">类的访问限定符</h2>
<ul>
<li>public 所有人都可以访问</li>
<li>不加public，什么都不添加的话，就是包级私有（包提供的封装边界）</li>
<li>package private 同一个包的类可以访问</li>
<li>
<ul>
<li><strong>包之间是没有父子关系的</strong>（包之间没有任何关系）</li>
</ul>
</li>
<li>private static class InnerClass只能在同一个类中访问（也是封装的一种形式）</li>
<li>包级私有限定的是通过包名判断的，但是JVM有包名设置的限定，对于自定义的包含java在运行时是不被允许的</li>
<li>了解Java Platform Module System
模块化接口，使得包可以私有化，让内部包</li>
</ul>
<h5 id="包级私有破坏">包级私有破坏</h5>
<p><strong>创建一个名字一样的包在包里面创造一个类作为桥梁，然后return new出要访问的私有包的类。最后在Main调用就可以了</strong></p>
<pre><code>   Eg：https://github.com/hcsp/bypass-package-private/pull/29
</code></pre>
<h5 id="用中间类绕过包级私有的限制">用中间类绕过包级私有的限制</h5>
<h2 id="java模块系统简介">Java模块系统简介</h2>
<ul>
<li>JDK9的新功能，把包对外封装成模块module，提供更大范围的封装，包级私有的包就不会被破坏</li>
</ul>
<h2 id="封装的必要性">封装的必要性</h2>
<ul>
<li>软件的演进 —— 向外界暴露内部实现类的风险</li>
</ul>
<h2 id="扩展阅读">扩展阅读</h2>
<ul>
<li>
<p>JSON序列化/反序列化与JavaBean约定</p>
</li>
<li>
<p>setter的链式调用</p>
</li>
<li>
<p>builder 模式 Vs构造器</p>
</li>
<li>
<p>解决变量（参数）太多的问题</p>
</li>
<li>
<ul>
<li>构造器 :
Person person = new Person(firstName:&quot;&quot;,lastname:&quot;&quot;,address:&quot;&quot;,phone:123)</li>
</ul>
</li>
<li>
<ul>
<li>
<p>Builder：<br>
person = PersonBulider.aPerson()<br>
.withFirstName(&quot;&quot;)<br>
.withLastName(&quot;&quot;)<br>
.withAddress(&quot;&quot;);</p>
<p>public class UserBuilder {
// 请在这里使用builder模式建造User对象
// 所需的接口请参阅UserBuilderTest测试类
private String firstName;
private String lastName;
private String phoneNumber;
private String address;</p>
<p>//    private UserBuilder() {
//
//    }
//把private 改成public 以及 直接删除掉，都可以让UserBuilderTest实现，那么是否这个方法不需要存在？</p>
<p>public static UserBuilder anUser() {
return new UserBuilder();//提供静态空转的方法
}</p>
<p>public UserBuilder firstName(String firstName) {
this.firstName = firstName;
return this;
}</p>
<p>public UserBuilder lastName(String lastName) {
this.lastName = lastName;
return this;
}</p>
<p>public UserBuilder phoneNumber(String phoneNumber) {
this.phoneNumber = phoneNumber;
return this;
}</p>
<p>public UserBuilder address(String address) {
this.address = address;
return this;
}</p>
<pre><code>public User build() {
    return new User(firstName, lastName, phoneNumber, address);
    }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>builder 同样也可以设置默认值</p>
</li>
</ul>
<h2 id="书">书</h2>
<p>Effictive Java</p>
]]></content>
        </item>
        
        <item>
            <title>Java 面向对象初步</title>
            <link>https://procarihana.github.io/public/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5/</link>
            <pubDate>Mon, 11 May 2020 17:18:01 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5/</guid>
            <description>面向对象的三大特征 封装 优点：实现细节可以发生变化，只要接口不变，就不会对使用产生影响
继承 多态 封装 封装隐藏了内部实现细节，只暴露出接口 电灯对象   你只访问他的“开关”接口，不关心内部的“电路”细节
 public static void main(String[] args) { Light light = new Light(); light.turnOn();//低耦合 Light light2 = new Light(); light2.打开电路1(); light2.打开电路2(); light2.打开电路3(); //高耦合,比低耦合更难扩展 //Home类和Light类之间建立联系——&amp;gt;耦合（让改变变得困难） //一方进行改变时，另一方也需要进行改变 public class Light {  public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节
} public void 打开电路1(){
} public void 打开电路2(){
} public void 打开电路3(){
}
  废弃后使用自动停止，不影响其他代码的运行
public class Light { @Deprecated public void turnOn(){//接口 打开电路1(); 打开电路2(); 打开电路3();//细节 } public static void main(String[] args) { Light light = new Light();  light.</description>
            <content type="html"><![CDATA[<h2 id="面向对象的三大特征">面向对象的三大特征</h2>
<h3 id="封装">封装</h3>
<p>优点：实现细节可以发生变化，只要接口不变，就不会对使用产生影响</p>
<h3 id="继承">继承</h3>
<h3 id="多态">多态</h3>
<h2 id="封装-1">封装</h2>
<h3 id="封装隐藏了内部实现细节只暴露出接口">封装隐藏了内部实现细节，只暴露出接口</h3>
<h4 id="电灯对象">电灯对象</h4>
<ul>
<li>
<p>你只访问他的“开关”接口，不关心内部的“电路”细节</p>
<pre><code> public static void main(String[] args) {
  Light light = new Light();
  light.turnOn();//低耦合

  Light light2 = new Light();
  light2.打开电路1();
  light2.打开电路2();
  light2.打开电路3();
  //高耦合,比低耦合更难扩展

  //Home类和Light类之间建立联系——&gt;耦合（让改变变得困难）
  //一方进行改变时，另一方也需要进行改变
    
  public class Light {
</code></pre>
<p>public void turnOn(){//接口
打开电路1();
打开电路2();
打开电路3();//细节</p>
<p>}
public void 打开电路1(){</p>
<p>}
public void 打开电路2(){</p>
<p>}
public void 打开电路3(){</p>
<p>}</p>
</li>
</ul>
<p>废弃后使用自动停止，不影响其他代码的运行</p>
<pre><code>public class Light {
@Deprecated
public void turnOn(){//接口
    打开电路1();
    打开电路2();
    打开电路3();//细节
    
}
public static void main(String[] args) {
    Light light = new Light();
</code></pre>
<p>light.<del>turnOn()</del>;//低耦合</p>
<h4 id="汽车">汽车</h4>
<ul>
<li>
<p>你只访问他的“方向盘”接口，不关心内部的细节</p>
<p>return gender.equals(&ldquo;M&rdquo;);
return Object.equals.(gender,&ldquo;M&rdquo;);//保证gender是空指针，也不会抛出空指针异常
return &ldquo;M&rdquo;.equals(grnder);</p>
</li>
</ul>
<h3 id="不封装">不封装</h3>
<ul>
<li>暴露细节的结果就是无法变化</li>
<li>软件的演进例子：为原先的属性增加限制</li>
<li>软件的演进例子： 修改某些属性</li>
</ul>
<h2 id="封装的实现">封装的实现</h2>
<h3 id="访问控制符">访问控制符</h3>
<h6 id="包如同一个文件夹每个类在包里面只能在包中被看到包外是无法被看到的有一个接口和外界交互外界不能访问包里面的内容">包：如同一个文件夹，每个类在包里面，只能在包中被看到，包外是无法被看到的。有一个接口和外界交互，外界不能访问包里面的内容</h6>
<ul>
<li>public 任何人都能访问</li>
<li>protected 只有子类可以访问和同一个包的可以访问（子类访问通过extend）</li>
<li>package private 只有同一个包的类可以访问</li>
<li>private 只有自己可以访问</li>
</ul>
<h3 id="javabean约定">JavaBean约定</h3>
<ul>
<li>getter</li>
<li>setter</li>
</ul>
<h2 id="设计模式实战工厂方法">设计模式实战：工厂方法</h2>
<ul>
<li>使用静态工厂方法代替构造器</li>
<li>将构造器私有化</li>
</ul>
<h2 id="类的访问限定符">类的访问限定符</h2>
<ul>
<li>public 任何访问</li>
<li>package private 同一个包的类可以访问</li>
<li>
<ul>
<li>包之间是没有父子关系的</li>
</ul>
</li>
<li>（包之间没有任何关系）</li>
<li>private inner class 只能在同一个类中访问</li>
<li>
<ul>
<li>static修饰的成员属于类成员，父类字段或方法只能被子类同名字段或方法遮蔽，public也不能被继承覆盖，</li>
</ul>
</li>
<li>了解Java Platform Module System</li>
</ul>
<h3 id="用中间类绕过包级私有的限制">用中间类绕过包级私有的限制</h3>
<h2 id="封装的必要性">封装的必要性</h2>
<ul>
<li>软件的演进 —— 向外界暴露内部实现类的风险</li>
</ul>
<h2 id="扩展阅读">扩展阅读</h2>
<ul>
<li>JSON序列化/反序列化与JavaBean约定</li>
<li>setter的链式调用</li>
<li>builder 模式</li>
</ul>
<p>（1）父类静态成员和静态初始化块，按在代码中出现的顺序依次执行。
（2）子类静态成员和静态初始化块，按在代码中出现的顺序依次执行。
（3）父类实例成员和实例初始化块，按在代码中出现的顺序依次执行。
（4）执行父类构造方法。
（5）子类实例成员和实例初始化块，按在代码中出现的顺序依次执行。
（6）执行子类构造方法。</p>
]]></content>
        </item>
        
        <item>
            <title>Java面向对象系统基础</title>
            <link>https://procarihana.github.io/public/posts/java%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link>
            <pubDate>Thu, 07 May 2020 16:40:59 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/java%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</guid>
            <description>对象（引用类型）  对象是数据和行为的集合（主观能动性） 一切使用new运算符创建出来的都是对象   new Object（）     特例： Integer i=2/String s= &amp;ldquo;2&amp;rdquo; 自动装拆箱的时候后会自动new 出一个新的对象     特例：new Object[]    对象组成？  所有的对象都在堆上分配 每个对象都包含⾃⼰的数据（成员变量）   初始化
声明int age = 0; 和int age;是相同的，因为默认初始化的值为0 【整数类型】
String 等引用类型的为null   原⽣类型的成员 引⽤类型的成员  栈、堆 栈：方法栈，main执行后需要用到的方法都会放到方法栈里面执行 堆：存放对象
对象的构造函数  新建对象的唯⼀途径 在堆上分配空间 执⾏必要的初始化⼯作 执⾏构造器函数 如果没有任何构造器，编译器会偷偷摸摸帮你⽣成⼀个  对象的方法  数据：有什么 方法：做什么  方法的重载(overload)  重载（overload）与重写/覆盖（override）    重载</description>
            <content type="html"><![CDATA[<h4 id="对象引用类型">对象（引用类型）</h4>
<ul>
<li>对象是数据和行为的集合（主观能动性）</li>
<li>一切使用new运算符创建出来的都是对象</li>
<li>
<ul>
<li>new Object（）</li>
</ul>
</li>
<li>
<ul>
<li>特例： Integer  i=2/String s= &ldquo;2&rdquo; 自动装拆箱的时候后会自动new 出一个新的对象</li>
</ul>
</li>
<li>
<ul>
<li>特例：new Object[]</li>
</ul>
</li>
</ul>
<h4 id="对象组成">对象组成？</h4>
<ul>
<li>所有的对象都在堆上分配</li>
<li>每个对象都包含⾃⼰的数据（成员变量）</li>
</ul>
<ol>
<li>初始化<br>
声明int age = 0; 和int age;是相同的，因为默认初始化的值为0 <em>【整数类型】</em><br>
String 等引用类型的为null</li>
</ol>
<ul>
<li>原⽣类型的成员</li>
<li>引⽤类型的成员</li>
</ul>
<h5 id="栈堆">栈、堆</h5>
<p>栈：方法栈，main执行后需要用到的方法都会放到方法栈里面执行
堆：存放对象</p>
<h4 id="对象的构造函数">对象的构造函数</h4>
<ul>
<li>新建对象的唯⼀途径</li>
<li>在堆上分配空间</li>
<li>执⾏必要的初始化⼯作</li>
<li>执⾏构造器函数</li>
<li>如果没有任何构造器，编译器会偷偷摸摸帮你⽣成⼀个</li>
</ul>
<h4 id="对象的方法">对象的方法</h4>
<ul>
<li>数据：有什么</li>
<li>方法：做什么</li>
</ul>
<h4 id="方法的重载overload">方法的重载(overload)</h4>
<ul>
<li>重载（overload）与重写/覆盖（override）</li>
</ul>
<ol>
<li>
<p>重载<br>
方法名字相同但是参数不相同</p>
<pre><code> public class Cat{
  void printName(S){
          
   }
       
    void printName(tring s){
    }
}
</code></pre>
</li>
</ol>
<ul>
<li>
<p>如何区分同名的不同重载⽅法？</p>
</li>
<li>
<p>根据类型<br>
调用时通过不同的参数区分</p>
<pre><code>  cat.printName();
  cat.printName(&quot;null&quot;);
</code></pre>
</li>
<li>
<p>隐式转换
自动匹配最合适的，按照转换的优先顺序</p>
<pre><code>  public static void main(String agrs[]){
   Cat cat = new Cat();
      cat.s(1);
  }
  void s(int i){
       
  }//最优先
  void s(Integer i){
    
  }//其次
  void s(Number i){
    
  }
  void s(Object i){
    
  }
</code></pre>
</li>
<li>
<p>类型最优先匹配（如果匹配多个，如null 的话，可以为null进行强制类型转换，选择最优先的）</p>
</li>
<li>
<p>不能仅仅重载返回值<br>
因为方法的区别是通过方法名和变量区分的，且方法调用的时候是忽略返回值的，所以即使两个方法的名字和变量相同但返回值不一样，调用的时候会产生冲突，在编译的时候无法通过。但是运行字节码的时候是允许的。</p>
</li>
<li>
<p>不能为⽅法提供默认值<br>
但是可以通过重载的方法实现</p>
<pre><code>      public static void main(String[] agrs){
      Cat cat = new Cat();
      cat.meow();
      cat.meow(&quot;mimi&quot;);
      }

      public void meow(){
      meow(&quot;喵&quot;)；
  }
  public void meow(String value){
      System.out.print(value);
  }
</code></pre>
</li>
</ul>
<h4 id="构造器的重载">构造器的重载</h4>
<ul>
<li>
<p>this()<br>
没有参数构造器可以通过重载，从而能够获得默认值</p>
</li>
<li>
<p>实例：HashMap的构造器重载</p>
<pre><code>//创建一只默认的猫，1岁，名叫张三
  Cat(){
      this(&quot;张三&quot;)；
  }
  //创建一支默认的猫，1岁，名叫name指定的名字
  Cat(String name){
   this(1,name);
  }
  //创建age和name指定的猫
  Cat (int age,String name){
      this.age = age;
      this.name = name;
  }
  public static void main(String[] agrs){
      new Cat();
  }
</code></pre>
</li>
</ul>
<h4 id="对象的初始化">对象的初始化</h4>
<ul>
<li>必要的初始化⼯作</li>
<li>静态成员的初始化</li>
<li>静态初始化块</li>
<li>成员的初始化</li>
<li>初始化块 {}</li>
<li>继续断点调试⼤法检查初始化顺序</li>
</ul>
<h4 id="对象的命周期">对象的⽣命周期</h4>
<ul>
<li>如果⼀直新建对象，内存会不会爆？<br>
可能不会</li>
<li>那对象的内存什么时候被回收？<br>
谁也不知道</li>
<li>对象的内存如何被回收？<br>
不⽤管，GC垃圾回收器帮你⼲</li>
<li>JVM怎么知道哪个对象没有被⽤到？</li>
<li>通过引⽤链（GC Roots）
沿着GC Roots 可达的数据都是活对象，除此以外的都是垃圾
但是没有被引用得不一定会被回收，取决于当前空间</li>
</ul>
<h4 id="数组特殊的对象">数组——特殊的对象</h4>
<ul>
<li>数组类是什么？为什么我从来没有⻅过？</li>
<li>JVM为数组提供了特殊的处理⽅法</li>
<li>数组只有两个操作：[]与length的⻓度不可变</li>
</ul>
<h4 id="tip">Tip</h4>
<ol>
<li>如果在实行初始化的过程中调用方法的话，方法就会先于构造器执行，一个残缺的对象执行方法是一个不安全的行为</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>Java的控制流</title>
            <link>https://procarihana.github.io/public/posts/java%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/</link>
            <pubDate>Wed, 06 May 2020 21:05:25 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/java%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81/</guid>
            <description>控制流 控制流：方法调用 方法调用就是一个方法栈，每当开始一个新的方法调用的时候就会开启一个方法栈的栈针，方法调用之后方法针会被销毁。当有新的方法调用的时候就会开始新一轮的方法栈，循环往复。
while与 do while 循环   while（返回boolean语句)
{
……
}
  do {无论真假就先执行一遍}
while{(返回 boolean语句）;}
  控制流：for 循环   fori
 for（int i = 0;//任何语句，包括空语句 1️⃣ i &amp;lt; 100;//返回boolean的语句，包括空语句 2️⃣ i++){//任何语句，包括空语句） 4️⃣ System.out.println(i); //3️⃣ }    for each
for（String s :Iterable）{ …… }
  对象能够实现Iterabie接口（可迭代）
List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;); //遍历列表，把元素拿出来 for (int i = ;i&amp;lt;list.size(); i++){ System.out.println(list.get(i)); } == for(String element : list){ System.</description>
            <content type="html"><![CDATA[<h2 id="控制流">控制流</h2>
<h2 id="控制流方法调用">控制流：方法调用</h2>
<p>方法调用就是一个方法栈，每当开始一个新的方法调用的时候就会开启一个方法栈的栈针，方法调用之后方法针会被销毁。当有新的方法调用的时候就会开始新一轮的方法栈，循环往复。</p>
<h2 id="while与-do-while-循环">while与 do while 循环</h2>
<ul>
<li>
<p>while（返回boolean语句)<br>
{</p>
<p>……</p>
<p>}</p>
</li>
<li>
<p>do {<strong>无论真假就先执行一遍</strong>}<br>
while{(返回 boolean语句）;}</p>
</li>
</ul>
<h2 id="控制流for-循环">控制流：for 循环</h2>
<ul>
<li>
<p>fori</p>
<pre><code>  for（int i = 0;//任何语句，包括空语句 1️⃣
       i &lt; 100;//返回boolean的语句，包括空语句  2️⃣
       i++){//任何语句，包括空语句） 4️⃣
         System.out.println(i);  //3️⃣
       }
</code></pre>
</li>
<li>
<p>for each</p>
<p>for（String s :Iterable<!-- raw HTML omitted -->）{
……
}</p>
</li>
</ul>
<p>对象能够实现Iterabie接口（可迭代）</p>
<pre><code>List&lt;String&gt; list = Arrays.asList(&quot;1&quot;,&quot;2&quot;);
//遍历列表，把元素拿出来
     for (int i = ;i&lt;list.size(); i++){
         System.out.println(list.get(i));
    }
    
    ==
    
     for(String element : list){
    System.out.println(element);
    } 

 
 for ( int i = 0 ; i&lt; list.size; i++){
     System.out.println(element);
 }
</code></pre>
<p>统计一个给定的字符串中，大写英文字母（A,B,C,&hellip;,Z）出现的次数。</p>
<pre><code>    public static int  countUpperCaseLetters(String str) {
    int a = 0;
    for(char ch : str.toCharArray()){
        if(ch &gt;='A' &amp;&amp; ch&lt;='Z'){
            ++a;
        }
    }
    return a;
}
public static void main(String[] args) {
    countUpperCaseLetters(&quot;AaBbCc1234ABC&quot;);
}
</code></pre>
<p>}</p>
<h2 id="改变循环的流程breakcontinue">改变循环的流程：break/continue</h2>
<ul>
<li>
<p>braek;立即结束包裹当前braek的第一层循环</p>
</li>
<li>
<p>找到结果后，打破当前循环，结束循环。</p>
<pre><code>  public static boolean find(List&lt;Integer&gt; list,int value){
  boolean exist = false;
  for (Integer element :list){
      if(element == value){
          exist = true;
          break;     //break 包裹这 for 的循环 --&gt; 结束的是for循环
      }
  }
  return exist;
  }
    
  public static void main(String[] args) throws IOException {
  List&lt;Integer&gt; list1 = Arrays.asList(1,2,3);
  find(list1,2);
  find(list1,2);

 }
</code></pre>
</li>
<li>
<p>continue;跳过包裹当前continue的第一层循环中的其余语句，继续下一次循环</p>
</li>
<li>
<p>如果if里面的语句满足，则跳过for剩下的未执行的语句，直接调回for的循环条件执行循环</p>
<pre><code>//只打印list重的奇数元素
public static void printOdd(List&lt;Integer&gt; list){
  for (int i= 0; i&lt; list.size();i++){
       if (list.get(i) % 2 ==0 ){
           continue;//continue包裹的第一层循环是for --&gt; 执行完第一次循环之后，就进入if
       } System.out.println(list.get(i));
  }
   }
  public static void main(String[] args) throws IOException {
  printOdd(Arrays.asList(1,4,2,56,-1,3,12));
    
    
   public static void printOddNumbersBetween(int start, int end) {


    for (int i = start; i &lt;= end; i++) {
      if (i % 2 != 0) {
          System.out.print(i + &quot;,&quot;);
     }
 
  List&lt;Integer&gt; list = new  ArrayList&lt;&gt;();
  List&lt;Integer&gt; list1 = new  ArrayList&lt;&gt;();
  for (int i = start; i &lt;= end; i++) {
      list.add(i);
  }
  for (int i = 0; i &lt;list.size();i++) {
      if (list.get(i) % 2 != 0) {
          list1.add(list.get(i));
          continue;
      }

  }System.out.println(list1);
}
  public static void main(String[] args) {
  printOddNumbersBetween(1, 5);
  printOddNumbersBetween(-2, 2);
  }
 }
</code></pre>
</li>
<li>
<p>break label</p>
</li>
</ul>
<p>label：标签，在程序的某得地方设置标签，然后跳转到标签处，实现程序控制流程转移</p>
<ul>
<li>
<p>lable 要和任意语句进行搭配</p>
<pre><code>   //不报错：任意字符（&quot;http&quot;） + &quot;：&quot; ———&gt;lable ； &quot;//&quot;表示开始注释
  http://google.com
    
   public static void main(String[] args)  {
      int i = 100;
      while (i --&gt; 0){//(i--)&gt;0
          System.out.println(i);
  }
    
    
  public static void main(String[] args)throws IOException{
  最外层的循环:
     for (int i=0;i &lt;2;i++){
         for (int j = 0; j&lt; 1;j++){
             break 最外层的循环;//通过label，break多层循环
         }

     }
     for (int i=0;i &lt;2;i++){
         for (int j = 0; j&lt; 1;j++){
             break;//--&gt;只能够解决当前的for，不能够解决所有的for
         }
      }
</code></pre>
</li>
</ul>
<h2 id="控制流switch">控制流：switch</h2>
<h3 id="可以switch的东西">可以switch的东西</h3>
<ul>
<li>
<p>int / long / char / byte / short(所有的<strong>整形</strong>数，而不是<em>整数</em>，不是<em>浮点数</em>)</p>
</li>
<li>
<p>enum 枚举
只能选取固定的值，例如:Weekday、colour</p>
<p>private enum WeekDay{
MONDAY,TUESDAY,//……，SUNDAY
}</p>
<pre><code>  enum Signal{    
  GREEN, YELLOW, RED  
  }  
   public class TrafficLight {         
   Signal color = Signal.RED;
   public void change() {  
   switch (color) {  
   color = Signal.GREEN;  
   break;  
   color = Signal.RED;  
  case GREEN:
  color = Signal.YELLOW;  
  break;  
      
      }  
  }  
}
</code></pre>
</li>
<li>
<p>String （JDK7+）</p>
<pre><code>int i = new Random().nextInt(5);
   switch (i){
       case 0:
           System.out.println(i);break;
       case 1:
           System.out.println(i);break;
       case 2:
           System.out.println(i);break;
       case 3:
           System.out.println(i);break;
       case 4:
           System.out.println(i);break;
           default:
               System.out.println(i);break;
               //没有添加break的情况下执行完一个语句之后，会紧接着执行下一个case（穿透）
</code></pre>
</li>
<li>
<p>声明的作用域在一个{}，不同的{}可以声明相同的变量而互不相冲</p>
<pre><code>//如果i是A/B/C, 打印ABC
     //否则打印DE
     int i = (char)('A' + new Random().nextInt(5));
     switch (i){
         case 'A':
         case 'B':
         case 'C':{
             String s = &quot;ABC&quot;;
             System.out.println(s);}
             break;
             default:
                 String s = &quot;DE&quot; ;
                 System.out.println(s);
                 break;
</code></pre>
</li>
</ul>
<h2 id="控制流嵌套">控制流：嵌套</h2>
<ul>
<li>
<p>所有调用都可以嵌套，但是方法声明不能够嵌套</p>
<pre><code>                 while (true){
                     for (int j = 0; j &lt; 100 ; j++) {
                         List&lt;String&gt; l = null;
                         for (String e : l){
                             switch (i){

                             }

                         }

                     }
</code></pre>
</li>
</ul>
<p>穿透</p>
<pre><code>   public static boolean isLeapYear(int year) {
     if (year % 100 == 0) {
         if (year % 400 == 0) {
             return true;
         } else {
             return false;
         }
     } else if (year % 4 == 0) {
             return true;
     } else {
         return false;
     }
     
    // or
     return year % 100 == 0 ? ( year % 400 == 0 ? true : false ) : (year % 4 == 0 ? true :false );
</code></pre>
<p>计算质数</p>
<pre><code>     public static int howManyPrimeNumbers(int n) {
    int num = 0;
    for (int n1 = 2; n1 &lt; n; n1 ++){
            if (isPrimeNumber(n1)){
                num++;
        }
    }
    return num;
    }
public static boolean isPrimeNumber(int n1) {
    for (int i = 2; i &lt;= Math.sqrt(n1) + 1; i++) {
        if (n1 % i == 0 &amp;&amp; n1 !=i ) {
           return false;
        }
    }
  return true;
}
</code></pre>
<p>给定一个二维数组，返回其主对角线（从左上到右下）元素之和。</p>
<p><a href="https://blog.csdn.net/hester_hester/article/details/77925927">https://blog.csdn.net/hester_hester/article/details/77925927</a></p>
<pre><code>public static int diagonalSum(int[][] matrix) {
    int N = matrix.length;
    int result = 0;
    for (int i = 0;i &lt; N;i++){
        result += matrix[i][i];
    }return result;

}</code></pre>
]]></content>
        </item>
        
        <item>
            <title>爬虫项目</title>
            <link>https://procarihana.github.io/public/posts/%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/</link>
            <pubDate>Wed, 06 May 2020 17:07:22 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/</guid>
            <description>原则  使用GitHub+主干/分支模型进行开发 禁止直接push master 所有的变更通过PR进行 自动化代码质量检查+测试 Checkstyle/SpotBugs 最基本的自动化测试覆盖 一切工作自动化 规范化提交流程   创建仓库流程   Github -new
  建立新项目 newBranch 的时候选Apache License 2.0
   Mvn archetype 项目骨架     IDEA - new     copy （cp -r ../* .）    .gitigonre
  git commit &amp;ndash;amend 就可以把这一次的commit和上一次的合并起来
   记得要把.iml 放进（vi .gitignore）： *.iml和target/(放在最后一行就好) 更改pom 里面的groundId，artifactId cp -r ～/.circleci . (因为之前cp ～* 的时候并不会cp到.</description>
            <content type="html"><![CDATA[<h4 id="原则">原则</h4>
<ul>
<li>使用GitHub+主干/分支模型进行开发</li>
<li>禁止直接push master</li>
<li>所有的变更通过PR进行</li>
<li>自动化代码质量检查+测试</li>
<li>Checkstyle/SpotBugs</li>
<li>最基本的自动化测试覆盖</li>
<li>一切工作自动化</li>
<li>规范化提交流程</li>
</ul>
<hr>
<h4 id="创建仓库流程">创建仓库流程</h4>
<ul>
<li>
<p>Github -new</p>
</li>
<li>
<p>建立新项目
newBranch 的时候选Apache License 2.0</p>
</li>
<li>
<ul>
<li>Mvn archetype 项目骨架</li>
</ul>
</li>
<li>
<ul>
<li>IDEA - new</li>
</ul>
</li>
<li>
<ul>
<li>copy （cp -r ../* .）</li>
</ul>
</li>
<li>
<p>.gitigonre</p>
</li>
<li>
<p>git commit &ndash;amend 就可以把这一次的commit和上一次的合并起来</p>
</li>
</ul>
<ol>
<li><strong>记得要把<code>.iml</code> 放进（vi .gitignore）： <code>*.iml</code>和<code>target/</code>(放在最后一行就好)</strong></li>
<li>更改pom 里面的groundId，artifactId</li>
<li>cp -r ～/.circleci . (因为之前cp ～* 的时候并不会cp到<code>.~</code>的文件)，保留checkstyle.xml以及congif.yml[自动化测试]</li>
<li><code>.idea/</code> 不能够提交（在最后完成项目提交时）</li>
</ol>
<ul>
<li>README<br>
MD语法</li>
<li>checkstyle 检查代码风格</li>
<li>
<ul>
<li>RegexpSingleline 每一行代码后面不能有空格</li>
</ul>
</li>
</ul>
<hr>
<h4 id="项目的设计流程-自顶向下">项目的设计流程-自顶向下</h4>
<ul>
<li>多人协作<br>
使用分支可以同时进行不同的功能，且互不影响</li>
<li>模块化</li>
<li>
<ul>
<li>各模块间职责明确，界限清晰</li>
</ul>
</li>
<li>
<ul>
<li>基本的文档</li>
</ul>
</li>
<li>
<ul>
<li>基本的接口</li>
</ul>
</li>
<li>小步提交</li>
<li>
<ul>
<li>大的变更更难以review</li>
</ul>
</li>
<li>
<ul>
<li>大的变更冲突更加棘手</li>
</ul>
</li>
</ul>
<hr>
<h4 id="项目的设计流程---自底向上">项目的设计流程 - 自底向上</h4>
<ul>
<li>一个人</li>
<li>
<ul>
<li>先实现功能</li>
</ul>
</li>
<li>
<ul>
<li>在实现的过程中不停地抽取公用部分</li>
</ul>
</li>
<li>
<ul>
<li>每当写很长的代码的时候，就要重构了</li>
</ul>
</li>
<li>
<ul>
<li>DRY:每当你复制、粘贴的时候，就要重构了</li>
</ul>
</li>
<li>通过重构实现模块化、接口化</li>
</ul>
<h2 id="模块化优点">模块化优点</h2>
<h4 id="项目的演进可扩展行">项目的演进：可扩展行</h4>
<ul>
<li>单线程-&gt;多线程</li>
<li>console -&gt; H2 database</li>
<li>H2 database -&gt;Elasticsearch</li>
</ul>
<h4 id="爬虫">爬虫</h4>
<ul>
<li>新闻网站反爬比较少</li>
<li>手机网页更容易爬</li>
<li>思路</li>
</ul>
<ol>
<li>建立两个链接池，一个放满足条件的链接，另一个放已经爬过的链接</li>
<li>通过HttpCline 来登录网站和获得数据</li>
<li>通过Jsoup 来解析数据</li>
<li>httpGet.addHeader 添加登录的名字和cookie
5.筛选需要链接，通过doc.select查找链接href和链接下需要的元素a标签、article 等</li>
<li></li>
</ol>
<h4 id="冒烟测试">冒烟测试</h4>
<ul>
<li>test 设置一个冒烟测试，每写一小部分就进行测试</li>
</ul>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
    &lt;version&gt;5.6.0&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
    &lt;version&gt;5.6.0&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><h4 id="git-push-错误的文件">git push 错误的文件</h4>
<ul>
<li>在分支上操作</li>
</ul>
<ol>
<li>git reset HEAD~1  把提交回滚到前1/2……各</li>
<li>把不想提交的放进 vi .gitignore 里（.idea/）</li>
<li>git add .</li>
<li>git commit 后就会出现分支</li>
</ol>
<ul>
<li>以master的身份提交</li>
</ul>
<ol>
<li>通过git log 查看刚才提交的提交的ID</li>
<li>git revert 撤销刚才的提交（但是刚才的提交就会消除）</li>
<li>重新把不需要提交的文件放进gitignore里面，然后再次提交</li>
<li>因为重新提交后和原本的master分支出现了分差，所以需要用git push -f （force push）强行提交</li>
</ol>
<ul>
<li>在主干上直接把多余的文件删掉</li>
<li>git add 错误的文件</li>
<li>
<ul>
<li>git reset HEAD 不想要提交的文件</li>
</ul>
</li>
</ul>
<pre><code>git reset HEAD .idea 
</code></pre><ul>
<li>只要没有push，所有行为都只有自己能够看到</li>
</ul>
<h4 id="commit-massage">commit massage</h4>
<ul>
<li>先写一行简短的总结</li>
<li>详细总结每行不要超过72word</li>
</ul>
<h4 id="本地库commit的时候后想要和前一个commit合并">本地库commit的时候后想要和前一个commit合并</h4>
<p>git commit &ndash;amend</p>
<h4 id="github-合并commit">github 合并commit</h4>
<ul>
<li>git rebase</li>
<li>merge pull request</li>
</ul>
<h4 id="maven-自动化的检查">Maven 自动化的检查</h4>
<ul>
<li>spotbugs</li>
<li>在Dependens前面加↓可以控制plugin的运行周期</li>
</ul>
<pre><code>        &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;verify&lt;/id&gt;
                        &lt;phase&gt;verify&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;check&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
</code></pre><ul>
<li>
<ul>
<li><a href="https://spotbugs.github.io/spotbugs-maven-plugin/usage.html">https://spotbugs.github.io/spotbugs-maven-plugin/usage.html</a>
根据不同的需要配置插件</li>
</ul>
</li>
<li>
<ul>
<li>gui [  mvn spotbugs:gui  ]</li>
</ul>
</li>
</ul>
<h4 id="docker-mysal-迁移h2-的数据库">Docker mysal 迁移h2 的数据库</h4>
<ul>
<li>建立一个储存数据库的目录（datadir）  mkdir</li>
</ul>
<pre><code>    mkdir mysql-data
</code></pre><ul>
<li>在docker 上面开设mysql的数据库</li>
</ul>
<pre><code>    docker run --name mockNews-mysql -v `pwd`/mysql-mockNewsData:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=hana -e MYSQL_DATABSE=databasename -p 3306:3306 -d mysql
</code></pre><ul>
<li>
<ul>
<li><code>pwd</code>只要MAC能够，Windows要用全路径名</li>
</ul>
</li>
<li>更改有flyway的连接（用户名为root，密码为docker run 上面设置的密码）和Mybatis的config.xml里面的url，</li>
<li>
<ul>
<li>
<p>config</p>
<!-- raw HTML omitted -->
</li>
</ul>
</li>
</ul>
<h3 id="flyway-数据库自动化管理">flyway 数据库自动化管理</h3>
<ul>
<li>每次启动项目都自动运行
<strong>pom.xml</strong></li>
</ul>
<pre><code>     &lt;build&gt;
        &lt;plugins&gt;

            &lt;plugin&gt;
                &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;
                &lt;artifactId&gt;flyway-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;5.2.4&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;url&gt;jdbc:mysql://localhost:3306/NEWS&lt;/url&gt;
                    &lt;user&gt;root&lt;/user&gt;
                    &lt;password&gt;hana&lt;/password&gt;
                &lt;/configuration&gt;
</code></pre><h4 id="or">or</h4>
<pre><code>    &lt;configuration&gt;
                &lt;url&gt;jdbc:mysql://localhost:3306/news&lt;/url&gt;
                &lt;user&gt;root&lt;/user&gt;
                &lt;password&gt;hana&lt;/password&gt;
     &lt;property name=&quot;url&quot;value=&quot;jdbc:mysql://localhost:3306/news?characterEncoding=utf-8&quot;/&gt;
</code></pre><p><strong>在<code>src/main/resources/db/migration</code>添加数据库需要重置的内容</strong></p>
<ol>
<li>添加 等等储存数据库需要的变更还原……</li>
</ol>
<pre><code>V1__Initial_version.sql
</code></pre><pre><code>V2__Add a new table.sql
</code></pre><ul>
<li>添加mysql connect java 的maven</li>
<li>需要去到小松鼠用</li>
</ul>
<pre><code>url=jdbc:mysql://localhost/databasename   
user = root   
password = docker设置的登录mysql  
</code></pre><p>（docker的mysql要在运行的状态，没有的话就要去docker -d（当前）或者-it（后台））</p>
<pre><code>    docker run mysqlname -it mysql
</code></pre><p>运行</p>
<pre><code>mvn flyway:migrate
</code></pre><h4 id="通过索引让数据更新">通过索引，让数据更新</h4>
<p><strong>问题：</strong></p>
<ol>
<li>flyway tablename - -   -</li>
</ol>
<ul>
<li>SQL分大小写，有小写tablename在创建后出现不存在的反馈</li>
<li>Found non-empty schema(s) <code>user</code> without schema history table! Use baseline() or set baselineOnMigrate to true to initialize the schema history table.</li>
</ul>
<h4 id="多线程">多线程</h4>
<ul>
<li>继承多线程的情况下，方法是不能直接 throw Excetion，要使用try和catch方法，异常要及时反馈，不能吞掉。</li>
<li>爬虫方法实例化后，所有线程就能够共用一个方法，不需要每一个线程都新开一个方法，出现重复爬取数据的现象</li>
<li>delete 语句要特别注意，需要使用synchronized</li>
</ul>
<ol start="2">
<li>
<p>mysql 的数据表新建都要带<br>
DEFAULT CHARSET=utf8mb4，不然就有可能出现乱码</p>
<p>create table NEWS(
id bigint primary key auto_increment,
title text,
content text,
url varchar(1000),
created_at timestamp,
modified_at timestamp)DEFAULT CHARSET=utf8mb4;</p>
</li>
</ol>
<hr>
<h3 id="项目">项目</h3>
<ul>
<li>爬去新浪新闻页，做一个真正的爬虫</li>
<li>使用数据库储存进行数据分析</li>
<li>随着数据量的增长，前一到ES</li>
<li>做一个简单的“新闻搜索引擎”</li>
</ul>
<h5 id="算法">算法</h5>
<ul>
<li>从一个节点遍历所有节点</li>
<li>广度优先 BFS 从上到下，从左到右，1层-&gt;2层-&gt;3……<br>
队列数据结构、JDK的队列实现</li>
<li>深度优先 1-&gt;2-&gt;4…… 从左到右</li>
</ul>
<h4 id="广度优先">广度优先</h4>
<h4 id="jdk的队列实现">JDK的队列实现</h4>
<h4 id="流程">流程</h4>
<ol>
<li>从链接池里拿一个链接</li>
<li>从池子里删除处理过的链接</li>
<li>判断链接是否处理</li>
<li>判断链接是否需要</li>
<li>处理</li>
</ol>
<ul>
<li>通过Jsoup获得HTML里面的内容</li>
<li>爬取新闻页面里面的链接放入链接库里</li>
<li>把内容放进新闻数据库里</li>
<li>把新闻链接放入新闻链接数据库里</li>
</ul>
<ol start="7">
<li>进入下一个循环</li>
<li>用DAO分离数据库和爬虫代码</li>
<li>用ORM把数据库里面的项目变成对象，使得数据库的操作变得更加简便</li>
</ol>
<h2 id="建立数据库">建立数据库</h2>
<h4 id="建立h2数据库">建立H2数据库</h4>
<ol>
<li>添加H2依赖</li>
<li>URL “”+/文件路径/数据库的文件名</li>
<li>create table LINKS_TO_BE_PROCESSED(link varchar (100));</li>
<li>create table LINKS_ALREADY_PROCESSED (link varchar (100))</li>
<li>create table News(id bigint primary key auto_increment,
title text,
content text,
url varchar(100),
created_at timestamp,
modified_at timestamp)</li>
<li>insert into links_to_be_processed(link)values(&lsquo;LINK&rsquo;) //向数据库设置起始的Link</li>
</ol>
<h4 id="sql数据类型">sql数据类型</h4>
<ul>
<li>varchar（n）可变长度字符串，最多为8,000字符</li>
<li>varchar（max）可变长度字符串，最多为1,073,741,824</li>
<li>text 可变长度的字符串，最多2GB文本数据(适合储存新闻)</li>
<li>nchar 固定长度的Unicode字符串。最多4，000个字符</li>
</ul>
<h4 id="flyaway">flyaway</h4>
<ul>
<li>
<p>数据库在使用的时候会不断变更，有不同的版本，flyaway可以储存数据库不同的版本，从而可以变更不同版本的<strong>结构</strong></p>
</li>
<li>
<p>flyaway需要在插件的地方修改URL，添加Username和password</p>
</li>
<li>
<p>即使数据库删掉也可以快速回复结构</p>
</li>
<li>
<p>flyWay 数据库结构管理的自动化</p>
<pre><code>   &lt;plugin&gt;
          &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;
          &lt;artifactId&gt;flyway-maven-plugin&lt;/artifactId&gt;
          &lt;version&gt;5.2.4&lt;/version&gt;
          &lt;configuration&gt;
              &lt;url&gt;&lt;/url&gt;
              &lt;user&gt;&lt;/user&gt;
              &lt;password&gt;&lt;/password&gt;
          &lt;/configuration&gt;

      &lt;/plugin&gt;
</code></pre>
</li>
<li>
<p>flyaway:baseline()</p>
</li>
<li>
<p>flyaway:migrate</p>
</li>
</ul>
<h4 id="orm-object-relation-mapping">ORM Object Relation Mapping</h4>
<p>对象关系数据库</p>
<ul>
<li>通过select 语句把表格里面的项目变成对象，</li>
<li></li>
</ul>
<h4 id="dao-data-accessbase-object">DAO Data Accessbase Object</h4>
<ul>
<li>数据库操作 和其他业务逻辑的分离</li>
<li>static 方法无法被覆用就无法使用接口，所以需要把方法变成实例方法，通过new一个实例来让static的main可以使用。且static方法是不能访问非static成员的。</li>
</ul>
<h4 id="mybatics">MyBatics</h4>
<ul>
<li>driver 驱动器 ：H2、MySQL…… 可以在小松鼠对应的driver里的className找到,需要添加相应的maven来驱动</li>
<li>mappers resource 地址的起始位resource</li>
<li>Select</li>
<li>
<ul>
<li>Blog blog = session.selectOne(
&ldquo;org.mybatis.example.BlogMapper.selectBlog&rdquo;, 101); //Mapper.xml</li>
</ul>
</li>
<li>
<ul>
<li>地址+SQL语句的名字</li>
</ul>
</li>
<li>Insert</li>
<li>
<ul>
<li>try (SqlSession session = sqlSessionFactory.openSession()) {
session.insert(&ldquo;com.github.Hana.MyMapper.insertNews&rdquo;,new News(title,content,url));</li>
</ul>
</li>
<li>
<ul>
<li>地址+需要添加的对象的实例</li>
</ul>
</li>
<li>Setting 驼峰名映射</li>
<li>
<ul>
<li>Mybatis 是无法自动识别大小写的，通过需要大写的字母前添加&rdquo;-&ldquo;来判断大小写：created_at。</li>
</ul>
</li>
<li>-mapUnderscoreToCamelCase	是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。</li>
</ul>
<h5 id="动态sql">动态SQL</h5>
<ul>
<li>
<p>SQL语句不支持直接传入参数，所以choose语句里面必须是sql，而不能直接传入参数</p>
</li>
<li>
<p>判断条件是记得要加单引号，因为不适用会认为是一个参数</p>
<!-- raw HTML omitted -->
</li>
<li>
<p>执行语句是，记得要加上传给SQL的参数</p>
<p>session.delete(&ldquo;com.github.Hana.MyMapper.deleteNextAvailableLink&rdquo;,link);</p>
</li>
</ul>
<h4 id="tips">Tips</h4>
<ol>
<li>Arraylist 从尾部删除更有效率（sive-1）。因为删除第一个元素之后，后面所有的元素都要向前移动一位。</li>
<li>linkPool.remove 删除指定位置的链接后返回被删除的链接</li>
<li>线程卡住的时候可以通过<code>jps</code>查看当前正在运行的线程</li>
<li>链接显示为&rdquo;//……&rdquo; 的话，为当前的链接，需要手动添加&quot;https&quot;+link 进行识别</li>
<li>数据库的用户名和密码最好是使用final常量去声明</li>
<li>想要关闭代码检查findbugs的错误可以通过引入包解决。在相应的地方通过注释SuppressFBWarnings（&ldquo;DMI_CONSTANT_DB_PASSWORD&rdquo;）</li>
<li>如果存在无法关闭的情况，可以通过final强行关闭</li>
<li>try with resoure会自动设置关闭。try（需要声明能close的变量）</li>
<li>HTML是没有换行符的，所以爬虫的时候是爬每一各P元素，加一个换行来分隔</li>
<li>static 方法是不能够访问非static 成员的，static main 才可以运行， 非static 的main 只是一个普通的方法，不能够被运行</li>
</ol>
<h2 id="httpclines-apache">Httpclines Apache</h2>
<ol>
<li>EntityUtils.toString(entity)&ndash;&gt;Attempted read from closed stream</li>
</ol>
<ul>
<li>这句导致了后面的写入文件错误.entity所得到的流是不可重复读取的也就是说所得的到实体只能一次消耗完,
不能多次读取</li>
<li>EntityUtils.toString(entity)后,流就关闭了,就导致后面的读和写显示错误.</li>
</ul>
<ol start="2">
<li>EntityUtils.consume &ndash;&gt; 释放持有的所有资源, 基本上意味着释放任何基础流，并给予Connection对象返回到其池，使它可以处理下一个请求。</li>
<li></li>
</ol>
<p>不推荐使用EntityUtils的toString方法，因为toString方法默认最大的长度是Integer.MAX_VALUE，这个有点危险，会导致缓冲区溢出。
4. 关闭Stream和response</p>
<pre><code>CloseableHttpClient httpclient = HttpClients.createDefault();
HttpGet httpget = new HttpGet(&quot;http://localhost/&quot;);
CloseableHttpResponse response = httpclient.execute(httpget);
try {
    HttpEntity entity = response.getEntity();
    if (entity != null) {
    InputStream instream = entity.getContent();
    try {
        // do something useful
        } finally {
        instream.close();
        }
    }
} finally {
    response.close();
}
</code></pre>
<ul>
<li>关闭InputStream和关闭response的区别在于：关闭InputStream会通过消费实体内容与底层保持连接，而关闭response则会立即停止和丢弃连接。</li>
</ul>
<ol start="5">
<li>代码中发送http请求， java.lang.IllegalArgumentException: Illegal character in query at index&hellip;非法字符错误解决办法</li>
</ol>
<ul>
<li>点开链接，查找到不能识别的字符，通过替代的方法手动识别</li>
</ul>
<ol start="6">
<li>Httpclient发送请求org.apache.http.client.ClientProtocolException</li>
</ol>
<ul>
<li>链接里面可能为&rdquo;//&ldquo;开头，需要手动添加&quot;https:&rdquo;</li>
<li>需要手动添加USER_AGRENT来模拟浏览器访问</li>
</ul>
<h2 id="jsoup">Jsoup</h2>
<ol>
<li>Element.attr();</li>
</ol>
<ul>
<li>
<p>attr()函数的设计目标是用于设置或获取指定DOM元素所对应的文档节点上的属性(attribute)。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
</li>
</ul>
<p><a href="https://segmentfault.com/a/1190000002680303">https://segmentfault.com/a/1190000002680303</a></p>
<h2 id="linkpool通过list或者set元素不重复实现">linkpool【通过List或者Set（元素不重复）实现】</h2>
<ul>
<li>
<p>Arraylist.get() &ndash;&gt; 从线程池中获取元素</p>
<p>String link = linkPool.get(0);</p>
</li>
<li>
<p>remove &ndash;&gt; 从线程池中删除某个元素，并返回被删除的元素(ArrayList从第一个元素开始删除效率更低)</p>
<p>linkPool.remove(linkPool.size()-1);</p>
</li>
<li>
<p>链接池使用完后不需要的链接需要及时删除</p>
</li>
</ul>
<h2 id="document">Document</h2>
<ul>
<li>document.select</li>
</ul>
<table>
<thead>
<tr>
<th align="center">描述</th>
<th align="center">测试的HTML代码</th>
<th align="center">select写法</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">通过 标签名 查找</td>
<td align="center"><code>&lt;span&gt; 33 &lt;/span&gt;``&lt;span&gt;25&lt;/span&gt;</code></td>
<td align="center">Elements elements = doc.select(&ldquo;span&rdquo;);注 ：通过标签来查找，直接写 &ldquo;标签名&rdquo; 就好， 不需要尖括号</td>
<td align="center"><code>33</code> <code>25</code></td>
</tr>
<tr>
<td align="center">通过 id 查找</td>
<td align="center"><code>&lt;span id=&quot;mySpan&quot;&gt;36&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;</code></td>
<td align="center">Elements elements = doc.select(&quot;#mySpan&rdquo;);注 ：通过id来查找，用 #</td>
<td></td>
</tr>
<tr>
<td align="center">通过 class查找</td>
<td align="center"><code>&lt;span class=&quot;myClass&quot;&gt;36&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;</code></td>
<td align="center">Elements elements = doc.select(&quot;.myClass&rdquo;);注 ：通过class来查找，用 .</td>
<td></td>
</tr>
<tr>
<td align="center">通过 属性名 查找</td>
<td align="center"><code>&lt;span class=&quot;class1&quot; id=&quot;id1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;class2&quot; id=&quot;id2&quot;&gt;36&lt;/span&gt;</code></td>
<td align="center">Elements elements = doc.select(&ldquo;span[class=class1]span[id=id1]&quot;);注 ：查询规则为 标签名[属性名=属性值]，标签名可写可不写，多个属性即多个[]，如上</td>
<td></td>
</tr>
<tr>
<td align="center">通过 属性名前缀  查找</td>
<td align="center"><code>&lt;span class=&quot;class1&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;class2&quot;&gt;22&lt;/span&gt;</code></td>
<td align="center">Elements elements = doc.select(&ldquo;span[^cl]&quot;);注 ：查询规则为 标签名[^属性名前缀] ，标签名可写可不写， 多个属性即多个[]</td>
<td align="center">36 22</td>
</tr>
<tr>
<td align="center">通过 属性名+正则表达式 查找</td>
<td align="center"><code>|&lt;span class=&quot;ABC&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;ADE&quot;&gt;22&lt;/span&gt;</code></td>
<td align="center">Elements elements = doc.select(&ldquo;span[class~=^AB]&quot;);注 ：查询规则为 标签名[属性名~=正则表达式]，标签名可写可不写，多个属性即多个</td>
<td></td>
</tr>
<tr>
<td align="center">通过 文本内容 查找</td>
<td align="center"><code>&lt;span&gt;36&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;</code></td>
<td align="center">Elements elements = doc.select(&ldquo;span:contains(3)&quot;);注 ：查询规则为 标签名:contains(文本值)</td>
<td></td>
</tr>
<tr>
<td align="center">通过 文本内容+正则表达式 查找</td>
<td align="center"><code>&lt;span&gt;36&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;</code></td>
<td align="center">Elements elements = doc.select(&ldquo;span:matchesOwn(^3)&quot;);注 ：查询规则为  标签名:matchesOwn(正则表达式)</td>
<td></td>
</tr>
</tbody>
</table>
<p><a href="https://blog.csdn.net/wangjunjun2008/article/details/50513528">https://blog.csdn.net/wangjunjun2008/article/details/50513528</a></p>
<h2 id="resultset">Resultset</h2>
<ol>
<li>结果集(ResultSet)是数据中查询结果返回的一种对象，可以说结果集是一个存储查询结果的对象，但是结果集并不仅仅具有存储的功能，他同时还具有操纵数据的功能，可能完成对数据的更新等。</li>
<li>结果集读取数据的方法主要是getXXX()，他的参数可以使整型表示第几列（是从1开始的），还可以是列名。</li>
</ol>
<ul>
<li>返回的是对应的XXX类型的值。如果对应那列时空值，XXX是对象的话返回XXX型的空值，如果XXX是数字类型，如Float等则返回0，boolean返回false。</li>
<li>使用getString()可以返回所有的列的值，不过返回的都是字符串类型的。</li>
</ul>
<ol start="3">
<li>
<p>Connection物件是代表Java与资料库的连线，要执行SQL的话，必须取得 Statement物件，它执行SQL叙述并取得执行之后的结果。</p>
<p>Connection conn = DriverManager.getConnection(url, user, password);
Statement stmt = conn.createStatement();</p>
</li>
</ol>
<ul>
<li>
<p>prepareStatement</p>
<p>/**</p>
<ul>
<li>Creates a <!-- raw HTML omitted -->PreparedStatement<!-- raw HTML omitted --> object for sending</li>
<li>parameterized SQL statements to the database.</li>
<li>
<!-- raw HTML omitted -->
</li>
<li>A SQL statement with or without IN parameters can be</li>
<li>pre-compiled and stored in a <!-- raw HTML omitted -->PreparedStatement<!-- raw HTML omitted --> object. This</li>
<li>object can then be used to efficiently execute this statement</li>
<li>multiple times.</li>
<li></li>
<li>
<!-- raw HTML omitted -->
</li>
<li>parametric SQL statements that benefit from precompilation. If</li>
<li>the driver supports precompilation,</li>
<li>the method <!-- raw HTML omitted -->prepareStatement<!-- raw HTML omitted --> will send</li>
<li>the statement to the database for precompilation. Some drivers</li>
<li>may not support precompilation. In this case, the statement may</li>
<li>not be sent to the database until the <!-- raw HTML omitted -->PreparedStatement<!-- raw HTML omitted --></li>
<li>object is executed.  This has no direct effect on users; however, it does</li>
<li>affect which methods throw certain <!-- raw HTML omitted -->SQLException<!-- raw HTML omitted --> objects.</li>
<li>
<!-- raw HTML omitted -->
</li>
<li>Result sets created using the returned <!-- raw HTML omitted -->PreparedStatement<!-- raw HTML omitted --></li>
<li>object will by default be type <!-- raw HTML omitted -->TYPE_FORWARD_ONLY<!-- raw HTML omitted --></li>
<li>and have a concurrency level of <!-- raw HTML omitted -->CONCUR_READ_ONLY<!-- raw HTML omitted -->.</li>
<li>The holdability of the created result sets can be determined by</li>
<li>calling {@link #getHoldability}.</li>
<li></li>
<li>@param sql an SQL statement that may contain one or more &lsquo;?&rsquo; IN</li>
<li>parameter placeholders</li>
<li>@return a new default <!-- raw HTML omitted -->PreparedStatement<!-- raw HTML omitted --> object containing the</li>
<li>pre-compiled SQL statement</li>
<li>@exception SQLException if a database access error occurs</li>
<li>or this method is called on a closed connection
*/
PreparedStatement prepareStatement(String sql)
throws SQLException;</li>
</ul>
</li>
</ul>
<p>a. 能创造一个用于发送sql语句到数据库的对象<br>
b. 能多次执行sql</p>
<ol start="4">
<li>取得Statement物件之后，可以使用executeUpdate()、executeQuery()等方法来执行 SQL。</li>
</ol>
<ul>
<li>executeUpdate()主要是用来执行CREATE TABLE、INSERT、DROP TABLE、ALTER TABLE等会改变资料库内容的SQL。</li>
<li>executeQuery()方法则是用于SELECT等查询资料库的SQL。</li>
<li>如果事先无法得知是进行查询或是更新，就可以使用execute()。</li>
</ul>
<ol start="5">
<li>executeUpdate()与 executeQuery()都会传回ResultSet物件，代表变更或查询的结果，查询的结果会是一笔一笔的资料，使用next()来移动至下一笔资料。</li>
</ol>
<ul>
<li>传回 true 或 false表示是否有下一笔资料，接着可以使用getXXX()来取得资料，例如getString()、getFloat()、getDouble()等方法，分别取得相对应的栏位型态资料，getXXX()方法都提供有依栏位名称取得资料，或是依栏位顺序取得资料的方法。</li>
</ul>
<ol start="6">
<li>Statement的execute()可以用来执行SQL，并可以测试所执行的SQL是执行查询或是更新，传回 true的话表示SQL执行将传回ResultSet表示查询结果，此时可以使用getResultSet()取得ResultSet物件，如果 execute()传回false，表示SQL执行会传回更新笔数或没有结果，此时可以使用getUpdateCount()取得更新笔数。如果事先无法得知是进行查询或是更新，就可以使用execute()。</li>
</ol>
<h2 id="mysql">MYSQL</h2>
<ul>
<li>在Java 时间戳的类 Instant</li>
<li>MYSQl 大小写的区分用下划线creat_at，Java的creatAt是识别不出来的，所以需要在mybatis 的设置里面添加</li>
</ul>
<h4 id="原则-1">原则</h4>
<ul>
<li>使用GitHub+主干/分支模型进行开发</li>
<li>禁止直接push master</li>
<li>所有的变更通过PR进行</li>
<li>自动化代码质量检查+测试</li>
<li>Checkstyle/SpotBugs</li>
<li>最基本的自动化测试覆盖</li>
<li>一切工作自动化</li>
<li>规范化提交流程</li>
</ul>
<hr>
<h4 id="创建仓库流程-1">创建仓库流程</h4>
<ul>
<li>
<p>Github -new</p>
</li>
<li>
<p>建立新项目
newBranch 的时候选Apache License 2.0</p>
</li>
<li>
<ul>
<li>Mvn archetype</li>
</ul>
</li>
<li>
<ul>
<li>IDEA - new</li>
</ul>
</li>
<li>
<ul>
<li>copy （cp -r ～/* .）</li>
</ul>
</li>
<li>
<p>.gitigonre</p>
</li>
<li>
<p>git commit &ndash;amend 就可以把这一次的commit和上一次的合并起来</p>
</li>
</ul>
<ol>
<li><strong>记得要把<code>.iml</code> 放进（vi .gitignore）： <code>*.iml</code>和<code>target/</code>(放在最后一行就好)</strong></li>
<li>更改pom 里面的groundId，artifactId</li>
<li>cp -r ～/.circleci . (因为之前cp ～* 的时候并不会cp到<code>.~</code>的文件)，保留checkstyle.xml以及congif.yml[自动化测试]</li>
<li><code>.idea/</code> 不能够提交（在最后完成项目提交时）</li>
</ol>
<ul>
<li>README</li>
</ul>
<hr>
<h4 id="项目的设计流程-自顶向下-1">项目的设计流程-自顶向下</h4>
<ul>
<li>多人协作<br>
使用分支可以同时进行不同的功能，且互不影响</li>
<li>模块化</li>
<li>
<ul>
<li>各模块间职责明确，界限清晰</li>
</ul>
</li>
<li>
<ul>
<li>基本的文档</li>
</ul>
</li>
<li>
<ul>
<li>基本的接口</li>
</ul>
</li>
<li>小步提交</li>
<li>
<ul>
<li>大的变更更难以review</li>
</ul>
</li>
<li>
<ul>
<li>大的变更冲突更加棘手</li>
</ul>
</li>
</ul>
<hr>
<h4 id="项目的演进可扩展行-1">项目的演进：可扩展行</h4>
<ul>
<li>单线程-&gt;多线程</li>
<li>console -&gt; H2 database</li>
<li>H2 database -&gt;Elasticsearch</li>
</ul>
<h4 id="爬虫-1">爬虫</h4>
<ul>
<li>新闻网站反爬比较少</li>
<li>手机网页更容易爬</li>
</ul>
<h4 id="git-push-错误的文件-1">git push 错误的文件</h4>
<ul>
<li>在分支上操作</li>
</ul>
<ol>
<li>git reset HEAD~1  把提交回滚到前1/2……各</li>
<li>把不想提交的放进 vi .gitignore 里（.idea/）</li>
<li>git add .</li>
<li>git commit 后就会出现分支</li>
</ol>
<ul>
<li>以master的身份提交</li>
</ul>
<ol>
<li>通过git log 查看刚才提交的提交的ID</li>
<li>git revert 撤销刚才的提交（但是刚才的提交就会消除）</li>
</ol>
<ul>
<li>在主干上直接把多余的文件删掉</li>
<li>只要没有push，所有行为都只有自己能够看到</li>
</ul>
<h4 id="commit-massage-1">commit massage</h4>
<ul>
<li>先写一行简短的总结</li>
<li>详细总结每行不要超过72word</li>
</ul>
<hr>
<h3 id="项目-1">项目</h3>
<ul>
<li>爬去新浪新闻页，做一个真正的爬虫</li>
<li>使用数据库储存进行数据分析</li>
<li>随着数据量的增长，前一到ES</li>
<li>做一个简单的“新闻搜索引擎”</li>
</ul>
<h5 id="算法-1">算法</h5>
<ul>
<li>从一个节点遍历所有节点</li>
<li>广度优先 BFS 从上到下，从左到右，1层-&gt;2层-&gt;3……<br>
队列数据结构、JDK的队列实现</li>
<li>深度优先 1-&gt;2-&gt;4…… 从左到右</li>
</ul>
<h4 id="流程-1">流程</h4>
<ol>
<li>从链接池里拿一个链接</li>
<li>判断链接是否处理</li>
<li>判断链接是否需要</li>
<li>处理</li>
</ol>
<ul>
<li>通过Jsoup获得HTML里面的内容</li>
<li>从池子里删除处理过的链接</li>
</ul>
<ol start="5">
<li>把新得到的链接放入链接池</li>
<li>如果是新闻页面的话储存</li>
<li>进入下一个循环</li>
<li>建立H2数据库</li>
</ol>
<ul>
<li>
<p>LINKS_TO_BE_PROCESSED</p>
</li>
<li>
<p>LINKS_ALREADY_PROCESSED</p>
</li>
<li>
<p>NEWS</p>
</li>
<li>
<p>ID</p>
</li>
<li>
<p>TITLE</p>
</li>
<li>
<p>CONTENT</p>
</li>
<li>
<p>URL</p>
</li>
<li>
<p>CREATED_AT</p>
</li>
<li>
<p>MODIFIED_AT</p>
</li>
</ul>
<h4 id="建立h2数据库-1">建立H2数据库</h4>
<ol>
<li>添加H2依赖</li>
<li>URL “”+/文件路径/数据库的文件名</li>
<li>creat table LINKS_TO_BE_PROCESSED{link varchar (100);}</li>
<li>creat table nws(id bigint primary_key auto_increment,title text,content text,url varchar(100),creat_at timestamp,modified_at timestamp)</li>
<li>insert into links_to_be_processed(link)values(&lsquo;LINK&rsquo;) //设置起始的Link</li>
</ol>
<h4 id="sql数据类型-1">sql数据类型</h4>
<ul>
<li>varchar（n）可变长度字符串，最多为8,000字符</li>
<li>varchar（max）可变长度字符串，最多为1,073,741,824</li>
<li>text 可变长度的字符串，最多2GB文本数据(适合储存新闻)</li>
<li>nchar 固定长度的Unicode字符串。最多4，000个字符</li>
</ul>
<h4 id="flyway">flyway</h4>
<ul>
<li>数据库在使用的时候会不断变更，有不同的版本，flyaway可以储存数据库不同的版本，从而可以变更不同版本的<strong>结构</strong></li>
<li>flyway需要在插件的地方修改URL，添加Username和password</li>
<li>即使数据库删掉也可以快速回复结构</li>
</ul>
<h4 id="orm-object-relation-mapping-对象关系数据库">ORM Object Relation Mapping 对象关系数据库</h4>
<ul>
<li>通过select 语句把表格里面的项目变成对象，</li>
<li></li>
</ul>
<h4 id="tips-1">Tips</h4>
<ol>
<li>Arraylist 从尾部删除更有效率（sive-1）。因为删除第一个元素之后，后面所有的元素都要向前移动一位。</li>
<li>linkPool.remove 删除指定位置的链接后返回被删除的链接</li>
<li>线程卡住的时候可以通过<code>jps</code>查看当前正在运行的线程</li>
<li>链接显示为&rdquo;//……&rdquo; 的话，为当前的链接，需要手动添加&quot;https&quot;+link 进行识别</li>
<li>数据库的用户名和密码最好是使用final常量去声明</li>
<li>想要关闭代码检查findbugs的错误可以通过引入包解决。在相应的地方通过注释SuppressFBWarnings（&ldquo;DMI_CONSTANT_DB_PASSWORD&rdquo;）</li>
<li>如果存在无法关闭的情况，可以通过final强行关闭</li>
<li>try with resoure会自动设置关闭。try（需要声明能close的变量）</li>
<li>HTML是没有换行符的，所以爬虫的时候是爬每一各P元素，加一个换行来分隔</li>
<li>static 方法是不能够访问非static 成员的，static main 才可以运行， 非static 的main 只是一个普通的方法，不能够被运行</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>IDEAMaven调试器的基本使用</title>
            <link>https://procarihana.github.io/public/posts/ideamaven%E8%B0%83%E8%AF%95%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link>
            <pubDate>Wed, 06 May 2020 17:06:17 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/ideamaven%E8%B0%83%E8%AF%95%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid>
            <description>SpotBugs  Maven 生命周期
设置生命周期后的Maven会在相应的阶段执行 Picture 设置 生命周期对应执行的工作需要绑定插件进行设置   complie —— goal ——&amp;gt; maven-compilen-plugin test —— goal ——&amp;gt; surefire 测试插件 verlfy —— goal ——&amp;gt; checkstyle（非核心插件可以绑定到任何阶段  Maven 生命周期  编译源代码   mvn compile   发布项目   mvn deploy   编译测试源代码   mvn test-compile   运行应用程序中的单元测试   mvn test   生成项目相关信息的网站   mvn site   编译源代码   mvn compile   清除项目目录中的生成结果   mvn clean 根据项目生成的jar mvn package 在本地Repository中安装jar mvn install 生成eclipse项目文件 mvn eclipse:eclipse 启动jetty服务 mvn jetty:run 启动tomcat服务 mvn tomcat:run 清除以前的包后重新打包，跳过测试类 mvn clean package -Dmaven.</description>
            <content type="html"><![CDATA[<h4 id="spotbugs">SpotBugs</h4>
<ul>
<li>Maven 生命周期<br>
设置生命周期后的Maven会在相应的阶段执行
Picture 设置</li>
<li>生命周期对应执行的工作需要绑定插件进行设置</li>
</ul>
<ol>
<li>complie —— goal ——&gt; maven-compilen-plugin</li>
<li>test —— goal ——&gt; surefire 测试插件</li>
<li>verlfy —— goal ——&gt; checkstyle（非核心插件可以绑定到任何阶段</li>
</ol>
<h2 id="maven-生命周期">Maven 生命周期</h2>
<ul>
<li>编译源代码</li>
<li>
<ul>
<li>mvn compile</li>
</ul>
</li>
<li>发布项目</li>
<li>
<ul>
<li>mvn deploy</li>
</ul>
</li>
<li>编译测试源代码</li>
<li>
<ul>
<li>mvn test-compile</li>
</ul>
</li>
<li>运行应用程序中的单元测试</li>
<li>
<ul>
<li>mvn test</li>
</ul>
</li>
<li>生成项目相关信息的网站</li>
<li>
<ul>
<li>mvn site</li>
</ul>
</li>
<li>编译源代码</li>
<li>
<ul>
<li>mvn compile</li>
</ul>
</li>
<li>清除项目目录中的生成结果</li>
<li>
<ul>
<li>mvn clean
根据项目生成的jar
mvn package
在本地Repository中安装jar
mvn install
生成eclipse项目文件
mvn eclipse:eclipse
启动jetty服务
mvn jetty:run
启动tomcat服务
mvn tomcat:run
清除以前的包后重新打包，跳过测试类
mvn clean package -Dmaven.test.skip=true</li>
</ul>
</li>
</ul>
<p>[https://segmentfault.com/a/1190000015077021]</p>
]]></content>
        </item>
        
        <item>
            <title>Java的运算系统</title>
            <link>https://procarihana.github.io/public/posts/java%E7%9A%84%E8%BF%90%E7%AE%97%E7%B3%BB%E7%BB%9F/</link>
            <pubDate>Fri, 01 May 2020 16:42:24 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/java%E7%9A%84%E8%BF%90%E7%AE%97%E7%B3%BB%E7%BB%9F/</guid>
            <description>基本运算   /
int b = 5/2; &amp;ndash;&amp;gt;结果为 &amp;lsquo;2&amp;rsquo;（地板除）
  取余运算
5/2=2……1
System.out.println(9 % 5);——&amp;gt;2 System.out.println(-9 % 5);——&amp;gt;-2(余数)      判断奇偶
通过取余是否为零完成
//判断一个整数是不是奇数 public static boolean isOdd(int number){ return number % 2 != 0; }    运算符
    += ，-= ，*=，/=
Eg：a+=2 | a = a+2
  += a +=3 ==&amp;gt; a = a + 3
  -= a -=3 ==&amp;gt;a - e</description>
            <content type="html"><![CDATA[<h4 id="基本运算">基本运算</h4>
<ul>
<li>
<p>/</p>
<p>int b = 5/2;
&ndash;&gt;结果为 &lsquo;2&rsquo;（地板除）</p>
</li>
<li>
<p>取余运算</p>
<p>5/2=2……1</p>
<pre><code>System.out.println(9 % 5);——&gt;2
System.out.println(-9 % 5);——&gt;-2(余数)
</code></pre>
</li>
</ul>
<ol>
<li>
<p>判断奇偶<br>
通过取余是否为零完成</p>
<pre><code>//判断一个整数是不是奇数
  public static boolean isOdd(int number){
      return number % 2 != 0;
}
</code></pre>
</li>
<li>
<p>运算符</p>
</li>
</ol>
<ul>
<li>
<p>+= ，-= ，*=，/=<br>
<strong>Eg：a+=2 | a = a+2</strong></p>
</li>
<li>
<p>+= <br>
a +=3  ==&gt; a = a + 3</p>
</li>
<li>
<p>-= <br>
a -=3  ==&gt;a - e</p>
</li>
<li>
<p>%=    a
a %=3  ==&gt;a % 3</p>
</li>
<li>
<p>二元一次开根Eg</p>
<pre><code>   public static double[] calculate(int a, int b, int c) {
     double d = b * b - 4 * a * c;
     if (d &gt; 0){
         double root1 = ((-b + Math.sqrt(d)) / 2 * a);
         double root2 = ((-b - Math.sqrt(d)) / 2 * a);
         return new double[]{root1,root2};
        }else if(d == 0) {
        double root = ((-b + Math.sqrt(d)) / 2 * a);
          return new double[]{root};
   }else if (d &lt; 0){
       return new double[]{};
   }
  return null;
</code></pre>
</li>
</ul>
<ol start="3">
<li>自增自减 i++，i&ndash;,++i,&ndash;i</li>
</ol>
<ul>
<li>
<p>i++ | i=i+1 | i+= 1</p>
<pre><code>    i++;  ==&gt; i=i+1/ i+=1
          1、i作为表达式的值 ==&gt;System.out.println(i++);==&gt;0
          
          2、i = i + 1（a+=）
            i = 1
</code></pre>
<p>++i; ==&gt; 1、b = b + 1</p>
<pre><code>        2、把结果作为表达式的值 ==&gt;System.out.println(i++);==&gt;1
</code></pre>
</li>
</ul>
<hr>
<ul>
<li>
<p>i++ vs ++i</p>
<pre><code>public static void printNumberTo10(int number) {
   while (true) {
       System.out.println(number++);
       if (number &gt; 10) {
              return;
       }
   }
 } // ——&gt; 包括number本身             
</code></pre>
</li>
</ul>
<hr>
<pre><code>    i = 0；
    x = 0;
    System.out.print(i++);
    System.out.print(++x);
        result: i++ = 0,i = 1;
                ++x = 1,x = 1;
</code></pre>
<ol start="4">
<li>比较运算符</li>
</ol>
<ul>
<li>
<p>结果是一个布尔值</p>
<pre><code>   Eg：
   System.out.println(2 == 1);  ==&gt; true
   System.out.println(2 &gt; 1);  ==&gt; false
</code></pre>
</li>
</ul>
<ol start="5">
<li>逻辑运算</li>
</ol>
<ul>
<li>&amp;&amp; <strong>与：只要有一个是假的就都是假的</strong></li>
<li>|| <strong>或：只要有一个是真的就都是真的</strong></li>
<li>！非（相反）</li>
<li>短路</li>
</ul>
<p>或：左侧结果是真的，后面的结果就会自动忽略掉（不会影响结果）
与：左侧结果是假的……</p>
<pre><code>  Boolean config = getconfig()
    if (config != null &amp;&amp; config) {
        /*config 的三种可能
          1: true -&gt; true
          2: false -&gt; false
        */3: null -&gt; false
    }
   public static Boolean getconfig(){
    //可能返回ture/false/null
    }
</code></pre>
<p><strong>Eg：装拆箱的时候，对象为null的时候拆箱就会出现空指针异常，可以通过先判断是否为null来避免，用&amp;&amp;进行逻辑运算，当为null的时候直接结束运算。</strong></p>
<ol start="6">
<li>三元运算符 ?:</li>
</ol>
<ul>
<li>
<p>一元：int a = 1;  a++</p>
</li>
<li>
<p>二元：a = a + 1; 9 % 5</p>
</li>
<li>
<p>三元运算嵌套</p>
<pre><code>   //当 a &gt; 0时，得到&quot;&gt;&quot;，否则，得到&quot;&lt;=&quot;
  String sign;

  if (a &gt; 0){
      sign = &quot;&gt;&quot;;
  }else {
      sign = &quot;&lt;=&quot;;
  }

  //三元运算符重写这个过程：

  sign = a &gt; 0 ? &quot;&gt;&quot; : &quot;&lt;=&quot;;

  //若 a &gt; b 返回 1
  //若 a &lt; b 返回 -1
  //若 a = b 返回 0
   int result = a &gt; b ? 1 : (a &lt; b ? -1 :0);
     
   return 100 &gt;= score &amp;&amp; score &gt;= 90 ? &quot;学生&quot;+student+&quot;的分数是&quot;+score+&quot;,评级是A&quot; : (89 &gt;= score &amp;&amp; score &gt;= 60 ? &quot;学生&quot;+student+&quot;的分数是&quot;+score+&quot;,评级是B&quot; : (59 &gt;= score &amp;&amp; score &gt;= 0 ? &quot;学生&quot;+student+&quot;的分数是&quot;+score+&quot;,评级是C&quot; :&quot;非法输入&quot; ));
</code></pre>
</li>
</ul>
<ol start="7">
<li>位运算</li>
</ol>
<ul>
<li>~ 按位取反 把字符的字节里面0变成1，1变成0</li>
<li>补码：+1</li>
<li>负数是通过补码表示的</li>
</ul>
<table>
<thead>
<tr>
<th align="center">4</th>
<th align="center">0000</th>
<th align="center">0100</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">取反</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th align="center">~</th>
<th align="center">1111</th>
<th align="center">1011</th>
</tr>
</thead>
</table>
<p>+1</p>
<hr>
<table>
<thead>
<tr>
<th align="center">-4</th>
<th align="center">0000</th>
<th align="center">1100</th>
</tr>
</thead>
</table>
<ul>
<li>补码可以完成加法和减法（不进位加法）
<strong>Eg：5-3</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">5</th>
<th align="center">0000</th>
<th align="center">0101</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th align="center">3</th>
<th align="center">0000</th>
<th align="center">0011</th>
</tr>
</thead>
</table>
<p>取反补位</p>
<hr>
<table>
<thead>
<tr>
<th align="center">-3</th>
<th align="center">1111</th>
<th align="center">1101</th>
</tr>
</thead>
</table>
<hr>
<hr>
<table>
<thead>
<tr>
<th align="center">5+（-3）</th>
<th align="center">10000</th>
<th align="center">0100</th>
</tr>
</thead>
</table>
<p>去掉第一位</p>
<hr>
<table>
<thead>
<tr>
<th align="center">2</th>
<th align="center">0000</th>
<th align="center">0010</th>
</tr>
</thead>
</table>
<ul>
<li>&amp; &amp;= 按位与  ：每个位进行一次与操作（有一个是0，则都是0）【And】</li>
</ul>
<p>0000 0011   3</p>
<p>0000 0101   5</p>
<hr>
<p>0000 0001   1</p>
<ul>
<li>| |= 按位或 ：有一个是1，则就是1【or】</li>
</ul>
<p>0000 0110   6</p>
<p>0000 1000   8</p>
<hr>
<p>0000 1110   14</p>
<pre><code>Y ^ Y = 0 
Y ^ 0 = Y 
Eg:
[1,2,3,4,5,6]
[1,2,3,4,2,1]
//找重复出现的数则用异或
</code></pre>
<p>判断字符串里是否有某个字符</p>
<pre><code>public static boolean isValidHexCharacter(char ch) {
    byte bch = (byte) ch;
    String str = &quot;0123456789AaBbCcDdEeFf&quot;;
    for (int i = 0; i &lt; str.length(); i++) {
        int b = (int) str.charAt(i);
        int d = b ^ bch;
        if (d == 0) {
            return true;
        }
    }
    return false;
}
</code></pre>
<p>位运算代替boolean</p>
<pre><code>public class Cat {
   private static int CUTE = 0x1;
   private int properties = 0;

/**
 * 使用位运算设置猫咪萌的属性
 *
 * @param cute true为萌，false为不萌
 */
public void setCute(boolean cute) {
    properties = cute? (properties | CUTE) : (properties &amp;(~CUTE));//true为1 ，false为0
    
}

/**
 * 这只猫萌吗？请在此处使用位运算读取properties，得到猫是否萌的结果
 *
 * @return 萌则返回true，否则返回false
 */
public boolean isCute() {
    return (properties &amp; CUTE) != 0;
}
</code></pre>
<ul>
<li>&laquo;=左移【&laquo;】</li>
</ul>
<p>0000 0101     |5[左移一位]</p>
<p><del>0</del> 0000 101++0++    |  5 * 2 ^ 1 = 10（去掉最前一位，后面补一个0）</p>
<p>0000 0101   |5[左移2位]</p>
<p><del>00</del>  0001 01++00++  5* 2 ^ 2= 20</p>
<p>对任何进制进行左移操作，就是乘以这个进制的基数
左移n为，相当于乘以2的n次方</p>
<ul>
<li><code>&gt;&gt;</code> &raquo;=带符号右移：该数对应的二进制码整体右移，左边的用原有标志位（原本是1就用1，是0就用0）补充，右边超出的部分舍弃。</li>
</ul>
<p>1(表示符号'+&rsquo;) 111 1110</p>
<p>0(表示符号&rsquo;-') 111 1110</p>
<ul>
<li><code>&gt;&gt;&gt;</code> &raquo;&gt;=无符号右移：不管正负标志位为0还是1，将该数的二进制码整体右移，左边部分总是以0填充，右边部分舍弃。</li>
</ul>
<p>-5用二进制表示1111 1011 <em>标志</em>位</p>
<p>-5&raquo;2: <em>1</em>111 1011&mdash;&mdash;&mdash;&mdash;&ndash;&gt;<strong>11</strong> <em>1</em>1 1110。</p>
<p><strong>11</strong>为标志位</p>
<p>-5&raquo;&gt;2:  <em>1</em>111 1011&mdash;&mdash;&mdash;&mdash;&ndash;&gt;<strong>00</strong> <em>1</em>1 1110。</p>
<p><strong>00</strong>为补充的0</p>
<p>位运算：</p>
<ol>
<li>设置属性某一位上面是1，其他都是0。</li>
<li>然后进行按位与（与过有1的都是1），从而把属性都放进int里面，只需要4个字节
boolean： 存放需要32个字节</li>
</ol>
<ul>
<li>
<p>设置<code>|</code>  无论原先是0还是1 ，进行按位或1操作最后都是1</p>
</li>
<li>
<p>读取<code>&amp;</code>  无论原先是0还是1 ，进行按位与1操作最后都是1</p>
</li>
<li>
<p>不用乘除号进行运算</p>
<pre><code>  // 返回number乘以16的结果
  // 请不要使用乘号
  public static int multiply16(int number) {
      return number &lt;&lt; 4;
  }
  // 返回number除以16的结果
  // 请不要使用除号
  public static int divide16(int number) {
       return number &gt;&gt; 4;
   }
</code></pre>
</li>
</ul>
<ol start="8">
<li>运算符的优先级</li>
</ol>
<ul>
<li>乘除高于加减</li>
<li>其他全部加括号</li>
</ul>
<ol start="9">
<li>字符串加法</li>
</ol>
<ul>
<li>对象进行字符串加法的时候，就会把相应的toString方法或者原生类型的相应表示</li>
<li>字符串加法会自动调用StringBuilder，减轻内存压力。因为对象是不可改变的，进行运算的时候会残生很多新的对象，造成储存空间的浪费。</li>
</ul>
<h2 id="取余">取余</h2>
<ul>
<li>只适用于整数</li>
</ul>
<h2 id="异或">异或</h2>
<p>两个数的二进制位 相比较 相同为0 不同为  ,结果为〇是两个数就是相等</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
</tr>
</thead>
</table>
<h2 id="题目">题目</h2>
<ol>
<li>寻找没有出现过的数字</li>
</ol>
<ul>
<li>位运算中的异或运算 XOR，主要因为异或运算有以下几个特点：</li>
<li>
<ul>
<li>一个数和 0 做 XOR 运算等于本身：a⊕0 = a</li>
</ul>
</li>
<li>
<ul>
<li>一个数和其本身做 XOR 运算等于 0：a⊕a = 0</li>
</ul>
</li>
<li>
<ul>
<li>XOR 运算满足交换律和结合律：a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b</li>
</ul>
</li>
<li>故而在以上的基础条件上，将所有数字按照顺序做抑或运算，最后剩下的结果即为唯一的数字</li>
<li>时间复杂度：O(n)O(n)，空间复杂度：O(1)O(1)</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">singleNumber</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> num<span style="color:#f92672">:</span> nums<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            ans <span style="color:#f92672">^=</span> num<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> ans<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Java的数据类型</title>
            <link>https://procarihana.github.io/public/posts/java%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
            <pubDate>Wed, 29 Apr 2020 15:16:54 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/java%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
            <description>数据类型  Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节。 两种数据类型   原生数据 赋值的是值本身 引用数据类型 对象 本质上就都是地址 赋值的是地址     原生数据 字节 最小值 最大值     byte 1     short 2  0*7fffffff(21亿)   int 4     long 8  2^63-1   float 4     double 8     char 2        基本数据类型的运算，会自动向上转型。 boolean不可以和其他基本数据类型相互转换。 byte-&amp;gt;short,char -&amp;gt; int -&amp;gt; long float -&amp;gt; double int -&amp;gt; float long -&amp;gt; double    boolean true/false void    存储数据超过最大值会溢出</description>
            <content type="html"><![CDATA[<h4 id="数据类型">数据类型</h4>
<ul>
<li>Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节。</li>
<li>两种数据类型</li>
</ul>
<ol>
<li>原生数据 赋值的是值本身</li>
<li>引用数据类型 对象 本质上就都是地址 赋值的是地址</li>
</ol>
<table>
<thead>
<tr>
<th align="center">原生数据</th>
<th align="center">字节</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">byte</td>
<td align="center">1</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2</td>
<td align="center"></td>
<td align="center">0*7fffffff(21亿)</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8</td>
<td align="center"></td>
<td align="center">2^63-1</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">2</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>基本数据类型的运算，会自动向上转型。</li>
<li>boolean不可以和其他基本数据类型相互转换。</li>
<li>byte-&gt;short,char -&gt; int -&gt; long</li>
<li>float -&gt; double</li>
<li>int -&gt; float</li>
<li>long -&gt; double</li>
</ul>
</blockquote>
<ul>
<li>boolean true/false</li>
<li>void</li>
</ul>
<hr>
<ul>
<li>存储数据超过最大值会溢出<br>
<em>Eg：（byte）127+1=-128</em></li>
<li>float 浮点数 是小数，在计算机中<strong>近似表示</strong><br>
<em>Eg：0.1+0.2=0.300000000004</em>
*1 - 0.9f = 0.099999……8 *</li>
<li>double 双精浮点数</li>
<li>浮点数判断大小，不可以比较相等  <code>==</code>可能可以工作，但是不安全
Math.abc(d-0.0)&lt;0.0000001
//通过绝对值判断浮点数d是否为0</li>
</ul>
<blockquote>
<ul>
<li>浮点数0.1在计算机中就无法精确表示，因为十进制的0.1换算成二进制是一个无限循环小数，很显然，无论使用float还是double，都只能存储一个0.1的近似值。但是，0.5这个浮点数又可以精确地表示。</li>
</ul>
</blockquote>
<p>因为浮点数常常无法精确表示，因此，浮点数运算会产生误差：</p>
<ul>
<li>
<p>long、float、double 声明值</p>
<pre><code>  long l = 0L;
  float f = 0.0f;
  double d = 0.0d;
  double e = 2e-3;//科学计算法可以在浮点数里使用
</code></pre>
</li>
</ul>
<h4 id="二进制">二进制</h4>
<ol>
<li>字节：计算机内存能够寻址的最小单位</li>
<li>int 32 位 31个1 二进制</li>
<li>ASCII 码 最常用的字符的对照表</li>
</ol>
<ul>
<li>可以通过int的强制转换看到字符的对应数字表</li>
</ul>
<ol start="4">
<li>强类型:即使数据一样，但是类型不一样，解释也不一样</li>
<li>16进制 0-9 a-f 不区分大小写</li>
</ol>
<h4 id="类型转换与类型提升">类型转换与类型提升</h4>
<ul>
<li>
<p>高精度的 转化为低精度的不会出现问题，但是反过来就可能会损失数据</p>
</li>
<li>
<p>整数除法是地板除：除的结果如果不能整出，就会向下取值<br>
<strong>Eg：3/2=1</strong><br>
<em>解决：把所有值（或者其中一个，另一个就会激动提高精度）都提高到最高的精度进行计算</em></p>
</li>
<li>
<p>丢失精度的时候需要进行强制转换<br>
<strong>Eg：int i；double d =（double）i</strong></p>
</li>
<li>
<p>ASKII码表：前128个最常用的字符</p>
<pre><code> //在ASKII中数据49为字符‘1’，数据50为字符‘2’
 char c = '1';//完全等价于char c = 49
 c = (char)(c+1);//完全等价于char c = 50
</code></pre>
</li>
</ul>
<h4 id="基本数据类型的装箱类型">基本数据类型的装箱类型</h4>
<ol>
<li>区分是不是对象，通过判断有没有对应的类<br>
<strong>Eg：int i = 0是原生数据；Integer integer = 0 是对象</strong></li>
</ol>
<ul>
<li>因为Integer是integer对应的类，而integer只是一个地址，指向存储‘100’的数据，这个过程通过自动装拆箱完成</li>
</ul>
<ol start="2">
<li>自动装拆箱<br>
<strong>Eg:当你声明int i，而需要用到Integer的时候，ide就会自动进行装箱<br>
Integer integer = i 这个过程</strong></li>
</ol>
<h4 id="引用类型装箱意义">引用类型，装箱意义</h4>
<ol>
<li>容器类不接受原生数据类型（List/Set</li>
<li>可以赋值null</li>
</ol>
<ul>
<li>null意义：Boolean可以有true/false和null三种状态，而boolean只有两种</li>
<li>null会在自动装拆箱中出现问题，因为原生数据没有null，当引用为null的时候，拆箱过程中就会出现空指针异常</li>
</ul>
<ol start="3">
<li>提供额外的方法<br>
<strong>Eg:可以通过Integer.parseInt把字符转换成数字</strong></li>
<li>自动装箱与拆箱</li>
</ol>
<h4 id="null与equals约定在数据类型中的应用">null与equals约定在数据类型中的应用</h4>
<ol>
<li>== 比较原生数据的时候，比较的是值是否相同；而比较对象的时候，实质比较的是地址是否相同</li>
<li>equals 是object的子类，比较两个对象的数据value是否相同</li>
<li>Integer 常用的数字（-128～127）有缓存，所以使用==判断这个范围的数据的时候，地址会相等</li>
<li>Integer 对象不可变，只能去读取里面的内容，不能去修改里面的数据</li>
</ol>
<h4 id="数组类型">数组类型</h4>
<ul>
<li>有JDK负责创建</li>
</ul>
<ol>
<li>X[] x = new X[10] 创造一个数组x，里面有10个元素</li>
<li>X[] x =new [] {2，1，3，4}</li>
<li>X[][] x = new int [] []<code>{``{``}</code>,<code>{``}``}</code> 嵌套数组</li>
<li>其中X可以也是数组类型</li>
</ol>
<ul>
<li>数组的主要特性</li>
</ul>
<ol>
<li>⻓度不可变</li>
<li>类型安全</li>
<li>只有⼀个length属性</li>
<li>可以使⽤for循环迭代</li>
</ol>
<h2 id="包装类的运算在不遇到算术运算的情况下不会自动拆箱">包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱</h2>
<p>包装类的equals()方法不处理数据转型</p>
<h2 id="gbk----utf-8">“GBK” &ndash;&gt; &ldquo;UTF-8&rdquo;</h2>
<p>dst=new String(src，&ldquo;GBK&rdquo;).getBytes(&ldquo;UTF-8&rdquo;)</p>
<h2 id="tostring-和-new-string-区别">toString 和 New String 区别</h2>
<ul>
<li>
<p>一个对象toString()方法如果没有被重写，那么默认调用它的父类Object的toString()方法。Object类的toString()方法返回一个能够代表该对象的字符串，由类名（对象是该类的一个实例）、“@”和此对象哈希码的无符号十六进制表示组成，即
<code>getClass().getName() + '@' + Integer.toHexString(hashCode())</code></p>
</li>
<li>
<p>而new String()的接受的参数（这里仅仅指首个参数）类型包括byte[]、char[]、StringBuffer、StringBuilder、String、int[]（ASCII码），将这些类型的字符数组或字符串或相似类型转化为String类型。</p>
</li>
<li>
<p>警告正是基于两者的区别，将byte[]或char[]转化为String时不能使用toString()方法，而应使用new String()。</p>
</li>
<li>
<p>(String)转型和toString()区别的问题。前者是将对象直接转型为String，而后者是调用了toString()方法。所以对于可达到同样目的不影响前后使用时，应优先使用前者，因为其没有外部方法调用，效率更高。</p>
</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Java程序的基本结构</title>
            <link>https://procarihana.github.io/public/posts/java%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</link>
            <pubDate>Tue, 28 Apr 2020 16:58:28 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/java%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</guid>
            <description>Java程序的基本结构 Java 简述  强类型：在内存的每一个数据都需要和一个类型相绑定   即使数据相同，但是类型不一样，解释的方式也不一样  静态   Java code &amp;ndash;&amp;gt; 字节码 （编译）  跨平台性能   操作系统  Linux、windows、mac…… 不同的操作系统有不同的语言 （API 【Application Programming Interface】 应用编程接口）&amp;ndash;&amp;gt;实现跨平台就要通过JVM实现   JVM 【Java Vitual Mach】（Java虚拟机） 字节码   最小单位为字节，八个字节为一个字节码   Java 成句基本结构 类和包的关系  基本结构&amp;ndash;类，Java 程序的最小的结构单元，按照约定放在自己同名的&amp;rsquo;.java&amp;rsquo; 文件中 每个 Class 都处于一个package中 Package 的名字是相对于src决定的，也就是由目录结构确定的，名字通常用域名的倒叙 如果class 直接放在java文件夹下面，就不会显示package 因为处于默认包里面  包的意义  类的名字是一个简单的字符串，通过包更容易区分 Eg：通过运用全限定类名，可以用于区分不同的同名类   全限定类名 ：包含包名的类&amp;ndash;&amp;gt;package.class  可以通过import引入包，可以让引用类的编写更加便捷  第三方包的引用  Maven 当方法属于Java.</description>
            <content type="html"><![CDATA[<h1 id="java程序的基本结构">Java程序的基本结构</h1>
<h3 id="java-简述">Java 简述</h3>
<ol>
<li>强类型：在内存的每一个数据都需要和一个类型相绑定</li>
</ol>
<ul>
<li>即使数据相同，但是类型不一样，解释的方式也不一样</li>
</ul>
<ol start="2">
<li>静态</li>
</ol>
<ul>
<li>Java code &ndash;&gt; 字节码 （编译）</li>
</ul>
<ol start="3">
<li>跨平台性能</li>
</ol>
<hr>
<h3 id="操作系统">操作系统</h3>
<ol>
<li>Linux、windows、mac……</li>
<li>不同的操作系统有不同的语言 （API 【Application Programming Interface】 应用编程接口）&ndash;&gt;实现跨平台就要通过JVM实现</li>
</ol>
<ul>
<li>JVM 【Java Vitual Mach】（Java虚拟机）</li>
<li>字节码</li>
</ul>
<ol>
<li>最小单位为字节，八个字节为一个字节码</li>
</ol>
<hr>
<h3 id="java-成句基本结构">Java 成句基本结构</h3>
<h4 id="类和包的关系">类和包的关系</h4>
<ol>
<li>基本结构&ndash;类，Java 程序的最小的结构单元，按照约定放在自己同名的&rsquo;.java&rsquo; 文件中</li>
<li>每个 Class 都处于一个package中</li>
<li>Package 的名字是相对于src决定的，也就是由目录结构确定的，名字通常用域名的倒叙</li>
<li>如果class 直接放在java文件夹下面，就不会显示package 因为处于默认包里面</li>
</ol>
<h4 id="包的意义">包的意义</h4>
<ol>
<li>类的名字是一个简单的字符串，通过包更容易区分
Eg：通过运用全限定类名，可以用于区分不同的同名类</li>
</ol>
<ul>
<li>全限定类名 ：包含包名的类&ndash;&gt;package.class</li>
</ul>
<ol start="2">
<li>可以通过import引入包，可以让引用类的编写更加便捷</li>
</ol>
<h4 id="第三方包的引用">第三方包的引用</h4>
<ol>
<li>Maven</li>
<li>当方法属于Java.lang的时候后，不需要特地去引用</li>
</ol>
<h4 id="方法静态方法与静态成员变量">方法、静态方法与静态成员变量</h4>
<ol>
<li>方法</li>
</ol>
<ul>
<li>静态方法:就是一个函数，一个不依附于任何对象的方法，不用去创造任何对象</li>
</ul>
<ol start="2">
<li>函数调用</li>
</ol>
<ul>
<li>每次函数调用的时候会产生新的独立的环境</li>
<li>函数调动可以多次调用，调用完成后，局部变量就会被销毁</li>
</ul>
<ol start="3">
<li>
<p>局部变量的作用域在第一对花括号里面</p>
<pre><code>     public static int result(int a,int b)
</code></pre>
</li>
<li>
<p>成员变量 ：和一个对象绑定的变量</p>
<pre><code> public class Cat{
     private String name;
     }
</code></pre>
</li>
<li>
<p>静态成员变量：是一个类的成员，方法调用后的结果会持续存在，独立于任何的函数调用，函数调用结束后都不会被销毁<br>
<code>public static int i</code></p>
</li>
<li>
<p><code>static</code>不和任何对象绑定</p>
</li>
</ol>
<h4 id="对象结构与成员变量">对象、结构与成员变量</h4>
<ol>
<li>类 说明书，说明方法如何调用，调用后会得到什么机结果</li>
<li>对象（实例） 通过new一个构造函数，从而创造出一个对象<br>
<code>Cat cat = new Cat();</code></li>
<li>构造器</li>
</ol>
<ul>
<li>
<p>没有生命任何的constructor构造器，编译器会自动构造一个</p>
</li>
<li>
<p>一个特殊的实例方法</p>
<pre><code>Cat(){}//编译器自动生成
</code></pre>
</li>
</ul>
<hr>
<pre><code>public Cat(String name){
    this.name = name;
}
</code></pre>
<ul>
<li>构造器里面可以声明参数</li>
<li>可以写public</li>
<li>没有返回值（返回的是构造函数的一个实例）</li>
<li>可以声明多个构造器</li>
</ul>
<ol start="4">
<li><code>this</code> 的使用：在不构成歧义的情况下可以不使用</li>
</ol>
<h4 id="实例方法与空指针异常">实例方法与空指针异常</h4>
<ol>
<li>实例方法 和对象相绑定的方法，只有实例才能够调用</li>
<li>空指针异常 会在对对象取属性或者调用实例方法的时候后发生</li>
</ol>
<ul>
<li>解决：可以通过if else 为null 进行判断</li>
</ul>
<h4 id="sum">sum</h4>
<ol>
<li>静态变量 不和任何对象绑定，一个全局的存储单元，被所有对象所共享。在所有的对方都可以对这个变量进行读写。</li>
<li>静态方法 不和任何实例对象相绑定</li>
<li>成员变量，没有static 限定，和一个对象紧密绑定的</li>
<li>实例方法 不能仅通过一个类名去引用，需要先创造出一个实例对象，这个对象才可以去调用这个方法。</li>
</ol>
<ul>
<li>在构造器里面可以直接调用实例方法</li>
</ul>
<hr>
<h4 id="对象与引用">对象与引用</h4>
<ol>
<li>引用 == 地址</li>
<li>所有的对象都是地址，一个实例被创造出来，实际上就是创造出一个地址，指向自己类的内存空间。对象被进行赋值的时候，只是地址被进行复制，而对象本身并没有改变。</li>
<li>深拷贝deepCopy 浅拷贝</li>
</ol>
<ul>
<li>浅拷贝只是复制了地址，并没有复制对象的所数据
<img src="/%E6%B5%85%E6%8B%B7%E8%B4%9D.png" alt="浅拷贝"></li>
<li>深拷贝需要创造所有的对应的对象进行拷贝,把对象的所有值都进行赋值。地址虽然不一样，但是通过赋值可以的到一样的数据
<img src="/%E6%B7%B1%E6%8B%B7%E8%B4%9D.png" alt="深拷贝"></li>
</ul>
<hr>
<h4 id="对象与引用-1">对象与引用</h4>
<ol>
<li>引用 == 地址</li>
<li>所有的对象都是地址，一个实例被创造出来，实际上就是创造出一个地址，指向自己类的内存空间。对象被进行赋值的时候，只是地址被进行复制，而对象本身并没有改变。</li>
<li>深拷贝deepCopy 浅拷贝</li>
</ol>
<ul>
<li>浅拷贝只是复制了地址，并没有复制对象的所数据</li>
<li>深拷贝需要创造所有的对应的对象进行拷贝</li>
</ul>
<h4 id="方法的传值-vs-传引用">方法的传值 vs 传引用</h4>
<ol>
<li>
<p>传值 通过引用的方法传值，只是把数据赋值一遍,修改是不会生效的。因为执行方法的时候后会创建一个全新的环境，结束后数据就会销毁。</p>
<p>public static void main (String [] args){
int i = 0;
addOne(i);
}
static void int addOne(int i){
i = i+1
}</p>
</li>
<li>
<p>传引用 本质为传递地址</p>
<pre><code> public static void main (String [] args){
     Cat cat = new Cat();
     cat.name = &quot;111&quot;;
     renameCat(cat);
 }

 stativ void renameCat(Cat cat){ 
  //在Cat这个类的储存空间里面赋值，把结果的地址传递给main里面的cat
  cat.name = &quot;mewo&quot;
 }
</code></pre>
</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>The Second Test</title>
            <link>https://procarihana.github.io/public/posts/the-second-test/</link>
            <pubDate>Sun, 26 Apr 2020 18:49:13 +0800</pubDate>
            
            <guid>https://procarihana.github.io/public/posts/the-second-test/</guid>
            <description>Test Second </description>
            <content type="html"><![CDATA[<h3 id="test">Test</h3>
<h1 id="second">Second</h1>
<p><img src="/1.jpg" alt=""></p>
]]></content>
        </item>
        
    </channel>
</rss>
