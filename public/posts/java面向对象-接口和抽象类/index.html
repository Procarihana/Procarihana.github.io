<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="Hana ">
<meta name="description" content="问题：如何禁止默认实现 强制要求覆盖方法
 抛出异常  在空的方法里面设置UnsupportedOperationException（）；
   缺点：编译的时候不会报错，运行的时候抛出异常     原因：abstruct是一个抽象集合，有时候这个集合不可变，不可以往里面添加（不支持修改，不可变）   抽象化 抽象方法必须在抽象类中 抽象方法不能够实例化  强制提供默
 抽象类  可以有成员，可以有构造器，可以有实例方法
 实现 抽象  Abstruct 有时候是不可变，不可以添加东西
 接口  抽象类 除了用abstruct声明之外，和其他类没有本质上的区别
 不可实例化
没有方法体的方法 可以拥有抽象的方法 abstruct void methon（）； 可以是实例化的东西一定要补全所有的方法体
因为抽象方法没有执行的内容，执行也没有内容可执行，所以必须要补全方法体 可以包含抽象方法 非private/static   抽象方法目的是让人继承     继承多态只发生在实例里面，因此不能用static，没有意义     private不能被子类访问继承，继承也没有用   可以包含普通类的任何东西
内部类、成员变量……  AbstructCollection 集合 AbstructList 列表（有序）" />
<meta name="keywords" content=", , " />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/" />


    <title>
        
            Java面向对象  接口和抽象类 :: FAFA Blog  — Just for fun
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="https://procarihana.github.io/public/main.d1ea4af8fd04fb24a4f8b882ea54bd04eb245427ca4baf527c81a5dab071410b.css">






<meta itemprop="name" content="Java面向对象  接口和抽象类">
<meta itemprop="description" content="问题：如何禁止默认实现 强制要求覆盖方法
 抛出异常  在空的方法里面设置UnsupportedOperationException（）；
   缺点：编译的时候不会报错，运行的时候抛出异常     原因：abstruct是一个抽象集合，有时候这个集合不可变，不可以往里面添加（不支持修改，不可变）   抽象化 抽象方法必须在抽象类中 抽象方法不能够实例化  强制提供默
 抽象类  可以有成员，可以有构造器，可以有实例方法
 实现 抽象  Abstruct 有时候是不可变，不可以添加东西
 接口  抽象类 除了用abstruct声明之外，和其他类没有本质上的区别
 不可实例化
没有方法体的方法 可以拥有抽象的方法 abstruct void methon（）； 可以是实例化的东西一定要补全所有的方法体
因为抽象方法没有执行的内容，执行也没有内容可执行，所以必须要补全方法体 可以包含抽象方法 非private/static   抽象方法目的是让人继承     继承多态只发生在实例里面，因此不能用static，没有意义     private不能被子类访问继承，继承也没有用   可以包含普通类的任何东西
内部类、成员变量……  AbstructCollection 集合 AbstructList 列表（有序）">
<meta itemprop="datePublished" content="2020-09-22T18:02:40&#43;08:00" />
<meta itemprop="dateModified" content="2020-09-22T18:02:40&#43;08:00" />
<meta itemprop="wordCount" content="1509">
<meta itemprop="image" content="https://procarihana.github.io/public/"/>



<meta itemprop="keywords" content=",," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://procarihana.github.io/public/"/>

<meta name="twitter:title" content="Java面向对象  接口和抽象类"/>
<meta name="twitter:description" content="问题：如何禁止默认实现 强制要求覆盖方法
 抛出异常  在空的方法里面设置UnsupportedOperationException（）；
   缺点：编译的时候不会报错，运行的时候抛出异常     原因：abstruct是一个抽象集合，有时候这个集合不可变，不可以往里面添加（不支持修改，不可变）   抽象化 抽象方法必须在抽象类中 抽象方法不能够实例化  强制提供默
 抽象类  可以有成员，可以有构造器，可以有实例方法
 实现 抽象  Abstruct 有时候是不可变，不可以添加东西
 接口  抽象类 除了用abstruct声明之外，和其他类没有本质上的区别
 不可实例化
没有方法体的方法 可以拥有抽象的方法 abstruct void methon（）； 可以是实例化的东西一定要补全所有的方法体
因为抽象方法没有执行的内容，执行也没有内容可执行，所以必须要补全方法体 可以包含抽象方法 非private/static   抽象方法目的是让人继承     继承多态只发生在实例里面，因此不能用static，没有意义     private不能被子类访问继承，继承也没有用   可以包含普通类的任何东西
内部类、成员变量……  AbstructCollection 集合 AbstructList 列表（有序）"/>







    <meta property="article:published_time" content="2020-09-22 18:02:40 &#43;0800 CST" />








    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://procarihana.github.io/public/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">知っているでしょう。</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://procarihana.github.io/public/posts">CNotes</a></li><li><a href="https://procarihana.github.io/public/tags">Tags</a></li><li><a href="https://procarihana.github.io/public/notes">PNotes</a></li><li><a href="https://procarihana.github.io/public/projects">Projects</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        8 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="https://procarihana.github.io/public/posts/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/">Java面向对象  接口和抽象类</a>
      </h1>

      

      <div class="post-content">
        <h2 id="问题如何禁止默认实现">问题：如何禁止默认实现</h2>
<p>强制要求覆盖方法</p>
<ul>
<li>抛出异常</li>
</ul>
<p>在空的方法里面设置UnsupportedOperationException（）；</p>
<ul>
<li>
<ul>
<li>缺点：编译的时候不会报错，运行的时候抛出异常</li>
</ul>
</li>
<li>
<ul>
<li>原因：abstruct是一个抽象集合，有时候这个集合不可变，不可以往里面添加（不支持修改，不可变）</li>
</ul>
</li>
<li>抽象化
抽象方法必须在抽象类中
抽象方法不能够实例化</li>
</ul>
<p>强制提供默</p>
<ul>
<li>抽象类</li>
</ul>
<p>可以有成员，可以有构造器，可以有实例方法</p>
<ol>
<li>实现</li>
<li>抽象</li>
</ol>
<p>Abstruct 有时候是不可变，不可以添加东西</p>
<ul>
<li>接口</li>
</ul>
<h2 id="抽象类">抽象类</h2>
<p><strong>除了用abstruct声明之外，和其他类没有本质上的区别</strong></p>
<ul>
<li>不可实例化<br>
没有方法体的方法</li>
<li>可以拥有抽象的方法 abstruct void methon（）；</li>
<li>可以是实例化的东西一定要补全所有的方法体<br>
因为抽象方法没有执行的内容，执行也没有内容可执行，所以必须要补全方法体</li>
<li>可以包含抽象方法   <strong>非private/static</strong></li>
<li>
<ul>
<li>抽象方法目的是让人继承</li>
</ul>
</li>
<li>
<ul>
<li>继承多态只发生在实例里面，因此不能用static，没有意义</li>
</ul>
</li>
<li>
<ul>
<li>private不能被子类访问继承，继承也没有用</li>
</ul>
</li>
<li>可以包含普通类的任何东西<br>
内部类、成员变量……</li>
</ul>
<p>AbstructCollection  集合
AbstructList 列表（有序）</p>
<p>addAll就是逐个调用add（）</p>
<hr>
<h2 id="接口-interface">接口 Interface</h2>
<ul>
<li>接口部分的实现了多继承</li>
<li>接口不是类</li>
<li>接口只代表一种功能</li>
<li>经典的接口定义：只描述接口有什么功能，但是不给出具体的实现<br>
（但可以包含方法实现）</li>
<li>接口中的（成员变量）默认都是public（访问限定符）</li>
<li>
<ul>
<li>static 用于多态（实例方法）所以不能使用</li>
</ul>
</li>
<li>
<ul>
<li>final不可改变，不能用于继承，所以也不可使用</li>
</ul>
</li>
<li>接口能有成员变量，但是有限制（默认为public static final），作为常量命名就需要全部大写</li>
<li>instanceof 不仅可以检测是否是一个类，还能够检测是否是一个接口</li>
</ul>
<h4 id="接口的扩展">接口的扩展</h4>
<ul>
<li>接口可以通过集成扩展接口<br>
继承另外一个接口，继承后能够拥有原先接口的所有方法，也要实现它所有的方法</li>
<li>一个类只能继承一个类，但是却能实现若干的接口</li>
</ul>
<hr>
<h2 id="接口可以包含">接口可以包含？</h2>
<ul>
<li>
<p>若干个方法（默认public）</p>
</li>
<li>
<p>若干个常量（默认public static final）</p>
</li>
<li>
<ul>
<li>在接口里面的变量默认都是public static final 的，它们是公共的,静态的,最终的常量.相当于全局常量，可以直接省略修饰符。
实现类可以直接访问接口中的变量</li>
</ul>
</li>
<li>
<p>extends 接口</p>
</li>
<li>
<p>默认方法</p>
</li>
<li>
<ul>
<li>Since Java 8</li>
</ul>
</li>
<li>
<ul>
<li>是一种妥协的产物（默认方法）[不破坏向后兼容]</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>通过添加 default void sort 而默认的有方法体的方法，即使使用接口没有实现这个默认方法，也可以正常运行，还能够获得这个实现</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>一个接口发布出去，就不能增添或减少方法、成员</li>
</ul>
</li>
<li>
<ul>
<li>因为所有的类都必须实现接口的所有方法，会导致之前实现的类都报错，打破向后兼容性
<strong>但是会出现二异性</strong></li>
</ul>
</li>
<li>
<ul>
<li>实现方法放在class 里面，就能够避免多个实现（多继承）带来的矛盾（避免二义性），从而提高面向对象的灵活性</li>
</ul>
</li>
<li>
<ul>
<li>如果不想实现所有的方法的话，可以声明为抽象类，可以继承接口，但是没有实现，把实现留给继承类</li>
</ul>
</li>
<li>
<p>可以用来实现mixin</p>
</li>
<li>
<p>菱形继承</p>
</li>
</ul>
<hr>
<h4 id="抽象类接口如何选择">抽象类？接口？如何选择</h4>
<ul>
<li>
<p>需要赋用代码的时候，用抽象类</p>
</li>
<li>
<p>只描述一种功能的时候用接口，接口不能包含方法实现，- 接口的抽象化更高</p>
</li>
<li>
<p>抽象类和接口都是继承<br>
多态只发生在实例方法间，final和static是不能用的</p>
</li>
</ul>
<p>共同点：</p>
<ol>
<li>抽象，不可实例化</li>
<li>可包含抽象方法（没有方法体，非static/public/final）</li>
</ol>
<p>异</p>
<ol>
<li>
<p>抽象类是类，可以包含类的一切东西；<br>
接口只能包含受限的成员和方法（public static final[常量]）没有方法体的抽象方法/dafule</p>
</li>
<li>
<p>抽象类只可以单一继承；一个类只能继承一个抽象类或者一个普通的类<br>
接口可以多继承，甚至继承多次（强制类型转化）<br>
最大成都的灵活性，最大程度的复用（大家都能够使用）</p>
<pre><code>     public class World {
     // 现在有若干种对象，请尝试使用接口和抽象类将它们建造成类型体系
     // 以最大限度的复用、简化代码
     public static List&lt;Object&gt; objects =
         Arrays.asList(new 麻雀(), new 喜鹊(), new 蝴蝶(), new 飞机(), new 救护车(), new 猫(), new 狗());
       //在建造成类型体系后，请尝试化简这个啰嗦的方法，体会多态带来的好处
      public static void 会飞的东西飞() {
     /**
     for (Object obj : objects) {
         if (obj instanceof 麻雀) {
             ((麻雀) obj).飞();
         } else if (obj instanceof 喜鹊) {
             ((喜鹊) obj).飞();
         } else if (obj instanceof 蝴蝶) {
          ((蝴蝶) obj).飞();
         } else if (obj instanceof 飞机) {
          ((飞机) obj).飞();
         }
         */
         if (obj instanceof 会飞的东西) {
             ((会飞的东西) obj).飞();
             }
         }
     }
 // 在建造成类型体系后，请尝试化简这个啰嗦的方法，体会多态带来的好处
</code></pre>
<p>public static void 会叫的东西叫() {
/*
for (Object obj : objects) {
if (obj instanceof 麻雀) {
((麻雀) obj).叫();
} else if (obj instanceof 喜鹊) {
((喜鹊) obj).叫();
} else if (obj instanceof 救护车) {
((救护车) obj).叫();
} else if (obj instanceof 猫) {
((猫) obj).叫();
} else if (obj instanceof 狗) {
((狗) obj).叫();
}
*/
if (obj instanceof 会叫的东西) {
((会叫的东西) obj).叫();
}
}
}
// 在建造成类型体系后，请尝试化简这个啰嗦的方法，体会多态带来的好处
public static void 动物都能新陈代谢() {
for (Object obj : objects) {
/*
if (obj instanceof 麻雀) {
((麻雀) obj).新陈代谢();
} else if (obj instanceof 喜鹊) {
((喜鹊) obj).新陈代谢();
} else if (obj instanceof 蝴蝶) {
((蝴蝶) obj).新陈代谢();
} else if (obj instanceof 猫) {
((猫) obj).新陈代谢();
} else if (obj instanceof 狗) {
((狗) obj).新陈代谢();
}
/*
if (obj instanceof 动物) {
((动物) obj).新陈代谢();
}
}</p>
<p>/*static class 麻雀 {
public void 新陈代谢() {
System.out.println(&ldquo;新陈代谢&rdquo;);
}</p>
<pre><code> public void 飞() {
     System.out.println(&quot;鸟儿飞&quot;);
 }

 public void 叫() {
     System.out.println(&quot;叽叽喳喳&quot;);
 }
</code></pre>
<p>}
*/
static class 鸟 extends 动物 implements 会飞的东西 , 会叫的东西 {
public void 飞() {
System.out.println(&ldquo;鸟儿飞&rdquo;);
}
static class 动物{
public void 新陈代谢() {
System.out.println(&ldquo;新陈代谢&rdquo;);
}
}
static class 麻雀 extends 鸟 {</p>
<pre><code> }
  interface 动物 {
     void 新陈代谢();
 }

 interface 会飞的东西 {
     void 飞();
 }

 interface 会叫的东西 {
     void 叫();
     }
 }
</code></pre>
</li>
</ol>
<hr>
<h5 id="mixin">Mixin</h5>
<pre><code>public class Main {
static class Animal {
    String Name;

    public Animal(String name) {
        this.Name = name;
    }
    public String getName() {
        return Name;
    }
}

interface 会跑 {
    String getName();
    default void 跑(){
        System.out.println(getName() + &quot;跑啊跑啊跑&quot;);
    }
}
interface 会游泳 {
    String getName();
    default void 游泳() {
        System.out.println(getName() + &quot;游啊游啊游&quot;);
    }
}

static class 猫 extends Animal implements 会跑 {
    猫() {
        super(&quot;小花猫&quot;);
    }
}

static class 鱼 extends Animal implements 会游泳 {
    鱼() {
        super(&quot;鱼&quot;);
    }
}

// 现在 乌龟 想要同时复用会跑和会游泳的代码
// 请尝试通过接口的默认方法实现mixin
// 从而实现最大程度的代码复用
//
 static class 乌龟 extends Animal implements 会跑,会游泳 {
    乌龟() {
        super(&quot;乌龟&quot;);
    }
}

public static void main(String[] args) {
    new 乌龟().跑();
    new 乌龟().游泳();
    }
}
</code></pre>
<h2 id="接口实战">接口实战</h2>
<h5 id="comparable接口">Comparable接口</h5>
<p>comarable 自然顺序（从小到大）<br>
a &lt; b -&gt;负数
a &gt; b -&gt;正数
a = b -&gt;0
对制定的列表按照升序排序</p>
<pre><code>public class Point implements Comparable&lt;Point&gt; {

private final int x;
private final int y;
// 代表笛卡尔坐标系中的一个点
public Point(int x, int y) {
    this.x = x;
    this.y = y;
}

public int getX() {
    return x;
}

public int getY() {
    return y;
}

@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }

    Point point = (Point) o;

    if (x != point.x) {
        return false;
    }
    return y == point.y;
}

@Override
public int hashCode() {
    int result = x;
    result = 31 * result + y;
    return result;
}

@Override
public String toString() {
    return String.format(&quot;(%d,%d)&quot;, x, y);
}

// 按照先x再y，从小到大的顺序排序
// 例如排序后的结果应该是 (-1, 1) (1, -1) (2, -1) (2, 0) (2, 1)
public static List&lt;Point&gt; sort(List&lt;Point&gt; points) {
    Collections.sort(points);//要实现，就需要用到Comparable这个接口进行排序
    return points;//传进一个有序的列表，排序，返回。

}

public static void main(String[] args) throws IOException {
    List&lt;Point&gt; points =
            Arrays.asList(
                    new Point(2, 0),
                    new Point(-1, 1),
                    new Point(1, -1),
                    new Point(2, 1),
                    new Point(2, -1));
    System.out.println(Point.sort(points));
}
//按照X排序，从小到大
@Override
public int compareTo(Point that) {
    //比较this 和 that
    //return this.x - that.x; 可能会发生溢出，所以错误。
    if (this.x&lt;that.x){
        return -1;//只要是负数就可以
    }else if (this.x&gt;that.x){
        return 1;
    }
    //return 0;说明this.x= that.x。需要按照y
    if (this.y&lt;that.y){
        return -1;//只要是负数就可以
    }else if (this.y&gt;that.y){
        return 1;
    }return 0;
}
}
</code></pre>
<h5 id="自定义过滤器-提取代码的共性通过继承来简化代码多态">自定义过滤器 (提取代码的共性，通过继承来简化代码【多态】)</h5>
<ul>
<li>先建一个结果集</li>
</ul>
<h4 id="treeset">TreeSet</h4>
<ul>
<li>
<p>两个本来不相等的元素，返回零后，treeset 就会 丢失</p>
</li>
<li>
<p>不能容纳重复元素的集合</p>
<p>public class User {
/** 用户ID，数据库主键，全局唯一 */
private final Integer id;</p>
<p>/** 用户名 */
private final String name;</p>
<p>public User(Integer id, String name) {
this.id = id;
this.name = name;
}</p>
<p>public Integer getId() {
return id;
}</p>
<p>public String getName() {
return name;
}</p>
<p>public static List<!-- raw HTML omitted --> filter(List<!-- raw HTML omitted --> users,Predicate<!-- raw HTML omitted --> predicate){
List<!-- raw HTML omitted --> results = new ArrayList&lt;&gt;();
for (User user : users){
if (predicate.test(user)){
results.add(user);
}
}
return results;
}
//抽象的过滤器函数</p>
<p>//    public static List<!-- raw HTML omitted --> filter(List<!-- raw HTML omitted -->     users,Judge condition){
//        List<!-- raw HTML omitted --> results = new ArrayList&lt;&gt;();
//        for (User user : users){
//            if (condition.MeetTheConditions(user)){
//                results.add(user);
//            }
//        }
//        return results;
//    }</p>
<p>//    private interface Judge{//一个类里面没有方法体，就是一个接口
//        boolean MeetTheConditions(User user);
//
//    }
//    private static class IdIsEvenNumber implements Judge{
//
//        @Override
//        public boolean MeetTheConditions(User user) {
//            return user.id % 2 == 0;
//        }
//    }</p>
<p>// 过滤ID为偶数的用户
public static List<!-- raw HTML omitted --> filterUsersWithEvenId(List<!-- raw HTML omitted --> users) {
return filter(users, (Predicate<!-- raw HTML omitted -->) user -&gt; user.id % 2 == 0);//匿名内部类
//        List<!-- raw HTML omitted --> results = new ArrayList&lt;&gt;();
//        for (User user : users) {
//            if (user.id % 2 == 0) {
//                results.add(user);
//            }
//        }
//        return results;
}</p>
<p>// 过滤姓张的用户
public static List<!-- raw HTML omitted --> filterZhangUsers(List<!-- raw HTML omitted --> users) {
return filter(users, new Predicate<!-- raw HTML omitted -->() {
@Override
public boolean test(User user) {
return user.name.startsWith(&ldquo;张&rdquo;);
}
});
//        List<!-- raw HTML omitted --> results = new ArrayList&lt;&gt;();
//        for (User user : users) {
//            if (user.name.startsWith(&ldquo;张&rdquo;)) {
//                results.add(user);
//            }
//        }
//        return results;
}</p>
<p>// 过滤姓王的用户
public static List<!-- raw HTML omitted --> filterWangUsers(List<!-- raw HTML omitted --> users) {
return filter(users, new Predicate<!-- raw HTML omitted -->() {
@Override
public boolean test(User user) {
return user.name.startsWith(&ldquo;王&rdquo;);
}
});
}
//        List<!-- raw HTML omitted --> results = new ArrayList&lt;&gt;();
//        for (User user : users) {
//            if (user.name.startsWith(&ldquo;王&rdquo;)) {
//                results.add(user);
//            }
//        }
//        return results;</p>
<p>// 请尝试通过Predicate接口将上述代码抽取成一个公用的过滤器函数
// 并简化上面三个函数
//判断是否满足一个条件使用Predicate
//    public static List<!-- raw HTML omitted --> filter(List<!-- raw HTML omitted --> users, Predicate<!-- raw HTML omitted --> predicate) {
//
//    }</p>
</li>
</ul>
<h5 id="name相同id-不同">name相同，id 不同</h5>
<pre><code>public class User implements Comparable&lt;User&gt; {
/** 用户ID，数据库主键，全局唯一 */
private final Integer id;

/** 用户名 */
private final String name;

public User(Integer id, String name) {
    this.id = id;
    this.name = name;
}

public Integer getId() {
    return id;
}

public String getName() {
    return name;
}

@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }

    User person = (User) o;

    return Objects.equals(id, person.id);
}

@Override
public int hashCode() {
    return id != null ? id.hashCode() : 0;
}

/** 老板说让我按照用户名排序 */
@Override
public int compareTo(User o) {
    if (this.name != o.name){
    return name.compareTo(o.name);
}
    if (this.id &gt; o.id){
        return 1;
    } else if(this.id&lt;o.id){
        return -1;
    } return 0;
    }

public static void main(String[] args) {
    List&lt;User&gt; users =
            Arrays.asList(
                    new User(100, &quot;b&quot;),
                    new User(10, &quot;z&quot;),
                    new User(1, &quot;a&quot;),
                    new User(2000, &quot;a&quot;));
    TreeSet&lt;User&gt; treeSet = new TreeSet&lt;&gt;(users);
    // 为什么这里的输出是3？试着修复其中的bug
    System.out.println(treeSet.size());
    }
}
</code></pre>
<h2 id="内部类">内部类</h2>
<ul>
<li>用途：实现更加精细的封装</li>
<li>可以访问外围类（包裹内部类的类）的实例方法</li>
<li>非静态内部类</li>
<li>
<ul>
<li>和一个外围类实例向绑定</li>
</ul>
</li>
<li>
<ul>
<li>可以访问外围类实例的方法</li>
</ul>
</li>
<li>静态内部类</li>
<li>
<ul>
<li>不和外围类实例相绑定</li>
</ul>
</li>
<li>
<ul>
<li>不可以访问外围实例的方法<br>
<strong>原则：永远使用静态内部类，除非编译报错</strong><br>
<em>原因：非静态的时候，编译器会注入一个外围类的实例（没用的时候，会占据内存）</em></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>非静态内部类<br>
每一个内部类都和一个外围类（A）的变量实例相绑定，使得内部类可以毫无障碍地使用外围类的实例方法<br>
private class A{<br>
{log();}//内部类<br>
}</p>
</li>
<li>
<ul>
<li>因为编译器会自动添加一个外围类的实例方法，而静态内部类是需要手工添加才可以使用外围类的实例方法</li>
</ul>
</li>
<li>
<p>静态内部类
没有相绑定的外围实例，所以不能够调用外围类的实例方法<br>
private static class B{<br>
public B (A a){<br>
this.a = a;<br>
}<br>
A a;<br>
//创建外围类的实例方法 <br>
{a.log()}
}</p>
</li>
<li>
<p>Java类的文件只能包含一个和他同名的public成员</p>
<p>在内部类中建立一个外围类的实例，建立构造器，使得内部类可以使用</p>
</li>
</ul>
<h5 id="非静态内部类访问外围类">非静态内部类访问外围类</h5>
<p>编译器注入外围类
public class Home {
List<!-- raw HTML omitted --> cats = new ArrayList&lt;&gt;();</p>
<pre><code>public List&lt;String&gt; getCatNames() {
    CatNameCollector collector = new CatNameCollector();
    cats.forEach(collector);
    return collector.getCatNames();
}

// 记录日志
private void log(Cat cat) {
    System.out.println(&quot;Collecting cat &quot; + cat.getName());
}

// 在这个类里会产生一个编译错误
// 请思考一下为什么
// 并将此类改写成非静态的内部类，以修复此问题
class CatNameCollector implements Consumer&lt;Cat&gt; {
    private List&lt;String&gt; catNames = new ArrayList&lt;&gt;();

    @Override
    public void accept(Cat cat) {
        log(cat);//log是一个实例，，编译器要访问外围实例的时候，需要和外围类实例想绑定，所以不能够使用static
        catNames.add(cat.getName());
    }

    private List&lt;String&gt; getCatNames() {
        return catNames;
    }
}
}
</code></pre>
<h5 id="静态内部类访问外围类">静态内部类访问外围类</h5>
<p>手工制作访问外围类的实例</p>
<pre><code>public class Home2 {
List&lt;Cat&gt; cats = new ArrayList&lt;&gt;();

public List&lt;String&gt; getCatNames() {
    CatNameCollector collector = new CatNameCollector(this);
    cats.forEach(collector);
    return collector.getCatNames();
}

// 记录日志
private void log(Cat cat) {
    System.out.println(&quot;Collecting cat &quot; + cat.getName());
}

static class CatNameCollector implements Consumer&lt;Cat&gt; {
    private Home2 home;

    public CatNameCollector(Home2 home) {
        this.home = home;
    }

    // 在这个类里会产生一个编译错误
    // 请思考一下为什么
    // 不要将此类改写成非静态的内部类
    // 而是引入一个外围类的实例以调用外围类的实例方法
    // private Home2 home;
    private List&lt;String&gt; catNames = new ArrayList&lt;&gt;();

    @Override
    public void accept(Cat cat) {
        home.log(cat);
        catNames.add(cat.getName());
    }

    private List&lt;String&gt; getCatNames() {
        return catNames;
    }
}
</code></pre>
<p>}</p>
<h2 id="匿名内部类">匿名内部类</h2>
<ul>
<li>
<p>直接通过new的方法创建的无名类</p>
</li>
<li>
<p>可以方便通过简短的代码让逻辑和外围逻辑结合起来</p>
</li>
<li>
<p>可以访问外围类的实例</p>
<p>public class User {
/** 用户ID，数据库主键，全局唯一 */
private final Integer id;</p>
<p>/** 用户名 */
private final String name;</p>
<p>public User(Integer id, String name) {
this.id = id;
this.name = name;
}</p>
<p>public Integer getId() {
return id;
}</p>
<p>public String getName() {
return name;
}</p>
<p>// 这里使用了一个NameCollector类，请尝试将它改写成匿名内部类
// 使得代码更加集中，更加容易阅读
public static List<!-- raw HTML omitted --> collectNames(List<!-- raw HTML omitted --> users) {
final List<!-- raw HTML omitted --> names = new ArrayList&lt;&gt;();
NameCollector collector = new NameCollector() {
@Override
public void accept(User user) {
names.add(user.getName());
}</p>
<pre><code>      public List&lt;String&gt; getNames() {
          return names;
      }
  };
  users.forEach(collector);
  return collector.getNames();
</code></pre>
<p>}</p>
<p>public static void main(String[] args) {
List<!-- raw HTML omitted --> users = Arrays.asList(new User(1, &ldquo;a&rdquo;), new User(2, &ldquo;b&rdquo;));
System.out.println(collectNames(users));
}
}</p>
</li>
</ul>

      </div>
    </article>

    <hr />

    <div class="post-info">
        <p>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon">
            <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
            <line x1="7" y1="7" x2="7" y2="7"></line>
          </svg><span class="tag"><a href="https://procarihana.github.io/public/tags//"></a></span><span class="tag"><a href="https://procarihana.github.io/public/tags//"></a></span>
        </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        1509 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        2020-09-22 18:02 &#43;0800
      </p>
    </div>

    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>

        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="https://procarihana.github.io/public/posts/java-8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">
                <span class="button__icon">←</span>
                <span class="button__text">Java 8 函数式编程</span>
              </a>
            </span>
          

          
            <span class="button next">
              <a href="https://procarihana.github.io/public/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
                <span class="button__text">多线程</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    


    

  </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2021</span>
            
                <span><a href="https://procarihana.github.io/public/">Hana</a></span>
            
            
                <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span>
            
            <span> <a href="https://procarihana.github.io/public/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">Djordje Atlialp</a></span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="https://procarihana.github.io/public/bundle.min.dc716e9092c9820b77f96da294d0120aeeb189b5bcea9752309ebea27fd53bbe6b13cffb2aca8ecf32525647ceb7001f76091de4199ac5a3caa432c070247f5b.js" integrity="sha512-3HFukJLJggt3&#43;W2ilNASCu6xibW86pdSMJ6&#43;on/VO75rE8/7KsqOzzJSVkfOtwAfdgkd5BmaxaPKpDLAcCR/Ww=="></script>



    </body>
</html>
