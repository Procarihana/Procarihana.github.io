<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Redis on FAFA Blog</title>
    <link>https://procarihana.github.io/public/tags/redis/</link>
    <description>Recent content in Redis on FAFA Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Fri, 04 Sep 2020 16:40:35 +0800</lastBuildDate>
    
	<atom:link href="https://procarihana.github.io/public/tags/redis/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>AOP和装饰器模式以及Redis</title>
      <link>https://procarihana.github.io/public/posts/aop%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8Aredis/</link>
      <pubDate>Fri, 04 Sep 2020 16:40:35 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/aop%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8Aredis/</guid>
      <description>AOP  Aspect-Oriented Programming 面向切面编程 相当于OOP（面向对象编程） AOP是面向切面变成，关注一个统一的切面   切面并不是对象和方法，而是执行方法的和方法之间的一瞬间、一个面   AOP和Spring是不同的东西   没有Spring容器AOP也是能够工作的     Spring 通过AOP来完成一些请求    AOP 适用的场景  需要统一处理的场景   日志     缓存     鉴权    AOP的实现  JDK动态代理（Proxy）   优点：⽅便，不需要依赖任何第三⽅库     缺点：功能受限，只适⽤于接⼝     OOP完成这些需求的话，需要使用到装饰器模型   CGLIB/ByteBuddy字节码⽣成   优点：强⼤，不受接⼝的限制     缺点：需要引⽤额外的第三⽅类库     不能增强final类/final/private⽅法    AOP与Spring  在Spring中使⽤AOP实现Redis缓存 Spring是如何切换JDK动态代理和CGLIB的？   spring.</description>
    </item>
    
    <item>
      <title>Docker的原理和应用</title>
      <link>https://procarihana.github.io/public/posts/docker%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/</link>
      <pubDate>Tue, 01 Sep 2020 18:41:11 +0800</pubDate>
      
      <guid>https://procarihana.github.io/public/posts/docker%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/</guid>
      <description>虚拟机有一套完整独立的操作系统，非常占内存和资源,虚拟机内即使有空闲的资源也不能够集中利用，只能够浪费 docker 启动的容器用于运行程序，剩余的内存能够继续用于新的容器，从而节省内存 阿里云的镜像加速所向无敌  Docker  保证开发、测试、交付、部署的环境完全一致 保证资源的隔离   通过fastjson 任意代码执行漏洞，通过java进程获得来操控别的进程从而过得Linux的控制权限。而Docker 资源隔离只能够获得Docker内的权限，对宿主机没有任何影响   启动临时的、用完即弃的环境，例如测试 迅速（秒级）超大规模部署和扩容   可以迅速扩容大量的容器，且环境是一模一样的    Docker 的基本概念  镜像 image   一个预定好的模板文件，Docker 引擎可以按照这个模板文件启动无数个一模一样，互不干扰的容器     像是一份清单一样，每次启动这个镜像就按照这份清单来启动   容器 container   一台虚拟的计算机，拥有独立的：      网络 文件系统 进程      默认和宿主机不发生任何交互      意味着数据是没有持久化的   Docker 指令 docker run : 启动一个全新的控制资源隔离的docker容器  一台独立的计算机 每个容器都有一个ID，支持缩写 docker run -it &amp;lt;镜像名&amp;gt;&amp;lt;镜像中要运行的命令和参数&amp;gt;   交互式命令行模式，当前shell中运行。Ctrl-c退出（启动一个容器，并立刻进入内部进行操作）   docker run -d   daemon模式，在后台运行   &amp;ndash; name 为容器指定一个名字 &amp;ndash; restart=always 遇到错误马上重启 -&amp;gt; 用于NGINX等    docker run &amp;ndash;name springboot-nginx &amp;ndash;restart=always -v pwd/nginx/nginx.</description>
    </item>
    
  </channel>
</rss>