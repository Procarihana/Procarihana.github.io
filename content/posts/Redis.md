---
title: "Redis"
date: 2020-10-10T13:32:57+08:00
draft: false
toc: false
images:
tags: ["",""]
---
## 
- 分布式要防止单点故障
## 缓存基础
- cache 位于速度相差较大的两种较大的两种硬件之间，用于协调两者数据输速度差异的结构
- 缓存是一个高速数据存储层，其中存储了数据子集，且通常是短暂性存储，这样日后再次请求该数据是，速度要比访问数据的主存储位置快。通过缓存，可以高效地重用之前检索或计算的数据
- 本质就是空间换时间，性能成本Tradeoff 减少对底层速度较慢的存储层的访问需求以此来提高数据检索性能，在容量换取速度方面，缓存通常是完整且持久地存储数据
- 缓存必要性
1. 提升访问性能
2. 降低网络拥堵
3. 消除数据库热点
- 某个资源被大量访问，就需要对这个热点数据和相应的数据进行配置，通过预测性能来提前放在缓存里面
4. 可预测的性能
5. 减少后端负载
6. 增加系统可扩展性
## 缓存特征指标
- 命中率
- - 命中率 = 返回正确结果数、请求缓存次数
- - 缓存率越高，缓存使用效率越高
- 最大空间
- - 缓存中可以存放的最大元素数量
- 缓存生存时间 TTL
- - 缓存可以存活的时间，超过时间就失效
- 缓存清空策略
- - 缓存可使用的存储空间有限，占满后就需要清除一些缓存，清空策略就决定了要清空哪些缓存
>- FIFO : 先进先出 ，最先进入缓存的数据会被优先清除掉，比缓存元素的创建时间，优先保障最新数据可用
>- LFU (less frequently used): 最少使用，根据元素的使用次数判断，使用次数较少的数据将被删除
>- LRU(less recently used）: 最近最少使用，假设最近最少使用的这些信息，将来被使用的概率也不大，根据数据最后一次被使用的时间戳来决定，把最老的诗句删掉
>- 定时过期：每个设置过时间的key都需要创建一个定时器，到过期时间就会立即清除
>- 惰性过期：只有当访问一个key时，才会判断该key是否已经过期，过期则清除
>- 最长过期： 根据过期时间，清理最长时间没用的
>- 随机过期清理：根据过期时间，任意清理一个
>- 随机清理：无论是否过期，随机清理

## 缓存常见问题详解
1. 缓存内数据同时失效
- 导致所有的请求都被传到数据库里，使得数据库请求突然增加
- - 解决：让缓存添加一个随机事件，使得同一批的请求不会同一时间失效
2. 缓存穿透
- 用户使用非法请求，请求的数据不是数据库和缓存里面存在的，使得请求每次都传到数据库，造成数据库瘫痪
- 如果是合理的范围里面，但是数据库仍是不存在的，也会导致请求直接发送到数据库里面。
- - 解决：
>- 要在最外层进行基本的数据校验，遇到非法请求直接
>- BlomFilter 过滤器 --> 存储所有的数据id，直接通过判断请求的数据id是否存在来判断请求数据是否合法
>- - 分配一个内存空间全部存0，加入元素，用k个互相独立的哈希函数计算，然后将元素哈希映射的K个位置全部设置为1，检测key，仍然按
>- - 但是只是大概率，还是有误差的 
3. 缓存雪崩
- 存在缓存数据里面的节点崩坏，节点内的数据全部都会失效，倒是请求都直接发送到数据库里面
- - 数据支持  
5. 数据源统一
- 不要自己单独另外进行缓存，会导致和原本的数据源出现不同
4. ReadAfterWrite 
- 写完后立即能够读，就会造成 DB和Catch里面不一样。需要对数据库和缓存一致性问题先解决。
- - 缓存尽快失效，能够尽可能保证数据一致
5. 缓存和
## 缓存和数据库的更新
- 先删除缓存后更新DB？
- - 并发的时候就会出现问题。当线程A需要更新数据一时，把cache 删除 。然后线程B发现数据一没有了，就从数据库里面读取数据一，这时数据库是新的数据，cache 会继续沿用线程B缓存进cache 的旧数据。
- 先更新后缓存？
- - 当线程A 更新数据库后再删除cache时，还没有来得及删除，线程B就过来向数据库写入新的数据，此时缓存里是线程A的更新的数据，而数据库里面的是线程B更新的数据。在线程B还没有把新的数据写入缓存时间里，就会出现缓存和数据库不一致的情况。
- - 但是这种情况很少，因为更新数据库的速度比更新缓存的速度要慢。

## Spring缓存抽象与相关源码分析
- CachingProvider 可以控制多个CacheManager(Guava等等的cache实现)，从而实现分级的缓存

- Spring 提供的cache 是抽象的，需要自己手工实现， 

## 注解
- `@Cacheable` 对应Cache-set， 
---
# Note

## Redis
- No Sql Not Only Sql,非关系型数据库
- NoSql 是解决高并发 高可用 高可扩展 大数据库存储问题而产生的数据库解决方案
- 可以作为关系型数据库的补充，但不能够替代
- Key Value 储存数据库 
- - 优势： 快速查询
- - 劣势： 存储的数据缺少结构化

## Redis的应用场景
- 内存数据库(登录信息、购物车信息、用户浏览记录等)
- 缓存服务器(商品数据、广告数据等等)(最多使用)
- 解决分布式集群架构中的Session分离问题(Session共享)
- 任务队列。(秒杀、抢购、12306等等)
- 支持发布订阅的消息模式
- 应用排行榜
- 网站访问统计
- 数据过期处理(可以精确到毫秒)

# Redis 分布式锁
- - redisson 
- 互斥性
- 锁超时
- 支持阻塞和非阻塞
- 可重入性
- 高可用

## 后台日志记录
- 在sentinel的配置文件中添加以下内容：

```
[root@redis_01 redis]# vim sentinel.conf 
daemonize yes
logfile "/var/log/sentinel_log.log"
```
- 启动，查看日志：

```
[root@redis_01 redis]# redis-server /etc/redis/sentinel.conf --sentinel
[root@redis_01 redis]# cat /var/log/sentinel_log.log 
```




- Apache JMeter
- 支持单元测试和并发测试
- PostMan 也能够支持测试
---
- 加载JVM里面的锁是无法解决集群问题的
- Redis 实现分布式锁
- - 通过SETNX key value 实现分布式锁
>- 只在键key 不存在的情况下讲key设置成value（成功）
>- 若Key 已经存在 则命令没有任何动作
>- 命令在设置成功时返回1，设置失败时返回0
---
- 通过返回 0 1 （true/fasle）来判断否有执行成功 来获得锁，从而为程序加锁
- 锁需要及时释放来避免异常，通常放在finally 里面避免死锁
- 宕机的情况JVM 也是没有办法保证的，而redis 有 expire()方法能够设置过期时间，从而避免 ，这个时间的设置一定要大于业务执行完成的时间，但是业务执行时间是不固定的，所以需要通过周期性地设置
>- 通过异步加时，因为在同一个顺序里面就会影响到正常代码的执行
---
- 在线程上加锁，有可能会被别的线程解锁，所以要解决锁只能被当前线程加减锁。
- 通过（String的 intUUID对象）唯一数来完成唯一一个锁的标识。但是单纯地这样使用会被其他线程覆盖String，通过map 的key 对应value 这样能够解决
---
可重入锁
- synchronized 锁里面不能够有锁
- 而可重入锁 是锁里面可以有多个锁
- - 实现可重入锁，可以通过每次获得锁就加一，里面的锁释放就-1，知道这个数值为0 是最外面的锁才完成释放
---
自旋锁 
- 当获得锁失败的时候，不直接返回，而是继续竞争锁
---

