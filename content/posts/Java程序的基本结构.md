---
title: "Java程序的基本结构"
date: 2020-04-28T16:58:28+08:00
draft: false
---
# Java程序的基本结构
### Java 简述
1. 强类型：在内存的每一个数据都需要和一个类型相绑定
- 即使数据相同，但是类型不一样，解释的方式也不一样
2. 静态
- Java code --> 字节码 （编译）
3. 跨平台性能
---
### 操作系统
1. Linux、windows、mac……
2. 不同的操作系统有不同的语言 （API 【Application Programming Interface】 应用编程接口）-->实现跨平台就要通过JVM实现

- JVM 【Java Vitual Mach】（Java虚拟机）
- 字节码
1. 最小单位为字节，八个字节为一个字节码

---
### Java 成句基本结构
#### 类和包的关系
1. 基本结构--类，Java 程序的最小的结构单元，按照约定放在自己同名的'.java' 文件中
2. 每个 Class 都处于一个package中
3. Package 的名字是相对于src决定的，也就是由目录结构确定的，名字通常用域名的倒叙
4. 如果class 直接放在java文件夹下面，就不会显示package 因为处于默认包里面

#### 包的意义

1. 类的名字是一个简单的字符串，通过包更容易区分
Eg：通过运用全限定类名，可以用于区分不同的同名类
- 全限定类名 ：包含包名的类-->package.class
2. 可以通过import引入包，可以让引用类的编写更加便捷

#### 第三方包的引用
1. Maven
2. 当方法属于Java.lang的时候后，不需要特地去引用

#### 方法、静态方法与静态成员变量
1. 方法
- 静态方法:就是一个函数，一个 不依附于任何对象的方法，不用去创造任何对象
2. 函数调用
- 每次函数调用的时候会产生新的独立的环境
- 函数调动可以多次调用，调用完成后，局部变量就会被销毁
3. 局部变量的作用域在第一对花括号里面  
            
           
            public static int result(int a,int b)
4. 成员变量 ：和一个对象绑定的变量
    

        public class Cat{
            private String name;
            }
5.  静态成员变量：是一个类的成员，方法调用后的结果会持续存在，独立于任何的函数调用，函数调用结束后都不会被销毁  
`public static int i`
6. `static`不和任何对象绑定

#### 对象、结构与成员变量
1. 类 说明书，说明方法如何调用，调用后会得到什么机结果
2. 对象（实例） 通过new一个构造函数，从而创造出一个对象  
`Cat cat = new Cat();`
3. 构造器
- 没有生命任何的constructor构造器，编译器会自动构造一个
- 一个特殊的实例方法

   
      Cat(){}//编译器自动生成

--- 


    public Cat(String name){
        this.name = name;
    }
- 构造器里面可以声明参数
- 可以写public
- 没有返回值（返回的是构造函数的一个实例）
- 可以声明多个构造器
4. `this` 的使用：在不构成歧义的情况下可以不使用

#### 实例方法与空指针异常

1. 实例方法 和对象相绑定的方法，只有实例才能够调用
2. 空指针异常 会在对对象取属性或者调用实例方法的时候后发生
- 解决：可以通过if else 为null 进行判断


#### sum
1. 静态变量 不和任何对象绑定，一个全局的存储单元，被所有对象所共享。在所有的对方都可以对这个变量进行读写。
2. 静态方法 不和任何实例对象相绑定
3. 成员变量，没有static 限定，和一个对象紧密绑定的
4. 实例方法 不能仅通过一个类名去引用，需要先创造出一个实例对象，这个对象才可以去调用这个方法。
- 在构造器里面可以直接调用实例方法

---  
#### 对象与引用
1. 引用 == 地址 
2. 所有的对象都是地址，一个实例被创造出来，实际上就是创造出一个地址，指向自己类的内存空间。对象被进行赋值的时候，只是地址被进行复制，而对象本身并没有改变。
3. 深拷贝deepCopy 浅拷贝
- 浅拷贝只是复制了地址，并没有复制对象的所数据
![浅拷贝](/浅拷贝.png)
- 深拷贝需要创造所有的对应的对象进行拷贝,把对象的所有值都进行赋值。地址虽然不一样，但是通过赋值可以的到一样的数据
![深拷贝](/深拷贝.png) 
---  
#### 对象与引用
1. 引用 == 地址 
2. 所有的对象都是地址，一个实例被创造出来，实际上就是创造出一个地址，指向自己类的内存空间。对象被进行赋值的时候，只是地址被进行复制，而对象本身并没有改变。
3. 深拷贝deepCopy 浅拷贝
- 浅拷贝只是复制了地址，并没有复制对象的所数据
- 深拷贝需要创造所有的对应的对象进行拷贝

#### 方法的传值 vs 传引用
1. 传值 通过引用的方法传值，只是把数据赋值一遍,修改是不会生效的。因为执行方法的时候后会创建一个全新的环境，结束后数据就会销毁。



     public static void main (String [] args){
         int i = 0;
         addOne(i);
     }
     static void int addOne(int i){
         i = i+1
     }


2. 传引用 本质为传递地址


        public static void main (String [] args){
            Cat cat = new Cat();
            cat.name = "111";
            renameCat(cat);
        }
    
        stativ void renameCat(Cat cat){ 
         //在Cat这个类的储存空间里面赋值，把结果的地址传递给main里面的cat
         cat.name = "mewo"
        }

