---
title: "JVM"
date: 2020-10-08T11:12:52+08:00
draft: true
toc: false
images:
tags: ["",""]
---

 HotSport JVM   
 ---
 堆
 - 所有对象都在里面
 - 只能操纵对象的引用或者地址
 - 只能够操纵产生，但无法控制死亡
 >- 常量池 
 >- String.intern() 直接从常量池里面获取这个对象的引用
 ---
 栈
 -  
 - 递归调用
 - 阶乘
 - - 每次方法调用都会产生一个新的栈针，返回之后就会销毁
- 栈里面的内存分配
- - 局部变量都是在栈里面的，因为每一次方法调用所用到的变量都是复制得到的，所以在调用改变的过程中是不会改变局部变量的
- - 对象的地址根据虚拟机是32位（4个字节）还是64位（8个字节）
- 栈针
- - 方法调用开始的时候，变量就会放在每个方法栈里面的操作数栈里面， 
---
方法区
- 被整个虚拟机共享的共享的class信息（创建对象的说明书）

 ---
 永久代放在堆里面，很容易就会超出内存
 元空间 和 natice 共享内存
 ---
 平台无关性
- 基于栈的模型

---
查看字节码
- javap target.xxx.classname 只能够查看public 的方法
- - `-private` 能够查看所有的方法
- - `-v` 常量的等等
---
字节码的加载和执行
- JVM只关心class file 
- 类加载器
- - 打通了代码和数据之间的障碍
- mock mokito 通过动态字节码增强的方式
- 热部署、热替换 动态地把某个jar包替换等等

---
双亲委派加载模型（并非强制的加载标准 ）
- 安全性
- - 恶意java.lang.object等等的类
- 由父类加载 loadClass
- - 先查看类是否被加载，如果被加载就直接返回
- - 如果没有找到就尝试查找parent 是否存在
- - 如果没有就用启动类加载
- - 否则就尝试自己加载
- 正确性
- - 类加载也被instanceof所检查
 - - 自定义加载的话，会出现类不是这个类的异常
 - - 因为两个类是由不同的类加载器加载的，所以会认为两个类不是同一个类
---
classloader

---
HotSport
- 通过收集运行的数据，能够获得运行频率高的类  
---
Just-In-Time  Complier
- 两种执行方式
- - 解释执行
>- 方便、跨平台
>- 慢
- - 编译执行
>- 麻烦 不灵活 编译后的代码臃肿 快
