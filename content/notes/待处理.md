---
title: "待处理"
date: 2020-09-14T20:44:10+08:00
draft: true
tags: ["",""]
---

----
Java通过synchronized进行访问的同步，synchronized作用非静态成员方法和静态成员方法上同步的目标是不同的


character流和byte流的区别
字符流和字节流每次读入的字节数是不确定的，可能相同也可能不相同；字符流和字节流都有缓冲流

完全二叉树

get是立即加载，load是延迟加载。 hibernate

重载的概念是：

方法名称相同，参数个数、次序、类型不同

因此重载对返回值没有要求，可以相同，也可以不同

但是如果参数的个数、类型、次序都相同，方法名也相同，仅返回值不同，则无法构成重载


Java的静态方法属于类的成员，实例方法属于对象的成员。
java不允许单独的方法，过程或函数存在,需要隶属于某一类中。
java语言中的方法属于对象的成员,而不是类的成员。不过，其中静态方法属于类的成员。

从java虚拟机的角度讲，只有两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用的是c++实现的，是虚拟机的一部分，另一类是就是所有其他类加载器，这些类加载器都由java语言实现，独立于虚拟机外部，并且全都继承自抽象类。
从开发人员的角度看，类加载器还可以划分为3种系统类加载器，启动类加载器（Bootstrap ClassLoader），负责加载存放在<JAVA_HOME>/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符的类库即使放在lib目录中也不会被加载）类库加载到虚拟机中内存中。启动类加载器无法被java程序直接引用，用户在编写自定义类加载器是，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。
    扩展类加载器（Extension ClassLoader）：这个类加载器有sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
    应用类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以也称它为系统类加载器（System ClassLoader）。他负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。对此，如果有必要开发者可以加入自己定义的类加载器。
    一般对于我们java程序员来说，类的加载使用的是双亲委派模型，即当一个类需要加载时，会将类传给Application ClassLoader，但是Application ClassLoader并不会加载，不管它是否能加载，而是传给它的"父类" Extension ClassLoader，Extension ClassLoader同样不会加载，同样传给 Bootstrap ClassLoader（注意不是我们常说的那种父类，但是可以这样理解）,这时Bootstrap ClassLoader会判断它是否能加载，能加载就直接加载了，不能加载就传给Extension ClassLoader，Extension ClassLoader同样的判断是否能加载，能加载就直接加载，不能加载就传给Application ClassLoader，然后Application ClassLoader也判断能否加载，如果还是不能加载应该就是报ClassNotFoundException了。这就是双亲委托模型的简单理解了。
    对于上面的"父类"为什么要打引号，因为它们并不是真的像java中继承的关系，而是组合的关系，即在"子类"中存在一个成员变量指向"父类"的引用。
    所以AE对DF错了。
    对于C，很容易理解，因为我们知道一个类只需要加载一次就够了，所以要保证线程安全。
    难点就在B了，其实也好理解，就是体现双亲委托模型的优势的时候了，之所以使用双亲委托机制是为了保证java程序的稳定运作，比如当你使用的不是双亲委托模型的时候，然后刚好开发者又定义了一个类，一个java.lang.String这样一个类，如果不使用双亲委托模型，当类加载的时候就有可能会加载开发者定义的String类，这导致了java代码的一片混乱，可读性极差。（PS：但这并不意味着类加载器只要双亲委托模型就行了，没有完美的模型，只有最合适的模型，有不同的需求使用不同的模型。比如破坏双亲委派模型，有兴趣的牛友可以自行了解），所以可以这么说，不同的类加载器加载出来的类是不一样的，不同的类加载器加载同一个类会在方法区产生两个不同的类，彼此不可见，并且在堆中生成不同的Class实例。对于接口，其实就是一个特殊的类，和类一样，在堆中产生不同的class对象。
    纯手打，个人理解，欢迎大佬指出错误。

    A.Java系统提供3种类加载器：启动类加载器（Bootstrap ClassLoader）  扩展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader）. A正确
B.《深入理解Java虚拟机》P228：对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类必定不相等。接口类是一种特殊类，因此对于同一接口不同的类装载器装载所获得的类是不相同的。B错误
C.类只需加载一次就行，因此要保证类加载过程线程安全，防止类加载多次。C正确
D. Java程序的类加载器采用双亲委派模型，实现双亲委派的代码集中在java.lang.ClassLoader的loadClass()方法中，此方法实现的大致逻辑是：先检查是否已经被加载，若没有加载则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出ClassNotFoundException异常。D错误
E.双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。E正确
F.应用程序类加载器（Application ClassLoader）负责加载用户类路径（ClassPath）上所指定的类库，不是所有的ClassLoader都加载此路径。F错误

链接：https://www.nowcoder.com/questionTerminal/b82e4a85a66e4dc488a5ab49094976e9
来源：牛客网

1、ThreadLocal的类声明：
public class ThreadLocal<T>
可以看出ThreadLocal并没有继承自Thread，也没有实现Runnable接口。所以AB都不对。
2、ThreadLocal类为每一个线程都维护了自己独有的变量拷贝。每个线程都拥有了自己独立的一个变量。
所以ThreadLocal重要作用并不在于多线程间的数据共享，而是数据的独立，C选项错。
由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，
变量被彻底封闭在每个访问的线程中。所以E对。
3、ThreadLocal中定义了一个哈希表用于为每个线程都提供一个变量的副本：
 static class ThreadLocalMap {

        static class Entry extends WeakReference<ThreadLocal> {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal k, Object v) {
                super(k);
                value = v;
            }
        }

        /**
         * The table, resized as necessary.
         * table.length MUST always be a power of two.
         */
        private Entry[] table;
}
所以D对。


作者：牛客641740495号
链接：https://www.nowcoder.com/discuss/510071?channel=&source_id=_discuss_interview
来源：牛客网

2.synchronized的实现
3.JVM内存布局（我突然忘词了，程序计数器半天没想起来）
4.mysql的mvcc（忘词，innodb半天没想起来）
5.TCP的安全性？我反问，他说tcp的可靠传输。我讲了讲停等协议，滑动窗口协议，超时重传，校验和。他说还有，我说不知道了。
6.I/O模型，零拷贝（不会）
7.分布式锁
8.写题：最大连续数组

15* 4 = 112
 1 设为x
 （x+5）*4=x^2+x+2 -->x=6

 由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。
匿名内部类也就是没有名字的内部类

正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写

但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口
```java
匿名内部类的基本实现

abstract class Person {
    public abstract void eat();
}
 
public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println("eat something");
            }
        };
        p.eat();
    }
}
```
```java
在接口上使用匿名内部类
interface Person {
    public void eat();
}
 
public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println("eat something");
            }
        };
        p.eat();
    }
}
```
```java
Thread类的匿名内部类实现
public class Demo {
    public static void main(String[] args) {
        Thread t = new Thread() {
            public void run() {
                for (int i = 1; i <= 5; i++) {
                    System.out.print(i + " ");
                }
            }
        };
        t.start();
    }
}
```
```java
Runnable接口的匿名内部类实现
public class Demo {
    public static void main(String[] args) {
        Runnable r = new Runnable() {
            public void run() {
                for (int i = 1; i <= 5; i++) {
                    System.out.print(i + " ");
                }
            }
        };
        Thread t = new Thread(r);
        t.start();
    }
}

```

1.final修饰变量，则等同于常量
2.final修饰方法中的参数，称为最终参数。
3.final修饰类，则类不能被继承
4.final修饰方法，则方法不能被重写。
5.final 不能修饰抽象类
6.final修饰的方法可以被重载 但不能被重写


wait()、notify()和notifyAll()是 Object类 中的方法
从这三个方法的文字描述可以知道以下几点信息：

1）wait()、notify()和notifyAll()方法是本地方法，并且为final方法，无法被重写。


2）调用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的monitor（即锁）

3）调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程；

4）调用notifyAll()方法能够唤醒所有正在等待这个对象的monitor的线程；

有朋友可能会有疑问：为何这三个不是Thread类声明中的方法，而是Object类中声明的方法

（当然由于Thread类继承了Object类，所以Thread也可以调用者三个方法）？其实这个问

题很简单，由于每个对象都拥有monitor（即锁），所以让当前线程等待某个对象的锁，当然

应该通过这个对象来操作了。而不是用当前线程来操作，因为当前线程可能会等待多个线程

的锁，如果通过线程来操作，就非常复杂了。

上面已经提到，如果调用某个对象的wait()方法，当前线程必须拥有这个对象的monitor（即

锁），因此调用wait()方法必须在同步块或者同步方法中进行（synchronized块或者

synchronized方法）。

调用某个对象的wait()方法，相当于让当前线程交出此对象的monitor，然后进入等待状态，

等待后续再次获得此对象的锁（Thread类中的sleep方法使当前线程暂停执行一段时间，从

而让其他线程有机会继续执行，但它并不释放对象锁）；

notify()方法能够唤醒一个正在等待该对象的monitor的线程，当有多个线程都在等待该对象

的monitor的话，则只能唤醒其中一个线程，具体唤醒哪个线程则不得而知。

同样地，调用某个对象的notify()方法，当前线程也必须拥有这个对象的monitor，因此调用

notify()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。

nofityAll()方法能够唤醒所有正在等待该对象的monitor的线程，这一点与notify()方法是不同的。
Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，在阻塞队列那一篇博文中就讲述到了，阻塞队列实际上是使用了Condition来模拟线程间协作。
Condition是个接口，基本的方法就是await()和signal()方法；
Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition()
调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用Conditon中的await()对应Object的wait()； Condition中的signal()对应Object的notify()； Condition中的signalAll()对应Object的notifyAll()


1. 只看尖括号里边的！！明确点和范围两个概念
2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List<A>,List<B>,List<Object>
3. 如果尖括号里面带有问号，那么代表一个范围，<? extends A> 代表小于等于A的范围，<? super A>代表大于等于A的范围，<?>代表全部范围
4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点
5. 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值
6. List<?>和List 是相等的，都代表最大范围
----------------------------------------------------------------------------------
7.补充：List既是点也是范围，当表示范围时，表示最大范围

下面贴代码：（本来用的Eclipse截图的，结果好像网站出来Bug，不能传图了o(╯□╰)o）

public static void main(String[] args) {
        List<A> a;
        List list;
        list = a;   //A对，因为List就是List<?>，代表最大的范围，A只是其中的一个点，肯定被包含在内
        List<B> b;
        a = b;      //B错，点之间不能相互赋值
        List<?> qm;
        List<Object> o;
        qm = o;     //C对，List<?>代表最大的范围，List<Object>只是一个点，肯定被包含在内
        List<D> d;
        List<? extends B> downB;
        downB = d;  //D对，List<? extends B>代表小于等于B的范围，List<D>是一个点，在其中
        List<?extends A> downA;
        a = downA;  //E错，范围不能赋值给点
        a = o;      //F错，List<Object>只是一个点
        downA = downB;  //G对，小于等于A的范围包含小于等于B的范围，因为B本来就比A小，B时A的子类嘛
    }
    我是在《数据结构与算法分析java版》这本书看到的。网上相关博客也有很多。我也不知道能不能用来解释这个题目。
大概的观点就是：java数组具有协变性，而java集合不是协变的；
什么意思呢？我举几个例子：
1. 假设有一个函数 fun（Animal animal），如果我们传入一个Dog d 对象进去，编译器是不会报错的，这是多态的概念；
2. 假设有一个函数 fun（Animal[] animals），如果我们传如一个Dog[] dogs数组进去，编译器也不会报错，这就是数组的协变性；
3. 假设有一个函数 fun（List<Animal>  animal）， 如果我们传如一个List <Dog>  dog 集合进去，编译器就会报错了，这就是集合泛型的不变性；
那么该怎么办呢？我们可以将泛型改成这样 fun (List <? extends Animal> )，这样之后，当我们再 传入一个List <Dog>  dog 集合进去，编译器就就不会报错了。也就是说可以传入包含Animal的子类的List了。


ava中的构造方法
构造方法的特点：
构造方法的方法名与类名相同
构造方法没有返回值类型，也不写void
构造方法可以重载

什么时候会用到构造方法：
在创建对象的时候
构造方法的作用：
创建对象的时候给属性赋初值
构造方法的分类：
显示的构造方法和隐式地构造方法
显示的构造方法：显示的写出构造方法时，系统不会提供默认的无参构造方法
隐式地构造方法：系统默认提供的无参构造方法

代码块：
分类：静态代码块和实例代码块
静态代码块：static修饰的代码块，在类加载时执行，且只执行一次。因为类就加载一次了。
实例代码块：没有static修饰的代码块，创建对象时执行，每创建一次对象加载一次。
实例代码块在执行构造方法之前执行。所以优先级高于构造方法。

从网上找了下，觉得解答的很好
1.从地址栏显示来说 
forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.
redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.
2.从数据共享来说 
forward:转发页面和转发到的页面可以共享request里面的数据.
redirect:不能共享数据.
3.从运用地方来说 
forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.
4.从效率来说 
forward:高.
redirect:低.
本质区别


解释一　　
一句话，转发是服务器行为，重定向是客户端行为。为什么这样说呢，这就要看两个动作的工作流程： 
转发过程：客户浏览器发送http请求----》web服务器接受此请求--》调用内部的一个方法在容器内部完成请求处理和转发动作----》将目标资源 发送给客户；在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客 户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。 

重定向过程：客户浏览器发送http请求----》web服务器接受后发送302状态码响应及对应新的location给客户浏览器--》客户浏览器发现 是302响应，则自动再发送一个新的http请求，请求url是新的location地址----》服务器根据此请求寻找资源并发送给客户。在这里 location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的 路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。 

解释二 
重定向，其实是两次request, 第一次，客户端request A,服务器响应，并response回来，告诉浏览器，你应该去B。这个时候IE可以看到地址变了，而且历史的回退按钮也亮了。重定向可以访问自己web应用以外的资源。在重定向的过程中，传输的信息会被丢失。
解释三
假设你去办理某个执照， 
重定向：你先去了A局，A局的人说：“这个事情不归我们管，去B局”，然后，你就从A退了出来，自己乘车去了B局。 
转发：你先去了A局，A局看了以后，知道这个事情其实应该B局来管，但是他没有把你退回来，而是让你坐一会儿，自己到后面办公室联系了B的人，让他们办好后，送了过来。
1.从地址栏显示来说
forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.
redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.

2.从数据共享来说
forward:转发页面和转发到的页面可以共享request里面的数据.
redirect:不能共享数据.

3.从运用地方来说
forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.

4.从效率来说
forward:高.
redirect:低.

Application
―Java应用程序”是可以独立运行的Java程序。
由Java解释器控制执行。
Applet
  ―Java小程序”不能独立运行（嵌入到Web页中）。
  由Java兼容浏览器控制执行。

Serverlets
是Java技术对CGI 编程的解决方案。
是运行于Web server上的、作为来自于Web browser 或其他HTTP client端的请求和在server上的数据库及其他应用程序之间的中间层程序。
Serverlets的工作是：
读入用户发来的数据（通常在web页的form中）
找出隐含在HTTP请求中的其他请求信息（如浏览器功能细节、请求端主机名等。
产生结果(调用其他程序、访问数据库、直接计算)
格式化结果（网页）
设置HTTP response参数(如告诉浏览器返回文档格式)
将文档返回给客户端。

程序设计六大原则
1、开闭原则（Open Close Principle）
开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。

2、里氏代换原则（Liskov Substitution Principle）
里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

3、依赖倒转原则（Dependence Inversion Principle）
这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

4、接口隔离原则（Interface Segregation Principle）
这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

5、迪米特法则，又称最少知道原则（Demeter Principle）
最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

6、合成复用原则（Composite Reuse Principle）
合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承

Statement是sql语句的载体
Statement是标准的Statement类，通过字符串对sql语句进行拼接，但是它存在sql注入的危险
PreparedStatement对sql语句进行了预编译，可以防止SQL注入
CallableStatement用来调用存储过程的
BatchedStatement用于批量操作数据库，BatchedStatement不是标准的Statement类

<<<<<<< HEAD

=======
File类的一下常用方法和说明
1.访问文件名相关方法：

String getName(); 返回此File对象所表示的文件名和路径名（如果是路径，则返回最后一级子路径名）。
String getPath(); 返回此File对象所对应的路径名。
File getAbsolutePath(); 返回此File对象所对应的绝对路径名。
String getParent(); 返回此File对象所对应目录（最后一级子目录）的父路径名。
boolean renameTo(File newName); 重命名此File对象所对应的文件或目录，如果重命名成功，则返回true:否则返回false.（A）
2.文件检测相关方法

boolean exists(); 判断File对象所对应的文件或目录是否存在。
boolean canWrite(); 判断File对象所对应的目录或文件是否可写。
boolean canRead(); 判断File对象所对应的目录或文件是否可读。
boolean isFile(); 判断File对象所对应的是否是文件，而不是目录。
boolean isDirectory(); 判断File对象所对应的是否是目录，而不是文件。
boolean isAbsolute(); 判断File对象所对应的文件或目录是否是绝对路径。该方法消除了不同平台的差异，可以直接判断File对象是否为绝对路径。在UNIX/Linux/BSD等系统上，如果路径名开头是一条斜线（/）,则表明该File对象对应一个绝对路径；在Windows等系统上，如果路径开头是盘符，则说明它是绝对路径。
3.获取常规文件信息

long lastModified(); 返回文件最后修改时间。
long length(); 返回文件内容的长度。
4.文件操作相关的方法

boolean createNewFile(); 当此File对象所对应的文件不存在时，该方法将新建的一个该File对象所指定的新文件，如果创建成功则返回true；否则返回false.(C)
boolean delete(); 删除File对象所对应的文件或路径。
static File CreateTempFile(String prefix,String suffix);在默认的临时文件目录创建一个临时空文件，使用给定前缀、系统生成的随机数和给定后缀作为文件名。这是一个静态方法，可以直接通过File来调用。preFix参数必须至少是3个字节长。建议前缀使用一个短的、有意义的字符串。建议前缀使用一个短的、有意义的字符串，比如”hjb“ 或”main”. suffix参数可以为null,在这种情况下，将使用默认的后缀”.tmp”.
static File CreateTempFile(String prefix,String suffix,File directory);在directory所指定的目录中创建一个临时空文件，使用给定前缀、系统生成的随机数和给定后缀作为文件名。这是一个静态方法，可以直接通过File来调用。
void deleteOnExit(); 注册一个删除钩子，指定当Java虚拟机退出时，删除File对象随对应的文件和目录。
5.目录操作相关方法（D）

boolean mkdir(); 试图创建一个File对象所对应的目录，如果创建成功，则返回true;否则返回false. 调用该方法时File对象必须对应一个路径，而不是一个文件。
String[] list(); 列出File对象的所有子文件名和路径名，返回String数组。
File[] listFiles(); 列出File对象的所有子文件和路径，返回File数组。
static File[] listRoots(); 列出系统所有的根路径。这是一个静态方法，可以直接通过File类来调用。
http://blog.csdn.net/nightcurtis/article/details/51385934



JVM
【https://www.nowcoder.com/test/question/done?tid=37669076&qid=14765#summary】

Java 锁

【http://ifeve.com/java_lock_see1/】

【http://ifeve.com/java_lock_see1/】

